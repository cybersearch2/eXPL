/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
package au.com.cybersearch2.classy_logic.parser;

import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.TemplateArchetype;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserContext;
import au.com.cybersearch2.classy_logic.compile.AxiomAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.ParserTask;
import au.com.cybersearch2.classy_logic.compile.SourceItem;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.LoopEvaluator;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.expression.Orientation;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.list.ListItemVariable;
import au.com.cybersearch2.classy_logic.list.ArrayIndex;
import au.com.cybersearch2.classy_logic.list.ArrayItemList;
import au.com.cybersearch2.classy_logic.list.ListIndex;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.LiteralParameter;
import au.com.cybersearch2.classy_logic.terms.LiteralType;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.interfaces.AssignType;
import au.com.cybersearch2.classy_logic.interfaces.ListItemSpec;
import au.com.cybersearch2.classy_logic.interfaces.LocaleListener;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser implements QueryParserConstants 
{

  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    parser.input(context);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    input(context);
    return queryProgram;
  }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, ParserContext context) throws ParseException
  {
    if (resourceName.length() < 3)
      throw new ParseException("Include resourceName \u005c"" + resourceName + "\u005c" is invalid");
    ParserResources parserResources = new ParserResources(context);
    try
    {
      parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
    }
    catch (IOException e)
    {
      throw new ParseException(e.getMessage());
    }
  }

  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  }

  protected Operand axiomContainerOperand(
          ParserAssembler parserAssembler,
          ListItemSpec[] indexData)
  {
      return axiomContainerOperand(parserAssembler, null, indexData);
  }

  protected Operand axiomContainerOperand(
      ParserAssembler parserAssembler,
      String name,
      ListItemSpec[] indexData)
  {
    QualifiedName listName = indexData[0].getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName.getName() + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = parserAssembler.addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand listItemOperand(
      ParserContext context,
      ListItemSpec indexData) throws ParseException
  {
      return listItemOperand(context, null, indexData);
  }

  protected Operand listItemOperand(
          ParserContext context,
          String name,
          ListItemSpec indexData) throws ParseException
  {

    QualifiedName listName = indexData.getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = context.getParserAssembler().addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand initList(
      ParserContext context,
      ListItemSpec indexData,
      Operand assignExpression) throws ParseException
  {
    if (assignExpression == null)
         throw new ParseException("Statement to initialize List \u005c"" + indexData.getListName() + "\u005c"  must be assigned a value");
    ParserAssembler parserAssembler = context.getParserAssembler();
    ArrayItemList<?> itemList = (ArrayItemList<?>) parserAssembler.getListAssembler().findItemList(indexData.getQualifiedListName());
    if (itemList == null)
         throw new ParseException("List \u005c"" + indexData.getListName() + "\u005c" must be declared before being initialized");
    int index = indexData.getItemIndex();
    if (index == -1)
         throw new ParseException("Invalid index \u005c"" + assignExpression.toString() + "\u005c" for list \u005c"" + indexData.getListName() + "\u005c" ");
    itemList.assignItem(index, assignExpression);
    return null; // No operand created indicated by null returned
  }

  protected SourceItem addSourceVariable(Operand var, ParserContext context)
  {
     int kind = context.getItemToken().kind;
     switch (kind)
     {
     case QueryParserConstants.INTEGER:
     case QueryParserConstants.BOOLEAN:
     case QueryParserConstants.DOUBLE:
     case QueryParserConstants.STRING:
     case QueryParserConstants.DECIMAL:
     case QueryParserConstants.CURRENCY:
     {
          String type = QueryParserConstants.tokenImage[kind];
          return context.addSourceItem(type.substring(1, type.length() - 1) + " " + var.toString());
     }
     default:
         return context.addSourceItem(var);
     }
  }

/** Root production. */
  final public void input(ParserContext context) throws ParseException
  {
    label_1:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case RESOURCE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ResourceDeclaration(context);
      jj_consume_token(SEMICOLON);
    }
    label_2:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      case SCOPE:
        ScopeDeclaration(context);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case SCOPE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(0);
    context.getQueryProgram().runPending();
  }

  final public void ResourceDeclaration(ParserContext context) throws ParseException
  {
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(RESOURCE);
    nameToken = jj_consume_token(STRING_LITERAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    context.getQueryProgram().openResource(getText(nameToken), properties);
  }

  final public void ScopeDeclaration(ParserContext context) throws ParseException
  {
  Token scopeToken;
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    scopeToken = jj_consume_token(SCOPE);
    nameToken = jj_consume_token(IDENTIFIER);
    context.setSourceMarker(scopeToken, nameToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    Scope scope = context.getQueryProgram().scopeInstance(nameToken.image , properties);
    context.setScope(scope);
    jj_consume_token(LBRACE);

    label_3:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
    context.resetScope();
  }

  final public void QueryChain(ParserContext context) throws ParseException
  {
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
  Token typeToken = null;
    queryToken = jj_consume_token(QUERY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case AXIOM:
        typeToken = jj_consume_token(AXIOM);
        break;
      case TERM:
        typeToken = jj_consume_token(TERM);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    querySpec = Query(context);
    context.setSourceMarker(queryToken, querySpec.getName());
    querySpec = QueryDeclaration(querySpec, context);
    label_4:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 78:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      chainToken = jj_consume_token(78);
      context.onTokenIntercept(chainToken);
      QueryDeclaration(querySpec.chain(), context);
    }
    jj_consume_token(SEMICOLON);
    context.getScope().addQuerySpec(querySpec);
    if (typeToken == null)
      {if (true) return;}
    ParserAssembler parserAssembler = context.getParserAssembler();
    VariableType varType = typeToken.kind == QueryParserConstants.AXIOM ? new VariableType(OperandType.AXIOM) : new VariableType(OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, querySpec.getKey());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, querySpec.getName());
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }

  final public QuerySpec Query(ParserContext context) throws ParseException
  {
   Token queryToken;
    queryToken = jj_consume_token(IDENTIFIER);
    {if (true) return new QuerySpec(queryToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  KeyName firstKeyname;
  KeyName keyname;
  Token delimitToken;
  SourceItem sourceItem;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(firstKeyname.toString());
    label_5:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      delimitToken = jj_consume_token(COMMA);
          sourceItem.setEnd(delimitToken);
      keyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(keyname.toString());
            ++keynameCount;
    }
    delimitToken = jj_consume_token(RPAREN);
        sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
        {if (true) return context.getScope().buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  String name1;
  String name2 = null;
    name1 = Name(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
      jj_consume_token(COLON);
      name2 = Name(context);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    {if (true) return keyname;}
    throw new Error("Missing return statement in function");
  }

  final public void Statement(ParserContext context) throws ParseException
  {
  Operand var;
  context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      VariableInitialization(context);
      break;
    case AXIOM:
      AxiomDeclaration(context);
      break;
    case LIST:
    case LOCAL:
      ListDeclaration(context);
      break;
    case TEMPLATE:
      TemplateDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case CALC:
      CalculatorTemplate(context);
      jj_consume_token(SEMICOLON);
      break;
    case CHOICE:
      ChoiceDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case INCLUDE:
      Include(context);
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AxiomDeclaration(ParserContext context) throws ParseException
  {
  QualifiedName qualifiedAxiomName;
  SourceItem sourceItem;
  Token axiomToken;
  Token delimitToken;
  String axiomSpec;
  Operand operand = null;
    axiomToken = jj_consume_token(AXIOM);
    qualifiedAxiomName = Axiom(context);
    context.setSourceMarker(axiomToken, qualifiedAxiomName);
    context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      axiomSpec = AxiomSpecification(qualifiedAxiomName, context);
      sourceItem = context.addSourceItem(axiomSpec);
      break;
    case ASSIGN:
      operand = AxiomVariable(qualifiedAxiomName, context);
       context.getOperandMap().addOperand(operand);
       sourceItem = context.addSourceItem(operand);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    delimitToken = jj_consume_token(SEMICOLON);
     sourceItem.setEnd(delimitToken);
  }

  final public QualifiedName Axiom(ParserContext context) throws ParseException
  {
  String axiomName;
    axiomName = Name(context);
    {if (true) return axiomName.indexOf(".") == -1 ?
        context.getParserAssembler().getContextName(axiomName) :
        QualifiedName.parseName(axiomName);}
    throw new Error("Missing return statement in function");
  }

  final public String AxiomSpecification(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  String termName;
  Token resouceToken;
  QualifiedName resourceBinding;
  int index = 0;
  StringBuilder builder = new StringBuilder(qualifiedAxiomName.getName());
  ParserAssembler parserAssembler = context.getParserAssembler();
  parserAssembler.getListAssembler().createAxiomItemList(qualifiedAxiomName);
    jj_consume_token(LPAREN);
    builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      termName = TermName(qualifiedAxiomName, parserAssembler);
          builder.append(termName);
      label_6:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        termName = TermName(qualifiedAxiomName, parserAssembler);
            builder.append(',').append(termName);
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACE:
    case COLON:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        resouceToken = jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case RESOURCE:
        case STRING_LITERAL:
          resourceBinding = ResourceBinding(QueryParserConstants.AXIOM, qualifiedAxiomName, parserAssembler);
            builder.append(':');
            if (resouceToken.next != null)
                builder.append(resouceToken.next);
          break;
        case PARAMETER:
          ParameterDeclaration(qualifiedAxiomName, parserAssembler);
            builder.append(":parameter");
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LBRACE:
        label_7:
        while (true) 
        {
          jj_consume_token(LBRACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case STRING_LITERAL:
          case TRUE:
          case FALSE:
          case UNKNOWN:
          case NAN:
            AxiomItem(qualifiedAxiomName, context);
            break;
          case BIT_OR:
            AltAxiomItem(qualifiedAxiomName, context);
            break;
          default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        ++index;
          jj_consume_token(RBRACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_7;
          }
        }
      builder.append('[').append(Integer.toString(index)).append(']');
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    parserAssembler.getAxiomAssembler().addAxiomTermName(qualifiedAxiomName, nameToken.image);
    {if (true) return nameToken.image;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName ResourceBinding(int kind, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case STRING_LITERAL:
      nameToken = jj_consume_token(STRING_LITERAL);
      break;
    case RESOURCE:
      jj_consume_token(RESOURCE);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    QualifiedName qualifiedBindingName =
        kind == QueryParserConstants.TEMPLATE ?
        new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName()) :
        qualifiedAxiomName;
    AxiomProvider axiomProvider = (nameToken != null) ?
        parserAssembler.bindResource(QualifiedName.parseName(getText(nameToken)), qualifiedBindingName) :
        parserAssembler.bindResource(qualifiedBindingName);
    {if (true) return qualifiedBindingName;}
    throw new Error("Missing return statement in function");
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    Fact(qualifiedAxiomName, context);
    label_8:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, context);
    }
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }

  final public void AltAxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    jj_consume_token(BIT_OR);
    Fact(qualifiedAxiomName, context);
    label_9:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_9;
      }
      jj_consume_token(BIT_OR);
      Fact(qualifiedAxiomName, context);
    }
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }

  final public String Fact(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  Parameter param = null;
  Token lit = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param = LiteralTerm(context);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, param);
    {if (true) return param.getValue().toString();}
      break;
    case NAN:
      jj_consume_token(NAN);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
    {if (true) return "NaN";}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  Operand expression = null;
  List<Template> axiomList = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      expression = Expression(context);
      break;
    case LBRACE:
      axiomList = AxiomList(qualifiedAxiomName, context);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     VariableType varType = new VariableType(axiomList == null ? OperandType.AXIOM : OperandType.LIST);
     if (expression != null)
         varType.setProperty(VariableType.EXPRESSION, expression);
     else
         varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     if (expression != null)
         parserAssembler.setParameter(operand.getQualifiedName());
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public List<Template> AxiomList(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  List<Template> templateParamList = new ArrayList<Template>();
  Template template;
    template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
    templateParamList.add(template);
    label_10:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_10;
      }
      template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
     templateParamList.add(template);
    }
    {if (true) return templateParamList;}
    throw new Error("Missing return statement in function");
  }

  final public Template AxiomInitializer(String listName, QualifiedName axiomName, ParserContext context) throws ParseException
  {
  Template initializeTemplate = null;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
      initializeTemplate = Parameters(listName, context, true);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
     if (initializeTemplate != null)
       {if (true) return initializeTemplate;}
     TemplateArchetype architype = new TemplateArchetype(new QualifiedTemplateName(context.getScope().getAlias(), axiomName.getName()));
     {if (true) return new Template(architype);}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateDeclaration(ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  QualifiedName contextName = context.getContextName();
    templateToken = jj_consume_token(TEMPLATE);
    template = Template(context, false);
    jj_consume_token(LPAREN);
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(templateToken, template.getQualifiedName());
    expression = TemplateExpression(template, context);
      template.addTerm(expression);
      sourceItem = addSourceVariable(expression, context);
    label_11:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_11;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      expression = TemplateExpression(template, context);
        template.addTerm(expression);
        sourceItem = addSourceVariable(expression, context);
    }
    delimitToken = jj_consume_token(RPAREN);
    context.setContextName(contextName);
    sourceItem.setEnd(delimitToken);
  }

  final public Template Template(ParserContext context, boolean isCalculator) throws ParseException
  {
  Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), templateToken.image);
    context.setContextName(qualifiedTemplateName);
    {if (true) return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, isCalculator);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorTemplate(ParserContext context) throws ParseException
  {
  Template template;
  Token calcToken;
  Token delimitToken;
  Operand operand;
  SourceItem sourceItem;
  Token privateToken = null;
  Map<String, Object> properties = new HashMap<String, Object>();
  ParserAssembler parserAssembler = context.getParserAssembler();
  QualifiedName contextName = context.getContextName();
    calcToken = jj_consume_token(CALC);
    template = Template(context, true);
    jj_consume_token(LPAREN);
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(calcToken, template.getQualifiedName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case DOT:
      privateToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case AXIOM:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case BANG:
    case COLON:
    case QMARK:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      operand = CalculatorExpression(template, template.getQualifiedName(), context);
      break;
    case 79:
      operand = CalculatorQuery(template, context);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (privateToken != null)
      operand.setPrivate(true);
    privateToken = null;
    sourceItem = addSourceVariable(operand, context);
    label_12:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_12;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case AXIOM:
      case SCOPE:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case COLON:
      case QMARK:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 81:
        operand = CalculatorExpression(template, template.getQualifiedName(), context);
        break;
      case 79:
        operand = CalculatorQuery(template, context);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (privateToken != null)
        operand.setPrivate(true);
      privateToken = null;
      sourceItem = addSourceVariable(operand, context);
    }
    delimitToken = jj_consume_token(RPAREN);
      sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    if (properties.size() > 0)
        template.addProperties(properties);
    context.setContextName(contextName);
  }

  final public Operand TemplateExpression(Template template, ParserContext context) throws ParseException
  {
    String name;
    QualifiedName qname;
    QualifiedName axiomQname;
    String axiomName = null;
    VariableType varType = null;
    Operand var = null;
    Token scToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Token interceptToken = null;
    Operand expression = null;
    ListItemSpec[] listIndexData = null;
    Group group = null;
    ParserAssembler parserAssembler = context.getParserAssembler();
    OperandMap operandMap = parserAssembler.getOperandMap();
    List<Parameter> literalList = null;
    List<Template> axiomList = null;
    Template parameterTemplate = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    name = Name(context);
    qname = parserAssembler.getContextName(name);
    axiomQname = qname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
    case XOR:
      listIndexData = IndexExpression(context.getQualifiedName(name), context);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case REGEX:
    case LPAREN:
    case LBRACE:
    case ASSIGN:
    case COLON:
    case QMARK:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
      case PLUSASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case ASSIGN:
          equalsToken = jj_consume_token(ASSIGN);
          break;
        case PLUSASSIGN:
          assignToken = jj_consume_token(PLUSASSIGN);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case AXIOM:
          jj_consume_token(AXIOM);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case IDENTIFIER:
            axiomName = Name(context);
             axiomQname = QualifiedName.parseName(axiomName);
            break;
          default:
            jj_la1[39] = jj_gen;
            ;
          }
          axiomList = AxiomList(axiomQname, context);
         VariableType axiomListVarType = new VariableType(OperandType.LIST);
         axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
         if (axiomName != null)
           axiomListVarType.setProperty(VariableType.AXIOM_KEY, axiomQname);
         expression = axiomListVarType.getInstance(parserAssembler, axiomQname);
          break;
        case SCOPE:
        case FACT:
        case LENGTH:
        case FORMAT:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case 81:
          expression = Expression(context);
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case COLON:
      case QMARK:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case QMARK:
          scToken = jj_consume_token(QMARK);
          break;
        case MINUSASSIGN:
          assignToken = jj_consume_token(MINUSASSIGN);
          break;
        case STARASSIGN:
          assignToken = jj_consume_token(STARASSIGN);
          break;
        case SLASHASSIGN:
          assignToken = jj_consume_token(SLASHASSIGN);
          break;
        case ANDASSIGN:
          assignToken = jj_consume_token(ANDASSIGN);
          break;
        case ORASSIGN:
          assignToken = jj_consume_token(ORASSIGN);
          break;
        case XORASSIGN:
          assignToken = jj_consume_token(XORASSIGN);
          break;
        case REMASSIGN:
          assignToken = jj_consume_token(REMASSIGN);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        expression = Expression(context);
        break;
      case REGEX:
        interceptToken = jj_consume_token(REGEX);
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          regexLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          regexId = jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LBRACE:
          group = GroupDeclaration(template, name, parserAssembler);
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      case LBRACE:
        interceptToken = jj_consume_token(LBRACE);
        literalList = LiteralList(context);
        jj_consume_token(RBRACE);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case INTEGER:
        case DOUBLE:
        case DECIMAL:
        case BOOLEAN:
        case STRING:
        case TERM:
        case CURRENCY:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
          parameterTemplate = Parameters(name, context, true);
          break;
        default:
          jj_la1[44] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
             template.addTerm(parserAssembler.getCallOperand(qname, parameterTemplate));
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    boolean isDeclaration = varType != null;
    boolean hasOperand = operandMap.hasOperand(name, parserAssembler.getQualifiedContextname());
    if (!isDeclaration)
      varType = new VariableType(OperandType.UNKNOWN);
    Operand assignExpression = (assignToken != null) ? expression : null;
    Operand regexOp = null;
    if (regexLit != null)
      regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
    else if (regexId != null)
      regexOp = operandMap.addOperand(regexId.image, null, parserAssembler.getQualifiedContextname());
    if (assignToken != null)
      expression = null;
    if (expression != null)
      varType.setProperty(VariableType.EXPRESSION, expression);
    if (listIndexData !=null)
      var = listIndexData.length == 1 ? listItemOperand(context, listIndexData[0]) : axiomContainerOperand(parserAssembler, listIndexData);
    else if (regexOp != null)
      var = new RegExOperand(qname, regexOp, 0, group);
    else if (scToken != null)
      var = new Evaluator(qname, expression, (scToken.image == "?" ? "&&" : "||"), Orientation.unary_postfix);
    else if (literalList != null)
      var = new LiteralListOperand(qname, literalList);
    else
      var = operandMap.getOperand(qname);
    if ((var != null) && isDeclaration)
       operandMap.duplicateOperandCheck(qname);
    if ((var == null) && !hasOperand)
      var = varType.getInstance(parserAssembler, name);
    if (var == null)
      var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
    if ((listIndexData == null) && (!hasOperand))
      operandMap.addOperand(var);
    if (assignToken != null)
      var = parserAssembler.createReflexiveEvaluator(var, assignToken.image, assignExpression);
    if ((equalsToken != null) && (listIndexData !=null))
      var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
    else if (hasOperand && (equalsToken != null))
      var = new Evaluator(parserAssembler.getContextName(var.getName() + var.getQualifiedName().incrementReferenceCount()), var, "=", expression);
    if (interceptToken != null)
      context.onTokenIntercept(interceptToken);
    {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorExpression(Template template, QualifiedName outerTemplateName, ParserContext context) throws ParseException
  {
  Token literalToken;
  Token delimitToken;
  Token choiceToken;
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
    case QMARK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        scToken = jj_consume_token(COLON);
        break;
      case QMARK:
        scToken = jj_consume_token(QMARK);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      context.onTokenIntercept(scToken);
      expression = Expression(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        delimitToken = jj_consume_token(LBRACE);
        Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName, "");
        context.addSourceItem(scToken.image+expression.toString()).setEnd(delimitToken);
        context.pushSourceMarker();
        Token token = Token.newToken(QueryParserConstants.CALC);
        token.beginLine = delimitToken.beginLine;
        token.beginColumn = delimitToken.beginColumn;
        context.setSourceMarker(token, innerTemplate.getQualifiedName());
        innerLoop = InnerCalculator(innerTemplate, outerTemplateName, context, true);
      context.popSourceMarker();
      context.onTokenIntercept(delimitToken);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
    String operator = scToken.image == "?" ? "&&" : "||";
    expression = innerLoop == null ? new Evaluator(expression, operator, Orientation.unary_postfix) : new Evaluator(expression, operator, innerLoop);
    expression.setPrivate(true);
    template.addTerm(expression);
    {if (true) return expression;}
      break;
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
      case IDENTIFIER:
        expression = TemplateExpression(template, context);
        break;
      case SCOPE:
      case FACT:
      case LENGTH:
      case FORMAT:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 81:
        expression = Expression(context);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    template.addTerm(expression);
    {if (true) return expression;}
      break;
    case LBRACE:
      delimitToken = jj_consume_token(LBRACE);
      context.onTokenIntercept(delimitToken);
      context.pushSourceMarker();
      Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName, "");
      Token token = Token.newToken(QueryParserConstants.CALC);
      token.beginLine = delimitToken.beginLine;
      token.beginColumn = delimitToken.beginColumn;
      context.setSourceMarker(token, innerTemplate.getQualifiedName());
      innerLoop = InnerCalculator(innerTemplate, outerTemplateName, context, false);
      context.checkForShortCircuit();
      context.popSourceMarker();
    template.addTerm(innerLoop);
    context.onTokenIntercept(delimitToken);
    {if (true) return innerLoop;}
      break;
    case AXIOM:
      literalToken = jj_consume_token(AXIOM);
    context.onTokenIntercept(literalToken);
      qualifiedAxiomName = Axiom(context);
      expression = AxiomVariable(qualifiedAxiomName, context);
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
    {if (true) return expression;}
      break;
    case CHOICE:
      literalToken = jj_consume_token(CHOICE);
    context.onTokenIntercept(literalToken);
      choiceToken = jj_consume_token(IDENTIFIER);
    qualifiedAxiomName = QualifiedName.parseName(choiceToken.image);
    qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplateAssembler().createChoiceTemplate(template, qualifiedTemplateName);
    OperandMap operandMap = parserAssembler.getOperandMap();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    for (String termName: axiomAssembler.getTermNameList(qualifiedAxiomName))
      operandMap.addOperand(termName, null, parserAssembler.getQualifiedContextname());
    QualifiedName contextName = context.getContextName();
    QualifiedName qname = QualifiedName.parseName(qualifiedAxiomName.getName(), contextName);
        Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
    {if (true) return choiceOperand;}
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorQuery(Template template, ParserContext context) throws ParseException
  {
  Token queryToken;
  Token delimitToken;
  String queryName;
  String callName;
  QualifiedName qname;
  QualifiedName outerTemplateName = template.getQualifiedName();
  Template innerTemplate = null;
  Template parameterTemplate = null;
    queryToken = jj_consume_token(79);
    context.onTokenIntercept(queryToken);
    context.pushSourceMarker();
    queryName = Name(context);
    qname = context.getQualifiedName(queryName);
    callName = qname.getName();
    Token token = Token.newToken(QueryParserConstants.QUERY);
    token.beginLine = queryToken.beginLine;
    token.beginColumn = queryToken.beginColumn;
    context.setSourceMarker(token, queryName);
    context.setSourceItemPending(false);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
      parameterTemplate = Parameters(callName, context, false);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(RPAREN);
    int reference = qname.incrementReferenceCount();
    if (reference > 0)
       qname = new QualifiedName(qname.getName() + reference, qname);
    context.addCalcQuery(qname, parameterTemplate).setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case 78:
      innerTemplate = InnerTemplateDeclaration(outerTemplateName, callName, context);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
    Operand queryOperand = context.getParserAssembler().getQueryOperand(queryName, qname, parameterTemplate, innerTemplate);
    template.addTerm(queryOperand);
    context.popSourceMarker();
    {if (true) return queryOperand;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplateDeclaration(QualifiedName outerTemplateName, String callName, ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String queryKey = outerTemplateName.getTemplate() + "." + callName;
    templateToken = jj_consume_token(78);
      ParserAssembler parserAssembler = context.getParserAssembler();
      template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName, callName);
      template.setKey(queryKey);
      context.onTokenIntercept(templateToken);
    delimitToken = jj_consume_token(LPAREN);
      context.addSourceItem(">> " + template.getQualifiedName().toString()).setEnd(delimitToken);
    expression = TemplateExpression(template, context);
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
    label_13:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_13;
      }
      delimitToken = jj_consume_token(COMMA);
          sourceItem.setEnd(delimitToken);
      expression = TemplateExpression(template, context);
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
    }
    delimitToken = jj_consume_token(RPAREN);
        sourceItem.setEnd(delimitToken);
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Operand InnerCalculator(Template template, QualifiedName outerTemplateName, ParserContext context, boolean runOnce) throws ParseException
  {
  Operand expression;
  SourceItem sourceItem;
  Token delimitToken;
  context.setSourceItemPending(true);
    expression = CalculatorExpression(template, outerTemplateName, context);
     sourceItem=addSourceVariable(expression, context);
    label_14:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_14;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      expression = CalculatorExpression(template, outerTemplateName, context);
      sourceItem=addSourceVariable(expression, context);
    }
    delimitToken = jj_consume_token(RBRACE);
    LoopEvaluator loopEvaluator = new LoopEvaluator(template, runOnce);
    sourceItem.setEnd(delimitToken);
    {if (true) return loopEvaluator;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName ChoiceDeclaration(ParserContext context) throws ParseException
  {
  Token choiceToken;
  Token delimitToken;
  QualifiedName qualifiedAxiomName;
  int selection = 0;
  boolean isSourceItemPending = context.isSourceItemPending();
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  QualifiedName contextName = context.getContextName();
    choiceToken = jj_consume_token(CHOICE);
    qualifiedAxiomName = Choice(context);
    if (!isSourceItemPending)
      context.setSourceMarker(choiceToken, qualifiedAxiomName);
    jj_consume_token(LPAREN);
    TermName(qualifiedAxiomName, parserAssembler);
    label_15:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      TermName(qualifiedAxiomName, parserAssembler);
    }
    delimitToken = jj_consume_token(RPAREN);
    context.addChoiceItem(qualifiedAxiomName).setEnd(delimitToken);
    label_16:
    while (true) 
    {
      ChoiceItem(selection++, qualifiedAxiomName, context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_16;
      }
    }
    context.setContextName(contextName);
    {if (true) return qualifiedAxiomName;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Choice(ParserContext context) throws ParseException
  {
    Token choiceToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    Scope scope = context.getScope();
    choiceToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.getListAssembler().createAxiomItemList(qualifiedChoiceName);
    parserAssembler.getTemplateAssembler().createTemplate(qualifiedChoiceName, true);
    context.setContextName(new QualifiedTemplateName(scope.getAlias(), choiceToken.image));
    {if (true) return qualifiedChoiceName;}
    throw new Error("Missing return statement in function");
  }

  final public void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    Operand operand;
    String fact;
    Token delimToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    String name = axiomAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new StringTerm(name + selection));
    StringBuilder builder = new StringBuilder();
    jj_consume_token(LBRACE);
    operand = ChoiceExpression(name, context);
     builder.append('{').append(operand.toString());
    label_17:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      fact = Fact(qualifiedAxiomName, context);
        builder.append(',').append(fact);
    }
    delimToken = jj_consume_token(RBRACE);
       parserAssembler.getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.getTemplateAssembler().addTemplate(qualifiedTemplateName, operand);
       builder.append('}');
       context.addSourceItem(builder.toString()).setEnd(delimToken);
  }

  final public Operand ChoiceExpression(String name, ParserContext context) throws ParseException
  {
    Operand operand;
    QualifiedName qname = context.getParserAssembler().getContextName(name);
    operand = Expression(context);
      if (operand instanceof Evaluator)
          {if (true) return new Evaluator(qname, operand, "&&", Orientation.unary_postfix );}
      if (operand instanceof StringOperand)
          {if (true) return new RegExOperand(qname, operand, 0, null);}
      {if (true) return new MatchOperand(qname, operand);}
    throw new Error("Missing return statement in function");
  }

  final public void InitialiserList(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String property;
  SourceItem sourceItem;
  Token delimitToken;
    jj_consume_token(LPAREN);
    property = InitialiserDeclaration(properties, context);
    sourceItem = context.addSourceItem(property);
    label_18:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_18;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      property = InitialiserDeclaration(properties, context);
      sourceItem = context.addSourceItem(property);
    }
    delimitToken = jj_consume_token(RPAREN);
    sourceItem.setEnd(delimitToken);
  }

  final public String InitialiserDeclaration(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String name;
  Parameter param;
    name = Name(context);
    jj_consume_token(ASSIGN);
    param = LiteralTerm(context);
     properties.put(name, param.getValue());
     {if (true) return name + "=" + param.getValue().toString();}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Group group = new Group(name);
    jj_consume_token(LBRACE);
    Group(group, template, name, parserAssembler);
    label_19:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      Group(group, template, name, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Token groupToken;
    groupToken = jj_consume_token(IDENTIFIER);
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null, parserAssembler.getQualifiedContextname());
    template.addTerm(var);
    group.addGroup(var);
    var.setPrivate(true);
  }

  final public List<Parameter> LiteralList(ParserContext context) throws ParseException
  {
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
    parameter = LiteralTerm(context);
    literalList.add(parameter);
    label_20:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_20;
      }
      jj_consume_token(COMMA);
      parameter = LiteralTerm(context);
      literalList.add(parameter);
    }
    {if (true) return literalList;}
    throw new Error("Missing return statement in function");
  }

  final public void VariableInitialization(ParserContext context) throws ParseException
  {
  Operand var;
  Token delimitToken;
    var = VariableDeclaration(context);
    delimitToken = jj_consume_token(SEMICOLON);
      if (var == null)
        {if (true) return;}
      context.getOperandMap().addOperand(var);
      context.setSourceMarker(context.getItemToken(), var.getQualifiedName());
      addSourceVariable(var, context).setEnd(delimitToken);
  }

  final public Operand VariableDeclaration(ParserContext context) throws ParseException
  {
  Token nameToken;
  boolean isUntyped = true;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  Operand expression = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  context.setSourceItemPending(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      isUntyped = false;
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    if (isUntyped)
      context.onTokenIntercept(nameToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
    case XOR:
      listIndexData = IndexExpression(context.getQualifiedName(nameToken.image), context);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(context);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
     String name = nameToken.image;
     if ((listIndexData !=null) && (listIndexData.length > 1))
       {if (true) throw new ParseException("Axiom list variable \u005c"" + name + "\u005c" cannot be declared here");}
     if (listIndexData !=null)
       {if (true) return initList(context, listIndexData[0], expression);}
     if (isUntyped)
       varType = new VariableType(OperandType.UNKNOWN);
     if (expression != null) //  Need literal condition? && !(expression instanceof Evaluator)
       varType.setProperty(expression.isEmpty() ? VariableType.EXPRESSION : VariableType.LITERAL, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void ListDeclaration(ParserContext context) throws ParseException
  {
  Token keywordToken;
  Token nameToken;
  Token delimitToken;
  String listName;
  VariableType varType = null;
  QualifiedName qualifiedBindingName = null;
  QualifiedName qualifiedAxiomName = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LIST:
      keywordToken = jj_consume_token(LIST);
      break;
    case LOCAL:
      keywordToken = jj_consume_token(LOCAL);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      varType = Type(context);
      jj_consume_token(GT);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    listName = nameToken.image;
    context.setSourceMarker(keywordToken, listName);
    context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      qualifiedAxiomName = Axiom(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        jj_consume_token(COLON);
        qualifiedBindingName = ResourceBinding(QueryParserConstants.TEMPLATE, qualifiedAxiomName, parserAssembler);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(SEMICOLON);
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    boolean isTermList = (varType != null) && varType.getOperandType() == OperandType.TERM;
    if ((varType == null) && (qualifiedAxiomName == null))
        {if (true) throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Missing type or axiom name.");}
    if ((varType != null) && isLocal)
        {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Type in declaration not allowed.");}
    if ((qualifiedBindingName != null) && !isTermList)
        {if (true) throw new ParseException("Invalid declaration for " + keywordToken.image + " \u005c"" + listName + "\u005c". Only Term type list can be bound to a resource");}
    if (qualifiedBindingName != null)
        qualifiedAxiomName = qualifiedBindingName;
    if (varType == null)
        varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
        varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
    context.addSourceItem(itemList).setEnd(delimitToken);
  }

  final public void Include(ParserContext context) throws ParseException
  {
  Token includeToken = null;
    jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    includeResource(includeToken.image, context);
  }

  final public Operand Expression(ParserContext context) throws ParseException
  {
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
    param = ConditionalOrExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      assignOperand = Expression(context);
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return new Evaluator(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PrimaryExpression(ParserContext context) throws ParseException
  {
  Operand operand;
  QualifiedName qname;
  ListItemSpec[] listIndexData;
  String name = null;
  Token literal = null;
  Operand param1 = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal(context);
    {if (true) return param1;}
      break;
    case IDENTIFIER:
      name = Name(context);
      if (jj_2_1(2)) 
      {
        param1 = NamedExpression(name, context);
      } else 
      {
        ;
      }
    if (param1 == null)
        {if (true) return parserAssembler.addOperand(name);}
    {if (true) return param1;}
      break;
    case SCOPE:
      literal = jj_consume_token(SCOPE);
      listIndexData = IndexExpression(context.getQualifiedName("scope"), context);
    if (listIndexData.length > 1)
         {if (true) throw new ParseException("Scope cannot be accessed using axiom list variable");}
    operand = listItemOperand(context, listIndexData[0]);
    context.onTokenIntercept(literal);
    {if (true) return operand;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      param1 = Expression(context);
      jj_consume_token(RPAREN);
    {if (true) return param1;}
      break;
    case LENGTH:
      literal = jj_consume_token(LENGTH);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    QualifiedName listName = context.getQualifiedName(name);
    qname = new QualifiedName(listName.getName().toString() + "_length", listName);
    ListLength listLength = new ListLength(qname, listName);
    ParserTask parserTask = context.getParserAssembler().addPending(listLength);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    context.onTokenIntercept(literal);
    {if (true) return listLength;}
      break;
    case FORMAT:
      literal = jj_consume_token(FORMAT);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        {if (true) throw new ParseException("Variable \u005c"" + name + "\u005c" not found");}
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    context.onTokenIntercept(literal);
    {if (true) return formatter;}
      break;
    case FACT:
      literal = jj_consume_token(FACT);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    Operand factOperand = parserAssembler.findOperandByName(name);
    context.onTokenIntercept(literal);
    if (factOperand != null)
        {if (true) return new FactOperand(factOperand);}
    else
        {if (true) throw new ParseException("Operand " + name + " not found");}
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ListItemSpec[] IndexExpression(QualifiedName listName, ParserContext context) throws ParseException
  {
  Object index1;
  Object index2 = null;
  int dimension = 1;
    index1 = ListSelection(context);
    if (jj_2_2(2)) 
    {
      index2 = ListSelection(context);
                                                                                     ++dimension;
    } else 
    {
      ;
    }
     if ((dimension == 2) && (index1 instanceof String))
       {if (true) throw new ParseException("Axiom list \u005c"" + listName.getName() + "\u005c" axiom cannot be selected by name");}
     if ((dimension == 1) && (index1 instanceof String))
       {if (true) return new ListItemSpec[] { new ListIndex(listName, (String)index1) };}
     if (dimension == 1)
       {if (true) return new ListItemSpec[] { new ListIndex(listName, (Operand)index1) };}
     ListItemSpec listItemSpec1 = null;
     if (index1 instanceof String)
         listItemSpec1 = new ListIndex(listName, (String)index1);
     else
         listItemSpec1 = new ArrayIndex(listName, (Operand)index1);
     ListItemSpec listItemSpec2 = null;
     if (index2 instanceof String)
       listItemSpec2 = new ListIndex(listName, (String)index2);
     else
       listItemSpec2 = new ListIndex(listName, (Operand)index2);
     {if (true) return new ListItemSpec[] { listItemSpec1, listItemSpec2 };}
    throw new Error("Missing return statement in function");
  }

  final public Object ListSelection(ParserContext context) throws ParseException
  {
  Token name;
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      param = Expression(context);
      jj_consume_token(RBRACKET);
    {if (true) return param;}
      break;
    case XOR:
      jj_consume_token(XOR);
      name = jj_consume_token(IDENTIFIER);
    {if (true) return name.image;}
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand Literal(ParserContext context) throws ParseException
  {
  Token lit;
  Operand operand;
  boolean flag;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    Long litValue = Long.decode(lit.image);
    operand = new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    operand = new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    operand = new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableType Type(ParserContext context) throws ParseException
  {
  Token literalToken;
  VariableType varType;
  Token qualifierLit = null;
  String qualifierId = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
      literalToken = jj_consume_token(INTEGER);
      varType = new VariableType(OperandType.INTEGER);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case BOOLEAN:
      literalToken = jj_consume_token(BOOLEAN);
      varType = new VariableType(OperandType.BOOLEAN);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DOUBLE:
      literalToken = jj_consume_token(DOUBLE);
      varType = new VariableType(OperandType.DOUBLE);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case STRING:
      literalToken = jj_consume_token(STRING);
      varType = new VariableType(OperandType.STRING);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DECIMAL:
      literalToken = jj_consume_token(DECIMAL);
      varType = new VariableType(OperandType.DECIMAL);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case TERM:
      literalToken = jj_consume_token(TERM);
      varType = new VariableType(OperandType.TERM);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case CURRENCY:
      literalToken = jj_consume_token(CURRENCY);
      context.onTokenIntercept(literalToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 80:
        jj_consume_token(80);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          qualifierLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          qualifierId = Name(context);
          break;
        default:
          jj_la1[73] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
      varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, context.getOperandMap().addOperand(qualifierId, null, context.getParserAssembler().getQualifiedContextname()));
       {if (true) return varType;}
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(PARAMETER);
    parserAssembler.setParameter(qualifiedAxiomName);
  }

  final public String Name(ParserContext context) throws ParseException
  {
  String name;
  Token partToken;
    partToken = jj_consume_token(IDENTIFIER);
    name = partToken.image;
    context.onTokenIntercept(partToken);
    label_21:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_21;
      }
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      name += ("." + partToken.image);
    }
    {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public Operand NamedExpression(String name, ParserContext context) throws ParseException
  {
  ListItemSpec[] indexData;
  Template parametersTemplate = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
    case XOR:
      indexData = IndexExpression(context.getQualifiedName(name), context);
    {if (true) return indexData.length == 1 ?
    listItemOperand(context, indexData[0]) :
    axiomContainerOperand(parserAssembler, indexData);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
        parametersTemplate = Parameters(name, context, true);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    QualifiedName qname = parserAssembler.getContextName(name);
    {if (true) return parserAssembler.getCallOperand(qname, parametersTemplate);}
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Template Parameters(String callName, ParserContext context, boolean nameRequired) throws ParseException
  {
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  String functionKey = outerTemplateName.getTemplate() + "." + callName;
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName, callName);
  template.setKey(functionKey);
    expression = ParameterExpression(context, nameRequired);
      template.addTerm(expression);
    label_22:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_22;
      }
      jj_consume_token(COMMA);
      expression = ParameterExpression(context, nameRequired);
        template.addTerm(expression);
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Operand ParameterExpression(ParserContext context, boolean nameRequired) throws ParseException
  {
  Token identifier = null;
  Parameter parameter = null;
  Operand expression = null;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[80] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      identifier = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACKET:
      case XOR:
        listIndexData = IndexExpression(context.getQualifiedName(identifier.image), context);
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      parameter = LiteralTerm(context);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(context);
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
     String name = (identifier == null) ? Term.ANONYMOUS : identifier.image;
     QualifiedName qname = parserAssembler.getContextName(name);
     Operand var = null;
     if (parameter != null)
       var = new Variable(qname);
     if (var != null)
       var.assign(parameter);
     if ((var == null) && (varType == null))
       var = parserAssembler.getOperandMap().getOperand(qname);
     if (var != null)
       {if (true) return var;}
     if (operandMap.hasOperand(name, parserAssembler.getQualifiedContextname()))
         var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
     if (var != null)
       {if (true) {if (true) return var;}}
     if (listIndexData !=null)
       var = listIndexData.length == 1 ? listItemOperand(context, name, listIndexData[0]) : axiomContainerOperand(parserAssembler, name, listIndexData);
     if (var != null)
       {if (true) return var;}
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     if (varType.getOperandType() == OperandType.TERM)
       varType.setUnknownType();
     if (expression != null)
       varType.setProperty(VariableType.EXPRESSION, expression);
     {if (true) return varType.getInstance(parserAssembler, name);}
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm(ParserContext context) throws ParseException
  {
  Token lit;
  Parameter param;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    param = new IntegerTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    param = new DoubleTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    param = new StringTerm(getText(lit));
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanTerm(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new LiteralParameter(Term.ANONYMOUS, new Unknown(), LiteralType.unknown);}
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TRUE:
      lit = jj_consume_token(TRUE);
    context.onTokenIntercept(lit);
    {if (true) return true;}
      break;
    case FALSE:
      lit = jj_consume_token(FALSE);
    context.onTokenIntercept(lit);
    {if (true) return false;}
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    lit = jj_consume_token(UNKNOWN);
    context.onTokenIntercept(lit);
  }

  final public Operand ConditionalOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ConditionalAndExpression(context);
    label_23:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_23;
      }
      op = jj_consume_token(SC_OR);
      params[1] = ConditionalAndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalAndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = InclusiveOrExpression(context);
    label_24:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[87] = jj_gen;
        break label_24;
      }
      op = jj_consume_token(SC_AND);
      params[1] = InclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand InclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ExclusiveOrExpression(context);
    label_25:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_25;
      }
      op = jj_consume_token(BIT_OR);
      params[1] = ExclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ExclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AndExpression(context);
    label_26:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case XOR:
        ;
        break;
      default:
        jj_la1[89] = jj_gen;
        break label_26;
      }
      op = jj_consume_token(XOR);
      params[1] = AndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = EqualityExpression(context);
    label_27:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[90] = jj_gen;
        break label_27;
      }
      op = jj_consume_token(BIT_AND);
      params[1] = EqualityExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand EqualityExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = RelationalExpression(context);
    label_28:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[91] = jj_gen;
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = RelationalExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand RelationalExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AdditiveExpression(context);
    label_29:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case GT:
      case LT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_29;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = AdditiveExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AdditiveExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = MultiplicativeExpression(context);
    label_30:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[95] = jj_gen;
        break label_30;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = MultiplicativeExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand MultiplicativeExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = UnaryExpression(context);
    label_31:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[97] = jj_gen;
        break label_31;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = UnaryExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case PLUS:
    case MINUS:
    case 81:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        jj_consume_token(PLUS);
    plus = true;
        break;
      case MINUS:
        jj_consume_token(MINUS);
    minus = true;
        break;
      case 81:
        jj_consume_token(81);
    tilde = true;
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      param = UnaryExpression(context);
    if (plus)
      {if (true) return new Evaluator(param, "+", Orientation.unary_prefix);}
    else if (minus)
      {if (true) return new Evaluator(param, "-", Orientation.unary_prefix);}
    else if (tilde)
      {if (true) return new Evaluator(param, "~", Orientation.unary_prefix);}
    {if (true) return param;}
      break;
    case INCR:
      param = PreIncrementExpression(context);
    {if (true) return param;}
      break;
    case DECR:
      param = PreDecrementExpression(context);
    {if (true) return param;}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
      param = UnaryExpressionNotPlusMinus(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PreIncrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(INCR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator(param, "++", Orientation.unary_prefix);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PreDecrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(DECR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator(param, "--", Orientation.unary_prefix);}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpressionNotPlusMinus(ParserContext context) throws ParseException
  {
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BANG:
      jj_consume_token(BANG);
      param = UnaryExpression(context);
    {if (true) return new Evaluator(param, "!", Orientation.unary_prefix);}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
      param = PostfixExpression(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PostfixExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean incr = false;
  boolean decr = false;
    param = PrimaryExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INCR:
        jj_consume_token(INCR);
    incr = true;
        break;
      case DECR:
        jj_consume_token(DECR);
    decr = true;
        break;
      default:
        jj_la1[102] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[103] = jj_gen;
      ;
    }
    if (incr)
       {if (true) return new Evaluator(param, "++", Orientation.unary_postfix);}
    else if (decr)
       {if (true) return new Evaluator(param, "--", Orientation.unary_postfix);}
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_3R_100() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    }
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_scan_token(XOR)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    }
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_scan_token(FACT)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(CURRENCY)) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(DECIMAL)) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_66()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[104];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static 
  {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
  }
  private static void jj_la1_init_0() 
  {
    jj_la1_0 = new int[] { 0x400000,0x6a7dfc0,0x6a7dfc0,0x0,0x0,0x6a75fc0,0x6a75fc0,0x201000,0x0,0x0,0x0,0x0,0x0,0x6a65fc0,0x0,0x0,0x0,0x8400000,0x90000000,0x0,0x0,0x0,0x400000,0x0,0x0,0x90000000,0x91188000,0x0,0x90a007c0,0x0,0x0,0x95b897c0,0x0,0x0,0x95b897c0,0x0,0xa007c0,0x0,0x0,0x0,0x91189000,0x0,0x0,0x0,0x90a007c0,0x2000,0x2000,0x0,0x0,0x91b887c0,0x95b897c0,0x90a007c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa007c0,0x0,0x0,0x2040000,0x0,0x0,0x0,0x0,0x0,0x91188000,0x0,0x90000000,0x0,0x0,0xa007c0,0x0,0x90a007c0,0x0,0x0,0xa007c0,0x0,0x90000000,0x0,0x90000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x91188000,0x91188000,0x0,0x0, };
  }
  private static void jj_la1_init_1() 
  {
    jj_la1_1 = new int[] { 0x0,0x40,0x40,0x80,0x80,0x40,0x40,0x0,0x40000,0x0,0x4000,0x80,0x100000,0x40,0x10080,0x4000,0x40,0x2,0x3e,0x200,0x100200,0x100200,0x2,0x4000,0x0,0x3e,0xf00802de,0x200,0x5e,0x4000,0x8000,0xf03802de,0x4000,0x8000,0xf03802de,0x80,0x0,0x800,0x10000,0x40,0xf00800de,0x300000,0x42,0x200,0x5e,0x310280,0x310280,0x300000,0x200,0xf00800de,0xf03802de,0x5e,0x0,0x4000,0x4000,0x4000,0x200,0x4000,0x4000,0x4000,0x4000,0x0,0x800,0x10000,0x0,0x40000,0x100000,0x80,0x10000,0x10000,0xde,0x800,0x1e,0x42,0x0,0x0,0x8000,0x5e,0x880,0x4000,0x0,0x800,0x5e,0x10000,0x1e,0xc,0x4000000,0x8000000,0x0,0x0,0x0,0x2400000,0x2400000,0x1860000,0x1860000,0xc0000000,0xc0000000,0x0,0x0,0xc0000000,0xf00800de,0x800de,0x30000000,0x30000000, };
  }
  private static void jj_la1_init_2() 
  {
    jj_la1_2 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x20000,0x0,0x0,0x0,0x0,0x28000,0x0,0x0,0x28000,0x0,0x0,0x10,0x40,0x0,0x20000,0x3f80,0x0,0x0,0x0,0x3fc0,0x3fc0,0x0,0x0,0x20000,0x20000,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x3fc0,0x3fc0,0x0,0x10,0x0,0x0,0x10000,0x0,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x10,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x23,0x23,0x20000,0x20000,0x0,0x0,0x0, };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) 
  {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) 
   {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) 
  {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) 
  {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 104; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException 
  {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) 
    {
      jj_gen++;
      if (++jj_gc > 100) 
      {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) 
        {
          JJCalls c = jj_2_rtns[i];
          while (c != null) 
          {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) 
  {
    if (jj_scanpos == jj_lastpos) 
    {
      jj_la--;
      if (jj_scanpos.next == null) 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else 
    {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) 
    {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() 
  {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) 
  {
    Token t = token;
    for (int i = 0; i < index; i++) 
    {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() 
  {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) 
  {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) 
    {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) 
    {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) 
    {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) 
      {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) 
        {
          for (int i = 0; i < jj_expentry.length; i++) 
          {
            if (oldentry[i] != jj_expentry[i]) 
            {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() 
  {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[82];
    if (jj_kind >= 0) 
    {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 104; i++) 
    {
      if (jj_la1[i] == jj_gen) 
      {
        for (int j = 0; j < 32; j++) 
        {
          if ((jj_la1_0[i] & (1<<j)) != 0) 
          {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) 
          {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) 
          {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 82; i++) 
    {
      if (la1tokens[i]) 
      {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) 
    {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() 
  {
  }

  /** Disable tracing. */
  final public void disable_tracing() 
  {
  }

  private void jj_rescan_token() 
  {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) 
    {
    try 
      {
      JJCalls p = jj_2_rtns[i];
      do 
        {
        if (p.gen > jj_gen) 
          {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) 
            {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) 
  {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) 
    {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls 
  {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
