/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
package au.com.cybersearch2.classy_logic.parser;

import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserContext;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.ParserTask;
import au.com.cybersearch2.classy_logic.compile.SourceMarker;
import au.com.cybersearch2.classy_logic.compile.SourceItem;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.LoopEvaluator;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.expression.OperatorEnum;
import au.com.cybersearch2.classy_logic.list.AxiomOperand;
import au.com.cybersearch2.classy_logic.list.ItemListOperand;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.NumberTerm;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.helper.Null;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;
import au.com.cybersearch2.classy_logic.helper.OperandParam;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser implements QueryParserConstants 
{

  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    parser.input(context);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    input(context);
    return queryProgram;
  }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, ParserContext context) throws ParseException
  {
    if (resourceName.length() < 3)
      throw new ParseException("Include resourceName \u005c"\u005c" is invalid");
    ParserResources parserResources = new ParserResources(context);
    try
    {
      parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
    }
    catch (IOException e)
    {
      throw new ParseException(e.getMessage());
    }
  }

  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  }

  protected Operand axiomOperand(QualifiedName qname,
                                 ParserAssembler parserAssembler,
                                 Operand indexExpression1,
                                 Operand indexExpression2)
  {
    AxiomOperand operand = new AxiomOperand(qname, indexExpression1, indexExpression2);
    ParserTask parserTask = parserAssembler.addPending(operand);
    //parserTask.setPriority(1);
    return operand;
  }

  protected Operand listItemOperand(QualifiedName qname,
                                    ParserAssembler parserAssembler,
                                    Operand indexExpression,
                                    Operand assignExpression)
  {
    ItemListOperand operand = new ItemListOperand(qname, indexExpression, assignExpression);
    ParserTask parserTask = parserAssembler.addPending(operand);
    //parserTask.setPriority(1);
    return operand;
  }

  protected SourceItem addSourceVariable(Operand var, ParserContext context)
  {
     int kind = context.getItemToken().kind;
     switch (kind)
     {
     case QueryParserConstants.INTEGER:
     case QueryParserConstants.BOOLEAN:
     case QueryParserConstants.DOUBLE:
     case QueryParserConstants.STRING:
     case QueryParserConstants.DECIMAL:
     case QueryParserConstants.CURRENCY:
     {
          String type = QueryParserConstants.tokenImage[kind];
          return context.addSourceItem(type.substring(1, type.length() - 1) + " " + var.toString());
     }
     default:
         return context.addSourceItem(var);
     }
  }

  protected QualifiedName createInnerTemplateName(QualifiedName outerTemplateName)
  {
        return new QualifiedTemplateName(
            outerTemplateName.getScope(),
            outerTemplateName.getTemplate() +
            Integer.toString(outerTemplateName.incrementReferenceCount() + 1));
  }

/** Root production. */
  final public void input(ParserContext context) throws ParseException
  {
    label_1:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case RESOURCE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ResourceDeclaration(context);
      jj_consume_token(SEMICOLON);
    }
    label_2:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      case SCOPE:
        ScopeDeclaration(context);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case SCOPE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(0);
    context.getQueryProgram().runPending();
  }

  final public void ResourceDeclaration(ParserContext context) throws ParseException
  {
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(RESOURCE);
    nameToken = jj_consume_token(STRING_LITERAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    context.getQueryProgram().openResource(getText(nameToken), properties);
  }

  final public void ScopeDeclaration(ParserContext context) throws ParseException
  {
  Token scopeToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    scopeToken = jj_consume_token(SCOPE);
    scopeToken = jj_consume_token(IDENTIFIER);
    context.setSourceMarker(scopeToken, scopeToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    Scope scope = context.getQueryProgram().scopeInstance(scopeToken.image , properties);
    context.setScope(scope);
    jj_consume_token(LBRACE);

    label_3:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
    context.resetScope();
  }

  final public void QueryChain(ParserContext context) throws ParseException
  {
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
    queryToken = jj_consume_token(QUERY);
    querySpec = Query(context);
    context.setSourceMarker(queryToken, querySpec.getName());
    querySpec = QueryDeclaration(querySpec, context);
    label_4:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 78:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      chainToken = jj_consume_token(78);
      context.onTokenIntercept(chainToken);
      QueryDeclaration(querySpec.chain(), context);
    }
    jj_consume_token(SEMICOLON);
    context.getScope().addQuerySpec(querySpec);
  }

  final public QuerySpec Query(ParserContext context) throws ParseException
  {
   Token queryToken;
    queryToken = jj_consume_token(IDENTIFIER);
    {if (true) return new QuerySpec(queryToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  KeyName firstKeyname;
  KeyName keyname;
  Token delimitToken;
  SourceItem sourceItem;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(firstKeyname.toString());
    label_5:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_5;
      }
      delimitToken = jj_consume_token(COMMA);
          sourceItem.setEnd(delimitToken);
      keyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(keyname.toString());
            ++keynameCount;
    }
    delimitToken = jj_consume_token(RPAREN);
        sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
        {if (true) return context.getScope().buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  String name1;
  String name2 = null;
    name1 = Name(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
      jj_consume_token(COLON);
      name2 = Name(context);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    {if (true) return keyname;}
    throw new Error("Missing return statement in function");
  }

  final public void Statement(ParserContext context) throws ParseException
  {
  Operand var;
  context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      VariableInitialization(context);
      break;
    case AXIOM:
      AxiomDeclaration(context);
      break;
    case LIST:
    case LOCAL:
      ListDeclaration(context);
      break;
    case TEMPLATE:
      TemplateDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case CALC:
      CalculatorTemplate(context);
      jj_consume_token(SEMICOLON);
      break;
    case CHOICE:
      ChoiceDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case INCLUDE:
      Include(context);
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AxiomDeclaration(ParserContext context) throws ParseException
  {
  QualifiedName qualifiedAxiomName;
  SourceItem sourceItem;
  Token axiomToken;
  Token delimitToken;
  String axiomSpec;
  Operand operand = null;
    axiomToken = jj_consume_token(AXIOM);
    qualifiedAxiomName = Axiom(context);
    context.setSourceMarker(axiomToken, qualifiedAxiomName);
    context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      axiomSpec = AxiomSpecification(qualifiedAxiomName, context);
      sourceItem = context.addSourceItem(axiomSpec);
      break;
    case ASSIGN:
      operand = AxiomVariable(qualifiedAxiomName, context);
       context.getOperandMap().addOperand(operand);
       sourceItem = context.addSourceItem(operand);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    delimitToken = jj_consume_token(SEMICOLON);
     sourceItem.setEnd(delimitToken);
  }

  final public QualifiedName Axiom(ParserContext context) throws ParseException
  {
  String axiomName;
    axiomName = Name(context);
    {if (true) return axiomName.indexOf(".") == -1 ?
        context.getParserAssembler().getContextName(axiomName) :
        QualifiedName.parseName(axiomName);}
    throw new Error("Missing return statement in function");
  }

  final public String AxiomSpecification(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  String termName;
  Token resouceToken;
  QualifiedName resourceBinding;
  int index = 0;
  StringBuilder builder = new StringBuilder(qualifiedAxiomName.getName());
  ParserAssembler parserAssembler = context.getParserAssembler();
  parserAssembler.createAxiom(qualifiedAxiomName);
    jj_consume_token(LPAREN);
    builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      termName = TermName(qualifiedAxiomName, parserAssembler);
          builder.append(termName);
      label_6:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        termName = TermName(qualifiedAxiomName, parserAssembler);
            builder.append(',').append(termName);
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACE:
    case COLON:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        resouceToken = jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case RESOURCE:
        case STRING_LITERAL:
          resourceBinding = ResourceBinding(QueryParserConstants.AXIOM, qualifiedAxiomName, parserAssembler);
            builder.append(':');
            if (resouceToken.next != null)
                builder.append(resouceToken.next);
          break;
        case PARAMETER:
          ParameterDeclaration(qualifiedAxiomName, parserAssembler);
            builder.append(":parameter");
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LBRACE:
        label_7:
        while (true) 
        {
          jj_consume_token(LBRACE);
          AxiomItem(qualifiedAxiomName, context);
        ++index;
          jj_consume_token(RBRACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_7;
          }
        }
      builder.append('[').append(Integer.toString(index)).append(']');
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    parserAssembler.addAxiomTermName(qualifiedAxiomName, nameToken.image);
    {if (true) return nameToken.image;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName ResourceBinding(int kind, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case STRING_LITERAL:
      nameToken = jj_consume_token(STRING_LITERAL);
      break;
    case RESOURCE:
      jj_consume_token(RESOURCE);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    QualifiedName qualifiedBindingName =
        kind == QueryParserConstants.TEMPLATE ?
        new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName()) :
        qualifiedAxiomName;
    AxiomProvider axiomProvider = (nameToken != null) ?
        parserAssembler.bindResource(QualifiedName.parseName(getText(nameToken)), qualifiedBindingName) :
        parserAssembler.bindResource(qualifiedBindingName);
    {if (true) return qualifiedBindingName;}
    throw new Error("Missing return statement in function");
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    Fact(qualifiedAxiomName, context);
    label_8:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, context);
    }
    context.getParserAssembler().saveAxiom(qualifiedAxiomName);
  }

  final public String Fact(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  Parameter param = null;
  Token lit = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param = LiteralTerm(context);
    parserAssembler.addAxiom(qualifiedAxiomName, param);
    {if (true) return param.getValue().toString();}
      break;
    case NUMBER_LITERAL:
      lit = jj_consume_token(NUMBER_LITERAL);
    parserAssembler.addAxiom(qualifiedAxiomName, new NumberTerm(getText(lit), parserAssembler.getScopeLocale()));
    {if (true) return getText(lit);}
      break;
    case NAN:
      jj_consume_token(NAN);
    parserAssembler.addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
    {if (true) return "NaN";}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  Operand expression = null;
  List<OperandParam> axiomList = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      expression = Expression(context);
      break;
    case LBRACE:
      axiomList = AxiomList(qualifiedAxiomName, context);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     VariableType varType = new VariableType(axiomList == null ? OperandType.AXIOM : OperandType.LIST);
     if (expression != null)
         varType.setProperty(VariableType.EXPRESSION, expression);
     else
         varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     if (expression != null)
         parserAssembler.setParameter(operand.getQualifiedName());
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> AxiomList(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  Operand operand;
    operand = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
    operandParamList.add(new OperandParam(qualifiedAxiomName.getName(), operand));
    label_9:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      operand = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
      operandParamList.add(new OperandParam(qualifiedAxiomName.getName(), operand));
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomInitializer(String listName, QualifiedName axiomName, ParserContext context) throws ParseException
  {
  List<OperandParam> initializeList = null;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      initializeList = ArgumentList(context, true);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
     VariableType varType = new VariableType(OperandType.TERM);
     varType.setProperty(VariableType.AXIOM_KEY, axiomName);
     if (initializeList != null)
        varType.setProperty(VariableType.PARAMS, initializeList);
     Operand operand = varType.getInstance(context.getParserAssembler(), listName);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateDeclaration(ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  QualifiedName contextName = context.getContextName();
    templateToken = jj_consume_token(TEMPLATE);
    template = Template(context, false);
    jj_consume_token(LPAREN);
    context.setSourceMarker(templateToken, template.getQualifiedName());
    expression = TemplateExpression(template, context);
      template.addTerm(expression);
      sourceItem = addSourceVariable(expression, context);
    label_10:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_10;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      expression = TemplateExpression(template, context);
        template.addTerm(expression);
        sourceItem = addSourceVariable(expression, context);
    }
    delimitToken = jj_consume_token(RPAREN);
    context.setContextName(contextName);
    sourceItem.setEnd(delimitToken);
  }

  final public Template Template(ParserContext context, boolean isCalculator) throws ParseException
  {
  Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), templateToken.image);
    context.setContextName(qualifiedTemplateName);
    {if (true) return context.getParserAssembler().createTemplate(qualifiedTemplateName, isCalculator);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorTemplate(ParserContext context) throws ParseException
  {
  Template template;
  Token calcToken;
  Token delimitToken;
  Operand operand;
  SourceItem sourceItem;
  Map<String, Object> properties = new HashMap<String, Object>();
  ParserAssembler parserAssembler = context.getParserAssembler();
  QualifiedName contextName = context.getContextName();
    calcToken = jj_consume_token(CALC);
    template = Template(context, true);
    jj_consume_token(LPAREN);
    context.setSourceMarker(calcToken, template.getQualifiedName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case AXIOM:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case DOT:
    case BANG:
    case COLON:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 79:
    case 82:
      operand = CalculatorExpression(template, template.getQualifiedName(), context);
      break;
    case TEMPLATE:
    case 80:
      operand = CalculatorQuery(template, context);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      sourceItem = addSourceVariable(operand, context);
    label_11:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_11;
      }
      delimitToken = jj_consume_token(COMMA);
       sourceItem.setEnd(delimitToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case AXIOM:
      case SCOPE:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case DOT:
      case BANG:
      case COLON:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 79:
      case 82:
        operand = CalculatorExpression(template, template.getQualifiedName(), context);
        break;
      case TEMPLATE:
      case 80:
        operand = CalculatorQuery(template, context);
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        sourceItem = addSourceVariable(operand, context);
    }
    delimitToken = jj_consume_token(RPAREN);
         sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    if (properties.size() > 0)
        template.addProperties(properties);
    context.setContextName(contextName);
  }

  final public Operand TemplateExpression(Template template, ParserContext context) throws ParseException
  {
    String name;
    QualifiedName qname;
    QualifiedName axiomQname;
    String axiomName = null;
    VariableType varType = null;
    Operand index = null;
    Operand var = null;
    Token scToken = null;
    Token privateToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Token interceptToken = null;
    Operand expression = null;
    Group group = null;
    ParserAssembler parserAssembler = context.getParserAssembler();
    OperandMap operandMap = parserAssembler.getOperandMap();
    List<Parameter> literalList = null;
    List<OperandParam> axiomList = null;
    List<OperandParam> operandParamList = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    name = Name(context);
    qname = parserAssembler.getContextName(name);
    axiomQname = qname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(context);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case REGEX:
    case LPAREN:
    case LBRACE:
    case ASSIGN:
    case COLON:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case 79:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
      case PLUSASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case ASSIGN:
          equalsToken = jj_consume_token(ASSIGN);
          break;
        case PLUSASSIGN:
          assignToken = jj_consume_token(PLUSASSIGN);
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case AXIOM:
          jj_consume_token(AXIOM);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case IDENTIFIER:
            axiomName = Name(context);
             axiomQname = QualifiedName.parseName(axiomName);
            break;
          default:
            jj_la1[33] = jj_gen;
            ;
          }
          axiomList = AxiomList(axiomQname, context);
         VariableType axiomListVarType = new VariableType(OperandType.LIST);
         axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
         if (axiomName != null)
           axiomListVarType.setProperty(VariableType.AXIOM_KEY, axiomQname);
         expression = axiomListVarType.getInstance(parserAssembler, axiomQname);
          break;
        case SCOPE:
        case FACT:
        case LENGTH:
        case FORMAT:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case NUMBER_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case 82:
          expression = Expression(context);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case COLON:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case 79:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case 79:
          scToken = jj_consume_token(79);
          break;
        case MINUSASSIGN:
          assignToken = jj_consume_token(MINUSASSIGN);
          break;
        case STARASSIGN:
          assignToken = jj_consume_token(STARASSIGN);
          break;
        case SLASHASSIGN:
          assignToken = jj_consume_token(SLASHASSIGN);
          break;
        case ANDASSIGN:
          assignToken = jj_consume_token(ANDASSIGN);
          break;
        case ORASSIGN:
          assignToken = jj_consume_token(ORASSIGN);
          break;
        case XORASSIGN:
          assignToken = jj_consume_token(XORASSIGN);
          break;
        case REMASSIGN:
          assignToken = jj_consume_token(REMASSIGN);
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        expression = Expression(context);
        break;
      case REGEX:
        interceptToken = jj_consume_token(REGEX);
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          regexLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          regexId = jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LBRACE:
          group = GroupDeclaration(template, name, parserAssembler);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      case LBRACE:
        interceptToken = jj_consume_token(LBRACE);
        literalList = LiteralList(context);
        jj_consume_token(RBRACE);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case INTEGER:
        case DOUBLE:
        case DECIMAL:
        case BOOLEAN:
        case STRING:
        case SCOPE:
        case FACT:
        case LENGTH:
        case TERM:
        case CURRENCY:
        case FORMAT:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case NUMBER_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case 82:
          operandParamList = ArgumentList(context, true);
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
             template.addTerm(parserAssembler.getCallOperand(qname, operandParamList));
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     Operand assignExpression = (assignToken != null) ? expression : null;
     Operand regexOp = null;
     if (regexLit != null)
       regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
     else if (regexId != null)
       regexOp = operandMap.addOperand(regexId.image, null);
     if (assignToken != null)
       expression = null;
     boolean isLiteral = (expression != null) && !expression.isEmpty() && (equalsToken != null);
     if (expression != null)
       varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     if (index !=null)
       var = listItemOperand(context.getQualifiedName(name), parserAssembler, index, null);
     else if (regexOp != null)
       var = new RegExOperand(qname, regexOp, 0, group);
     else if (scToken != null)
       var = new Evaluator(qname, expression, (scToken.image == "?" ? "&&" : "||"));
     else if (literalList != null)
       var = new LiteralListOperand(qname, literalList);
     else if (!operandMap.hasOperand(name))
       var = varType.getInstance(parserAssembler, name);
     else
       var = operandMap.addOperand(name, expression);
     if ((index == null) && (!operandMap.hasOperand(name)))
       operandMap.addOperand(var);
     if (assignToken != null)
       var = new Evaluator(qname, var, assignToken.image, assignExpression);
     if ((index !=null) && (equalsToken != null) && !isLiteral)
       var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
      if (interceptToken != null)
        context.onTokenIntercept(interceptToken);
      {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorExpression(Template template, QualifiedName outerTemplateName, ParserContext context) throws ParseException
  {
  Token literalToken;
  Token delimitToken;
  Token choiceToken;
  Token scToken = null;
  Token privateToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
    case 79:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        scToken = jj_consume_token(COLON);
        break;
      case 79:
        scToken = jj_consume_token(79);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      context.onTokenIntercept(scToken);
      expression = Expression(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        delimitToken = jj_consume_token(LBRACE);
        QualifiedName innerTemplateName = createInnerTemplateName(outerTemplateName);
        Template innerTemplate = context.getParserAssembler().chainTemplate(outerTemplateName, innerTemplateName);
        context.addSourceItem(scToken.image+expression.toString()).setEnd(delimitToken);
        context.pushSourceMarker();
        Token token = Token.newToken(QueryParserConstants.CALC);
        token.beginLine = delimitToken.beginLine;
        token.beginColumn = delimitToken.beginColumn;
        context.setSourceMarker(token, innerTemplateName);
        innerLoop = InnerCalculator(innerTemplate, outerTemplateName, context, true);
      context.popSourceMarker();
      context.onTokenIntercept(delimitToken);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
    expression = new Evaluator(expression, (scToken.image == "?" ? "&&" : "||"), innerLoop);
    expression.setPrivate(true);
    template.addTerm(expression);
    {if (true) return expression;}
      break;
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case DOT:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
      case IDENTIFIER:
        expression = TemplateExpression(template, context);
        break;
      case SCOPE:
      case FACT:
      case LENGTH:
      case FORMAT:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 82:
        expression = Expression(context);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    if (privateToken != null)
      expression.setPrivate(true);
    template.addTerm(expression);
    {if (true) return expression;}
      break;
    case LBRACE:
      delimitToken = jj_consume_token(LBRACE);
      context.pushSourceMarker();
      QualifiedName innerTemplateName = createInnerTemplateName(outerTemplateName);
      Template innerTemplate = context.getParserAssembler().chainTemplate(outerTemplateName, innerTemplateName);
      Token token = Token.newToken(QueryParserConstants.CALC);
      token.beginLine = delimitToken.beginLine;
      token.beginColumn = delimitToken.beginColumn;
      context.setSourceMarker(token, innerTemplateName);
      innerLoop = InnerCalculator(innerTemplate, outerTemplateName, context, false);
      context.checkForShortCircuit();
      context.popSourceMarker();
      context.onTokenIntercept(delimitToken);
    template.addTerm(innerLoop);
    context.onTokenIntercept(delimitToken);
    {if (true) return innerLoop;}
      break;
    case AXIOM:
      literalToken = jj_consume_token(AXIOM);
      qualifiedAxiomName = Axiom(context);
      expression = AxiomVariable(qualifiedAxiomName, context);
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
    context.onTokenIntercept(literalToken);
    {if (true) return expression;}
      break;
    case CHOICE:
      literalToken = jj_consume_token(CHOICE);
      choiceToken = jj_consume_token(IDENTIFIER);
    qualifiedAxiomName = QualifiedName.parseName(choiceToken.image);
    qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplate(qualifiedTemplateName);
    OperandMap operandMap = parserAssembler.getOperandMap();
    for (String termName: parserAssembler.getAxiomTermNameList(qualifiedAxiomName))
      operandMap.addOperand(termName, null);
    QualifiedName contextName = context.getContextName();
    QualifiedName qname = QualifiedName.parseName(choiceTemplate.getName(), contextName);
        Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
    context.onTokenIntercept(literalToken);
    {if (true) return choiceOperand;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorQuery(Template template, ParserContext context) throws ParseException
  {
  String queryName;
  List<OperandParam> operandParamList = null;
  Template innerTemplate = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TEMPLATE:
      innerTemplate = InnerTemplateDeclaration(template.getQualifiedName(), context);
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    jj_consume_token(80);
    queryName = Name(context);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      operandParamList = ArgumentList(context, false);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    QualifiedName qname = QualifiedName.parseName(queryName);
    Operand queryOperand = context.getParserAssembler().getQueryOperand(qname, operandParamList, innerTemplate);
    template.addTerm(queryOperand);
    if (innerTemplate != null)
        template.setNext(innerTemplate);
    {if (true) return queryOperand;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplateDeclaration(QualifiedName ownerQualifiedName, ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
    jj_consume_token(TEMPLATE);
    template = InnerTemplate(ownerQualifiedName, context);
    jj_consume_token(LPAREN);
    expression = TemplateExpression(template, context);
            template.addTerm(expression);
    label_12:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_12;
      }
      jj_consume_token(COMMA);
      expression = TemplateExpression(template, context);
            template.addTerm(expression);
    }
    jj_consume_token(RPAREN);
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplate(QualifiedName ownerQualifiedName, ParserContext context) throws ParseException
  {
  Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedName(templateToken.image, ownerQualifiedName);
    Template innerTemplate = context.getParserAssembler().createTemplate(qualifiedTemplateName, false);
    innerTemplate.setInnerTemplate(true);
    innerTemplate.setKey(templateToken.image);
    {if (true) return innerTemplate;}
    throw new Error("Missing return statement in function");
  }

  final public Operand InnerCalculator(Template template, QualifiedName outerTemplateName, ParserContext context, boolean runOnce) throws ParseException
  {
  Operand expression;
  SourceItem sourceItem;
  Token delimitToken;
  context.setSourceItemPending(true);
    expression = CalculatorExpression(template, outerTemplateName, context);
     sourceItem=addSourceVariable(expression, context);
    label_13:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_13;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      expression = CalculatorExpression(template, outerTemplateName, context);
      sourceItem=addSourceVariable(expression, context);
    }
    delimitToken = jj_consume_token(RBRACE);
    LoopEvaluator loopEvaluator = new LoopEvaluator(template, runOnce);
    sourceItem.setEnd(delimitToken);
    {if (true) return loopEvaluator;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName ChoiceDeclaration(ParserContext context) throws ParseException
  {
    Token choiceToken;
    Token delimitToken;
    QualifiedName qualifiedAxiomName;
    int selection = 0;
    boolean isSourceItemPending = context.isSourceItemPending();
    ParserAssembler parserAssembler = context.getParserAssembler();
    OperandMap operandMap = parserAssembler.getOperandMap();
    choiceToken = jj_consume_token(CHOICE);
    qualifiedAxiomName = Choice(parserAssembler);
    if (!isSourceItemPending)
      context.setSourceMarker(choiceToken, qualifiedAxiomName);
    jj_consume_token(LPAREN);
    TermName(qualifiedAxiomName, parserAssembler);
    label_14:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      TermName(qualifiedAxiomName, parserAssembler);
    }
    delimitToken = jj_consume_token(RPAREN);
    context.addChoiceItem(qualifiedAxiomName).setEnd(delimitToken);
    label_15:
    while (true) 
    {
      ChoiceItem(selection, qualifiedAxiomName, context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_15;
      }
    }
      QualifiedName contextName = context.getContextName();
      {if (true) return qualifiedAxiomName;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Choice(ParserAssembler parserAssembler) throws ParseException
  {
    Token choiceToken;
    choiceToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.createAxiom(qualifiedChoiceName);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(qualifiedChoiceName.getScope(), qualifiedChoiceName.getName());
    Template template = parserAssembler.createTemplate(qualifiedTemplateName, true);
    template.setChoice(true);
    {if (true) return qualifiedChoiceName;}
    throw new Error("Missing return statement in function");
  }

  final public void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    Operand operand;
    String fact;
    Token delimToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    String name = parserAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.addAxiom(qualifiedAxiomName, new Parameter(Term.ANONYMOUS, new Null()));
    StringBuilder builder = new StringBuilder();
    jj_consume_token(LBRACE);
    operand = ChoiceExpression(name, context);
     builder.append('{').append(operand.toString());
    label_16:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      fact = Fact(qualifiedAxiomName, context);
        builder.append(',').append(fact);
    }
    delimToken = jj_consume_token(RBRACE);
       parserAssembler.saveAxiom(qualifiedAxiomName);
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.addTemplate(qualifiedTemplateName, operand);
       builder.append('}');
       context.addSourceItem(builder.toString()).setEnd(delimToken);
  }

  final public Operand ChoiceExpression(String name, ParserContext context) throws ParseException
  {
    Operand operand;
    QualifiedName qname = context.getParserAssembler().getContextName(name);
    operand = Expression(context);
      if (operand instanceof Evaluator)
          {if (true) return new Evaluator(qname, operand, "&&" );}
      if (operand instanceof StringOperand)
          {if (true) return new RegExOperand(qname, operand, 0, null);}
      {if (true) return new MatchOperand(qname, operand);}
    throw new Error("Missing return statement in function");
  }

  final public void InitialiserList(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String property;
  SourceItem sourceItem;
  Token delimitToken;
    jj_consume_token(LPAREN);
    property = InitialiserDeclaration(properties, context);
    sourceItem = context.addSourceItem(property);
    label_17:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_17;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      property = InitialiserDeclaration(properties, context);
      sourceItem = context.addSourceItem(property);
    }
    delimitToken = jj_consume_token(RPAREN);
    sourceItem.setEnd(delimitToken);
  }

  final public String InitialiserDeclaration(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String name;
  Parameter param;
    name = Name(context);
    jj_consume_token(ASSIGN);
    param = LiteralTerm(context);
     properties.put(name, param.getValue());
     {if (true) return name + "=" + param.getValue().toString();}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Group group = new Group(name);
    jj_consume_token(LBRACE);
    Group(group, template, name, parserAssembler);
    label_18:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      Group(group, template, name, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Token groupToken;
    groupToken = jj_consume_token(IDENTIFIER);
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null);
    template.addTerm(var);
    group.addGroup(var);
  }

  final public List<Parameter> LiteralList(ParserContext context) throws ParseException
  {
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
    parameter = LiteralTerm(context);
    literalList.add(parameter);
    label_19:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      parameter = LiteralTerm(context);
      literalList.add(parameter);
    }
    {if (true) return literalList;}
    throw new Error("Missing return statement in function");
  }

  final public void VariableInitialization(ParserContext context) throws ParseException
  {
  Operand var;
  Token delimitToken;
    var = VariableDeclaration(context);
    delimitToken = jj_consume_token(SEMICOLON);
      context.getOperandMap().addOperand(var);
      context.setSourceMarker(context.getItemToken(), var.getQualifiedName());
      addSourceVariable(var, context).setEnd(delimitToken);
  }

  final public Operand VariableDeclaration(ParserContext context) throws ParseException
  {
  Token nameToken;
  VariableType varType = null;
  Operand index = null;
  Operand expression = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  context.setSourceItemPending(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(context);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(context);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
     boolean isUntyped = (varType == null);
     if (isUntyped)
       context.onTokenIntercept(nameToken);
     String name = nameToken.image;
     if (index !=null)
         {if (true) return listItemOperand(context.getQualifiedName(name), parserAssembler, index, expression);}
     if (isUntyped)
         varType = new VariableType(OperandType.UNKNOWN);
     boolean isLiteral = (expression != null) &&
                          !expression.isEmpty() && !(expression instanceof Evaluator);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void ListDeclaration(ParserContext context) throws ParseException
  {
  Token keywordToken;
  Token nameToken;
  Token delimitToken;
  String listName;
  VariableType varType = null;
  QualifiedName qualifiedBindingName = null;
  QualifiedName qualifiedAxiomName = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LIST:
      keywordToken = jj_consume_token(LIST);
      break;
    case LOCAL:
      keywordToken = jj_consume_token(LOCAL);
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      varType = Type(context);
      jj_consume_token(GT);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    listName = nameToken.image;
    context.setSourceMarker(keywordToken, listName);
    context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      qualifiedAxiomName = Axiom(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        jj_consume_token(COLON);
        qualifiedBindingName = ResourceBinding(QueryParserConstants.TEMPLATE, qualifiedAxiomName, parserAssembler);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(SEMICOLON);
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    boolean isTermList = (varType != null) && varType.getOperandType() == OperandType.TERM;
    if ((varType == null) && (qualifiedAxiomName == null))
        {if (true) throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Missing type or axiom name.");}
    if ((varType != null) && isLocal)
        {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Type in declaration not allowed.");}
    if ((qualifiedBindingName != null) && !isTermList)
        {if (true) throw new ParseException("Invalid declaration for " + keywordToken.image + " \u005c"" + listName + "\u005c". Only Term type list can be bound to a resource");}
    if (qualifiedBindingName != null)
        qualifiedAxiomName = qualifiedBindingName;
    if (varType == null)
        varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
        varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getOperandMap().addItemList(itemList.getQualifiedName(), itemList);
    context.addSourceItem(itemList).setEnd(delimitToken);
  }

  final public void Include(ParserContext context) throws ParseException
  {
  Token includeToken = null;
    jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    includeResource(includeToken.image, context);
  }

  final public Operand Expression(ParserContext context) throws ParseException
  {
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
    param = ConditionalOrExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      assignOperand = Expression(context);
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return new Evaluator(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PrimaryExpression(ParserContext context) throws ParseException
  {
  String name = null;
  QualifiedName qname;
  Token literal = null;
  Operand param1 = null;
  Operand operand;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal(context);
    {if (true) return param1;}
      break;
    case NUMBER_LITERAL:
      literal = jj_consume_token(NUMBER_LITERAL);
    NumberTerm numberTerm = new NumberTerm(getText(literal), parserAssembler.getScopeLocale());
    Variable var = new Variable(QualifiedName.ANONYMOUS);
    var.assign(numberTerm);
    context.onTokenIntercept(literal);
    {if (true) return var;}
      break;
    case IDENTIFIER:
      name = Name(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
      case LBRACKET:
        param1 = NamedExpression(name, context);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
    if (param1 == null)
        {if (true) return operandMap.addOperand(name, null);}
    {if (true) return param1;}
      break;
    case SCOPE:
      literal = jj_consume_token(SCOPE);
      param1 = IndexExpression(context);
    operand = listItemOperand(context.getQualifiedName("scope"), parserAssembler, param1, null);
    context.onTokenIntercept(literal);
    {if (true) return operand;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      param1 = Expression(context);
      jj_consume_token(RPAREN);
    {if (true) return param1;}
      break;
    case LENGTH:
      literal = jj_consume_token(LENGTH);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    operand = parserAssembler.findOperandByName(name);
    context.onTokenIntercept(literal);
    if (operand != null)
        {if (true) return new ListLength(qname, operand);}
    else
        {if (true) return new ListLength(qname, parserAssembler.getItemList(name));}
      break;
    case FORMAT:
      literal = jj_consume_token(FORMAT);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        {if (true) throw new ParseException("Variable \u005c"" + name + "\u005c" not found");}
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    context.onTokenIntercept(literal);
    {if (true) return formatter;}
      break;
    case FACT:
      literal = jj_consume_token(FACT);
      jj_consume_token(LPAREN);
      name = Name(context);
      jj_consume_token(RPAREN);
    Operand factOperand = parserAssembler.findOperandByName(name);
    context.onTokenIntercept(literal);
    if (factOperand != null)
        {if (true) return new FactOperand(factOperand);}
    else
        {if (true) throw new ParseException("Operand " + name + " not found");}
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> ArgumentList(ParserContext context, boolean nameRequired) throws ParseException
  {
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  OperandParam operandParam;
    operandParam = Argument(context, nameRequired);
    operandParamList.add(operandParam);
    label_20:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[67] = jj_gen;
        break label_20;
      }
      jj_consume_token(COMMA);
      operandParam = Argument(context, nameRequired);
      operandParamList.add(operandParam);
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public OperandParam Argument(ParserContext context, boolean nameRequired) throws ParseException
  {
  VariableType varType = null;
  Operand expression;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    expression = Expression(context);
     boolean isAssign = false;
     Operand leftOperand = expression.getLeftOperand();
     if ((leftOperand != null) && (expression instanceof Evaluator))
       isAssign =  ((Evaluator)expression).getOperator() == OperatorEnum.ASSIGN;
     String name = Term.ANONYMOUS;
     if (nameRequired)
       name = expression.getName();
     if (!isAssign)
       {if (true) return new OperandParam(name, expression);}
     name = leftOperand.getName();
     expression = expression.getRightOperand();
     boolean isLiteral = !expression.isEmpty();
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     if (varType.getOperandType() == OperandType.TERM)
       varType.setUnknownType();
     varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return new OperandParam(name, operand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand IndexExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(LBRACKET);
    param = Expression(context);
    jj_consume_token(RBRACKET);
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public Operand Literal(ParserContext context) throws ParseException
  {
  Token lit;
  Operand operand;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    Long litValue = Long.decode(lit.image);
    operand = new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    operand = new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    operand = new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableType Type(ParserContext context) throws ParseException
  {
  Token literalToken;
  VariableType varType;
  Token qualifierLit = null;
  String qualifierId = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
      literalToken = jj_consume_token(INTEGER);
      varType = new VariableType(OperandType.INTEGER);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case BOOLEAN:
      literalToken = jj_consume_token(BOOLEAN);
      varType = new VariableType(OperandType.BOOLEAN);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DOUBLE:
      literalToken = jj_consume_token(DOUBLE);
      varType = new VariableType(OperandType.DOUBLE);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case STRING:
      literalToken = jj_consume_token(STRING);
      varType = new VariableType(OperandType.STRING);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DECIMAL:
      literalToken = jj_consume_token(DECIMAL);
      varType = new VariableType(OperandType.DECIMAL);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case TERM:
      literalToken = jj_consume_token(TERM);
      varType = new VariableType(OperandType.TERM);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case CURRENCY:
      literalToken = jj_consume_token(CURRENCY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 81:
        jj_consume_token(81);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          qualifierLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          qualifierId = Name(context);
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
      varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, context.getOperandMap().addOperand(qualifierId, null));
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorFunction(ParserContext context) throws ParseException
  {
    String fnName;
    List<OperandParam> operandParamList = null;
    ParserAssembler parserAssembler = context.getParserAssembler();
    fnName = Name(context);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      operandParamList = ArgumentList(context, true);
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    {if (true) return parserAssembler.getCallOperand(parserAssembler.getContextName(fnName), operandParamList);}
    throw new Error("Missing return statement in function");
  }

  final public void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(PARAMETER);
    parserAssembler.setParameter(qualifiedAxiomName);
  }

  final public String Name(ParserContext context) throws ParseException
  {
  String name;
  Token partToken;
    partToken = jj_consume_token(IDENTIFIER);
    name = partToken.image;
    context.onTokenIntercept(partToken);
    label_21:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_21;
      }
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      name += ("." + partToken.image);
    }
    {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public Operand NamedExpression(String name, ParserContext context) throws ParseException
  {
  Operand param1 = null;
  Operand param2 = null;
  List<OperandParam> operandParamList = null;
  QualifiedName qname;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      param1 = IndexExpression(context);
      if (jj_2_1(2)) 
      {
        param2 = IndexExpression(context);
      } else 
      {
        ;
      }
    {if (true) return axiomOperand(context.getQualifiedName(name), parserAssembler, param1, param2);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case SCOPE:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 82:
        operandParamList = ArgumentList(context, true);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    {if (true) return parserAssembler.getCallOperand(qname, operandParamList);}
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm(ParserContext context) throws ParseException
  {
  Token lit;
  Parameter param;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    param = new IntegerTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    param = new DoubleTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    param = new StringTerm(getText(lit));
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanTerm(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new Parameter(Term.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TRUE:
      lit = jj_consume_token(TRUE);
    context.onTokenIntercept(lit);
    {if (true) return true;}
      break;
    case FALSE:
      lit = jj_consume_token(FALSE);
    context.onTokenIntercept(lit);
    {if (true) return false;}
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    lit = jj_consume_token(UNKNOWN);
    context.onTokenIntercept(lit);
  }

  final public Operand ConditionalOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ConditionalAndExpression(context);
    label_22:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_22;
      }
      op = jj_consume_token(SC_OR);
      params[1] = ConditionalAndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalAndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = InclusiveOrExpression(context);
    label_23:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_23;
      }
      op = jj_consume_token(SC_AND);
      params[1] = InclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand InclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ExclusiveOrExpression(context);
    label_24:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_24;
      }
      op = jj_consume_token(BIT_OR);
      params[1] = ExclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ExclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AndExpression(context);
    label_25:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case XOR:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_25;
      }
      op = jj_consume_token(XOR);
      params[1] = AndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = EqualityExpression(context);
    label_26:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_26;
      }
      op = jj_consume_token(BIT_AND);
      params[1] = EqualityExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand EqualityExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = RelationalExpression(context);
    label_27:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[84] = jj_gen;
        break label_27;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = RelationalExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand RelationalExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AdditiveExpression(context);
    label_28:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case GT:
      case LT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = AdditiveExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AdditiveExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = MultiplicativeExpression(context);
    label_29:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_29;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = MultiplicativeExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand MultiplicativeExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = UnaryExpression(context);
    label_30:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[90] = jj_gen;
        break label_30;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = UnaryExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case PLUS:
    case MINUS:
    case 82:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        jj_consume_token(PLUS);
    plus = true;
        break;
      case MINUS:
        jj_consume_token(MINUS);
    minus = true;
        break;
      case 82:
        jj_consume_token(82);
    tilde = true;
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      param = UnaryExpression(context);
    if (plus)
      {if (true) return new Evaluator("+", param);}
    else if (minus)
      {if (true) return new Evaluator("-", param);}
    else if (tilde)
      {if (true) return new Evaluator("~", param);}
    {if (true) return param;}
      break;
    case INCR:
      param = PreIncrementExpression(context);
    {if (true) return param;}
      break;
    case DECR:
      param = PreDecrementExpression(context);
    {if (true) return param;}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
      param = UnaryExpressionNotPlusMinus(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PreIncrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(INCR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator("++", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PreDecrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(DECR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator("--", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpressionNotPlusMinus(ParserContext context) throws ParseException
  {
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BANG:
      jj_consume_token(BANG);
      param = UnaryExpression(context);
    {if (true) return new Evaluator("!", param);}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
      param = PostfixExpression(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[94] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PostfixExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean incr = false;
  boolean decr = false;
    param = PrimaryExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INCR:
        jj_consume_token(INCR);
    incr = true;
        break;
      case DECR:
        jj_consume_token(DECR);
    decr = true;
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[96] = jj_gen;
      ;
    }
    if (incr)
       {if (true) return new Evaluator(param, "++");}
    else if (decr)
       {if (true) return new Evaluator(param, "--");}
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(82)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(FACT)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[97];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static 
  {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
  }
  private static void jj_la1_init_0() 
  {
    jj_la1_0 = new int[] { 0x400000,0x6a7dfc0,0x6a7dfc0,0x0,0x0,0x6a75fc0,0x6a75fc0,0x0,0x0,0x0,0x0,0x6a65fc0,0x0,0x0,0x0,0x8400000,0x0,0x0,0x0,0x400000,0x0,0x90000000,0x91188000,0x0,0x91b887c0,0x0,0x95b89fc0,0x0,0x95b89fc0,0x0,0xa007c0,0x0,0x0,0x0,0x91189000,0x0,0x0,0x0,0x91b887c0,0x2000,0x2000,0x0,0x0,0x0,0x91b887c0,0x95b897c0,0x800,0x91b887c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa007c0,0x0,0x0,0x2040000,0x0,0x0,0x0,0x0,0x0,0x0,0x91188000,0x0,0xa007c0,0x90000000,0x0,0x0,0xa007c0,0x91b887c0,0x0,0x91b887c0,0x0,0x90000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x91188000,0x91188000,0x0,0x0, };
  }
  private static void jj_la1_init_1() 
  {
    jj_la1_1 = new int[] { 0x0,0x80,0x80,0x100,0x100,0x80,0x80,0x0,0x8000,0x100,0x200000,0x80,0x20100,0x8000,0x80,0x4,0x400,0x200400,0x200400,0x4,0x8000,0x7d,0xf01005bd,0x400,0xf01001bd,0x8000,0xf03105bd,0x8000,0xf03105bd,0x100,0x0,0x1000,0x20000,0x80,0xf01001bd,0x200000,0x84,0x400,0xf01001bd,0x220500,0x220500,0x200000,0x400,0x10000,0xf01001bd,0xf03105bd,0x0,0xf01001bd,0x8000,0x8000,0x8000,0x400,0x8000,0x8000,0x8000,0x8000,0x0,0x1000,0x20000,0x0,0x80000,0x200000,0x100,0x20000,0x20000,0x1100,0x1bd,0x8000,0x0,0x3c,0x84,0x0,0x0,0xf01001bd,0x10000,0xf01001bd,0x1100,0x3c,0x18,0x4000000,0x8000000,0x0,0x0,0x0,0x2400000,0x2400000,0x18c0000,0x18c0000,0xc0000000,0xc0000000,0x0,0x0,0xc0000000,0xf01001bd,0x1001bd,0x30000000,0x30000000, };
  }
  private static void jj_la1_init_2() 
  {
    jj_la1_2 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x40000,0x0,0x58000,0x0,0x58000,0x0,0x0,0x0,0x40,0x0,0x40000,0xbf80,0x0,0x0,0x40000,0xbfc0,0xbfc0,0x8000,0x0,0x0,0x40000,0x48000,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc0,0x3fc0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x40000,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x8,0x10,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x23,0x23,0x40000,0x40000,0x0,0x0,0x0, };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) 
  {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) 
   {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) 
  {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) 
  {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 97; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException 
  {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) 
    {
      jj_gen++;
      if (++jj_gc > 100) 
      {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) 
        {
          JJCalls c = jj_2_rtns[i];
          while (c != null) 
          {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) 
  {
    if (jj_scanpos == jj_lastpos) 
    {
      jj_la--;
      if (jj_scanpos.next == null) 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else 
    {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) 
    {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() 
  {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) 
  {
    Token t = token;
    for (int i = 0; i < index; i++) 
    {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() 
  {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) 
  {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) 
    {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) 
    {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) 
    {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) 
      {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) 
        {
          for (int i = 0; i < jj_expentry.length; i++) 
          {
            if (oldentry[i] != jj_expentry[i]) 
            {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() 
  {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[83];
    if (jj_kind >= 0) 
    {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 97; i++) 
    {
      if (jj_la1[i] == jj_gen) 
      {
        for (int j = 0; j < 32; j++) 
        {
          if ((jj_la1_0[i] & (1<<j)) != 0) 
          {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) 
          {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) 
          {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 83; i++) 
    {
      if (la1tokens[i]) 
      {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) 
    {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() 
  {
  }

  /** Disable tracing. */
  final public void disable_tracing() 
  {
  }

  private void jj_rescan_token() 
  {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) 
    {
    try 
      {
      JJCalls p = jj_2_rtns[i];
      do 
        {
        if (p.gen > jj_gen) 
          {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) 
            {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) 
  {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) 
    {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls 
  {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
