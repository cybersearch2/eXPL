/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
package au.com.cybersearch2.classy_logic.parser;

import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.TemplateArchetype;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserContext;
import au.com.cybersearch2.classy_logic.compile.AxiomAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ListAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.ParserTask;
import au.com.cybersearch2.classy_logic.compile.SourceItem;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.TemplateOperand;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.expression.Orientation;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.list.ListItemVariable;
import au.com.cybersearch2.classy_logic.list.ArrayIndex;
import au.com.cybersearch2.classy_logic.list.ArrayItemList;
import au.com.cybersearch2.classy_logic.list.ListIndex;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.list.Cursor;
import au.com.cybersearch2.classy_logic.list.ListType;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.LiteralParameter;
import au.com.cybersearch2.classy_logic.terms.LiteralType;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.interfaces.ListItemSpec;
import au.com.cybersearch2.classy_logic.interfaces.LocaleListener;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser implements QueryParserConstants 
{

  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    parser.input(context);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    input(context);
    return queryProgram;
  }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, ParserContext context) throws ParseException
  {
    if (resourceName.length() < 3)
      throw new ParseException("Include resourceName \u005c"" + resourceName + "\u005c" is invalid");
    ParserResources parserResources = new ParserResources(context);
    try
    {
      parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
    }
    catch (IOException e)
    {
      throw new ParseException(e.getMessage());
    }
  }

  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  }

  protected Operand axiomContainerOperand(
          ParserAssembler parserAssembler,
          ListItemSpec[] indexData)
  {
      return axiomContainerOperand(parserAssembler, null, indexData);
  }

  protected Operand axiomContainerOperand(
      ParserAssembler parserAssembler,
      String name,
      ListItemSpec[] indexData)
  {
    QualifiedName listName = indexData[0].getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName.getName() + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = parserAssembler.addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand listItemOperand(
      ParserContext context,
      ListItemSpec indexData) throws ParseException
  {
      return listItemOperand(context, null, indexData);
  }

  protected Operand listItemOperand(
          ParserContext context,
          String name,
          ListItemSpec indexData) throws ParseException
  {

    QualifiedName listName = indexData.getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = context.getParserAssembler().addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand initList(
      ParserContext context,
      ListItemSpec indexData,
      Operand assignExpression) throws ParseException
  {
    if (assignExpression == null)
         throw new ParseException("Statement to initialize List \u005c"" + indexData.getListName() + "\u005c"  must be assigned a value");
    ParserAssembler parserAssembler = context.getParserAssembler();
    ArrayItemList<?> itemList = (ArrayItemList<?>) parserAssembler.getListAssembler().findItemList(indexData.getQualifiedListName());
    if (itemList == null)
         throw new ParseException("List \u005c"" + indexData.getListName() + "\u005c" must be declared before being initialized");
    int index = indexData.getItemIndex();
    if (index == -1)
         throw new ParseException("Invalid index \u005c"" + assignExpression.toString() + "\u005c" for list \u005c"" + indexData.getListName() + "\u005c" ");
    itemList.assignItem(index, assignExpression);
    return null; // No operand created indicated by null returned
  }

  protected SourceItem addSourceVariable(Operand var, ParserContext context)
  {
     int kind = context.getItemToken().kind;
     switch (kind)
     {
     case QueryParserConstants.INTEGER:
     case QueryParserConstants.BOOLEAN:
     case QueryParserConstants.DOUBLE:
     case QueryParserConstants.STRING:
     case QueryParserConstants.DECIMAL:
     case QueryParserConstants.CURRENCY:
     {
          String type = QueryParserConstants.tokenImage[kind];
          return context.addSourceItem(type.substring(1, type.length() - 1) + " " + var.toString());
     }
     default:
         return context.addSourceItem(var);
     }
  }

  void initializeList(ItemList<?> itemList, List<Parameter> literalList)
  {
    for (int i = 0; i < literalList.size(); ++i)
    {
      Parameter param = literalList.get(i);
      if (param instanceof IntegerTerm)
        ((ItemList<Long>)itemList).assignItem(i, (Long)param.getValue());
      else if (param instanceof DoubleTerm)
        ((ItemList<Double>)itemList).assignItem(i, (Double)param.getValue());
      else if (param instanceof StringTerm)
        ((ItemList<String>)itemList).assignItem(i, (String)param.getValue());
      else if (param instanceof BooleanTerm)
        ((ItemList<BooleanTerm>)itemList).assignItem(i, (BooleanTerm)param.getValue());
    }
  }

  void sizeList(ItemList<?> itemList, OperandType operandType, int begin, int end) throws ParseException
  {
    if (end <= begin)
      throw new ParseException("List \u005c"" + itemList.getName() + "\u005c" begin parameter must less then end");
    if (itemList instanceof ArrayItemList)
    {
      ArrayItemList arrayItemList = (ArrayItemList)itemList;
      arrayItemList.setOffset(begin);
      arrayItemList.setSize(end - begin + 1);
    }
    else
      throw new ParseException("List \u005c"" + itemList.getName() + "\u005c" is not sizeable");
  }

  Template createDynamicAxiomTemplate(String listName, ParserContext context)
  {
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), listName);
    context.setTemplateName(qualifiedTemplateName);
    return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, true);
  }

/** Root production. */
  final public void input(ParserContext context) throws ParseException
  {
    label_1:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case RESOURCE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ResourceDeclaration(context);
    }
    label_2:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case EXPORT:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      case SCOPE:
        ScopeDeclaration(context);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case SCOPE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case EXPORT:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(0);
    context.getQueryProgram().runPending();
  }

  final public void ResourceDeclaration(ParserContext context) throws ParseException
  {
  Token keywordToken;
  Token delimitToken;
  QualifiedName qualifiedName;
  Token axiomToken = null;
  Token templateToken = null;
  Token resourceToken = null;
  QualifiedName qualifiedTemplateName = null;
  Map<String, Object> properties = new HashMap<String, Object>();
  ParserAssembler parserAssembler = context.getParserAssembler();
    keywordToken = jj_consume_token(RESOURCE);
    qualifiedName = Axiom(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case AXIOM:
      axiomToken = jj_consume_token(AXIOM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
        TermHeader(qualifiedName, context);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          jj_consume_token(COMMA);
          templateToken = jj_consume_token(EXPORT);
          qualifiedTemplateName = Axiom(context);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      break;
    case EXPORT:
      templateToken = jj_consume_token(EXPORT);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      resourceToken = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
      jj_consume_token(COLON);
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(SEMICOLON);
    String resourceName;
    if (resourceToken != null)
      resourceName = getText(resourceToken);
    else
      resourceName = qualifiedName.toString();
    context.getQueryProgram().openResource(resourceName, properties);
    QualifiedName qualifiedBindingName =
      axiomToken == null ?
      new QualifiedTemplateName(qualifiedName.getScope(), qualifiedName.getName()) :
      qualifiedName;
    if (resourceToken != null)
      parserAssembler.bindResource(resourceName, qualifiedBindingName);
    else
      parserAssembler.bindResource(qualifiedBindingName);
    if ((axiomToken == null) || (templateToken == null))
      {if (true) return;}
    QualifiedName templateBindingName =
      new QualifiedTemplateName(qualifiedTemplateName.getScope(), qualifiedTemplateName.getName());
    parserAssembler.bindResource(resourceName, templateBindingName);
  }

  final public void ScopeDeclaration(ParserContext context) throws ParseException
  {
  Token scopeToken;
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    scopeToken = jj_consume_token(SCOPE);
    nameToken = jj_consume_token(IDENTIFIER);
    context.setSourceMarker(scopeToken, nameToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      InitialiserList(properties, context);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    Scope scope = context.getQueryProgram().scopeInstance(nameToken.image , properties);
    context.setScope(scope);
    jj_consume_token(LBRACE);

    label_3:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case EXPORT:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case EXPORT:
      case IDENTIFIER:
        Statement(context);
        break;
      case QUERY:
        QueryChain(context);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
    context.resetScope();
  }

  final public void QueryChain(ParserContext context) throws ParseException
  {
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
  Token typeToken = null;
    queryToken = jj_consume_token(QUERY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case AXIOM:
        typeToken = jj_consume_token(AXIOM);
        break;
      case TERM:
        typeToken = jj_consume_token(TERM);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    querySpec = Query(context);
    context.setSourceMarker(queryToken, querySpec.getName());
    querySpec = QueryDeclaration(querySpec, context);
    label_4:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case RARROW:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_4;
      }
      chainToken = jj_consume_token(RARROW);
      context.onTokenIntercept(chainToken);
      QueryDeclaration(querySpec.chain(), context);
    }
    jj_consume_token(SEMICOLON);
    context.getScope().addQuerySpec(querySpec);
    if (typeToken == null)
      {if (true) return;}
    ParserAssembler parserAssembler = context.getParserAssembler();
    VariableType varType = typeToken.kind == QueryParserConstants.AXIOM ? new VariableType(OperandType.AXIOM) : new VariableType(OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, querySpec.getKey());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, querySpec.getName());
    itemList.setPublic(true);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }

  final public QuerySpec Query(ParserContext context) throws ParseException
  {
   Token queryToken;
    queryToken = jj_consume_token(IDENTIFIER);
    {if (true) return new QuerySpec(queryToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  KeyName firstKeyname;
  KeyName keyname;
  Token delimitToken;
  SourceItem sourceItem;
  int keynameCount = 1;
  List<Term> termList = new ArrayList<Term>();
    jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(firstKeyname.toString());
    label_5:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
      delimitToken = jj_consume_token(COMMA);
          sourceItem.setEnd(delimitToken);
      keyname = KeyName(querySpec, context);
          sourceItem = context.addSourceItem(keyname.toString());
            ++keynameCount;
    }
    delimitToken = jj_consume_token(RPAREN);
        sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      TermList(termList, context);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
        {if (true) return context.getScope().buildQuerySpec(querySpec, firstKeyname, keynameCount, termList);}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec, ParserContext context) throws ParseException
  {
  String name1;
  String name2 = null;
    name1 = Name(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
      jj_consume_token(COLON);
      name2 = Name(context);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    {if (true) return keyname;}
    throw new Error("Missing return statement in function");
  }

  final public void Statement(ParserContext context) throws ParseException
  {
  context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      VariableInitialization(context);
      break;
    case AXIOM:
      AxiomDeclaration(context);
      break;
    case LIST:
    case LOCAL:
    case EXPORT:
      ListDeclaration(context);
      break;
    case TEMPLATE:
      TemplateDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case CALC:
      CalculatorTemplate(context);
      jj_consume_token(SEMICOLON);
      break;
    case CHOICE:
      ChoiceDeclaration(context);
      jj_consume_token(SEMICOLON);
      break;
    case INCLUDE:
      Include(context);
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AxiomDeclaration(ParserContext context) throws ParseException
  {
  QualifiedName qualifiedAxiomName;
  SourceItem sourceItem;
  Token axiomToken;
  Token delimitToken;
  String axiomSpec;
    axiomToken = jj_consume_token(AXIOM);
    qualifiedAxiomName = Axiom(context);
    context.setSourceMarker(axiomToken, qualifiedAxiomName);
    context.setSourceItemPending(false);
    axiomSpec = AxiomSpecification(qualifiedAxiomName, context);
    sourceItem = context.addSourceItem(axiomSpec);
    delimitToken = jj_consume_token(SEMICOLON);
     sourceItem.setEnd(delimitToken);
  }

  final public QualifiedName Axiom(ParserContext context) throws ParseException
  {
  String axiomName;
    axiomName = Name(context);
    {if (true) return axiomName.indexOf(".") == -1 ?
        context.getParserAssembler().getContextName(axiomName) :
        QualifiedName.parseName(axiomName);}
    throw new Error("Missing return statement in function");
  }

  final public String AxiomSpecification(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  String termNames;
  Token resouceToken;
  int index = 0;
  StringBuilder builder = new StringBuilder(qualifiedAxiomName.getName());
  ParserAssembler parserAssembler = context.getParserAssembler();
    termNames = TermHeader(qualifiedAxiomName, context);
    builder.append(termNames);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACE:
    case COLON:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        resouceToken = jj_consume_token(COLON);
        ParameterDeclaration(qualifiedAxiomName, parserAssembler);
        builder.append(":parameter");
        break;
      case LBRACE:
        label_6:
        while (true) 
        {
          jj_consume_token(LBRACE);
          AxiomItem(qualifiedAxiomName, context);
        ++index;
          jj_consume_token(RBRACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_6;
          }
        }
      builder.append('[').append(Integer.toString(index)).append(']');
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TermHeader(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  String termName;
  StringBuilder builder = new StringBuilder();
  ParserAssembler parserAssembler = context.getParserAssembler();
  parserAssembler.getListAssembler().createAxiomItemList(qualifiedAxiomName);
    jj_consume_token(LPAREN);
    builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      termName = TermName(qualifiedAxiomName, parserAssembler);
          builder.append(termName);
      label_7:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        termName = TermName(qualifiedAxiomName, parserAssembler);
            builder.append(',').append(termName);
      }
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    parserAssembler.getAxiomAssembler().addAxiomTermName(qualifiedAxiomName, nameToken.image);
    {if (true) return nameToken.image;}
    throw new Error("Missing return statement in function");
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BIT_OR:
      jj_consume_token(BIT_OR);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    Fact(qualifiedAxiomName, context);
    label_8:
    while (true) 
    {
      if (jj_2_1(2)) 
      {
        ;
      } else 
      {
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      case BIT_OR:
        jj_consume_token(BIT_OR);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Fact(qualifiedAxiomName, context);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BIT_OR:
      jj_consume_token(BIT_OR);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }

  final public String Fact(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  Parameter param = null;
  Token lit = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
        param = LiteralTerm(context);
        break;
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
      case IDENTIFIER:
        param = MacroLiteralTerm(context);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, param);
    {if (true) return param.getValue().toString();}
      break;
    case NAN:
      jj_consume_token(NAN);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
    {if (true) return "NaN";}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List<Template> AxiomList(QualifiedName qualifiedAxiomName, ParserContext context) throws ParseException
  {
  List<Template> templateParamList = new ArrayList<Template>();
  Template template;
    template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
    templateParamList.add(template);
    label_9:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_9;
      }
      template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context);
     templateParamList.add(template);
    }
    {if (true) return templateParamList;}
    throw new Error("Missing return statement in function");
  }

  final public Template AxiomInitializer(String listName, QualifiedName axiomName, ParserContext context) throws ParseException
  {
  Template initializeTemplate = null;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
      initializeTemplate = Parameters(listName, context, true);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
     if (initializeTemplate != null)
       {if (true) return initializeTemplate;}
     TemplateArchetype architype = new TemplateArchetype(new QualifiedTemplateName(context.getScope().getAlias(), axiomName.getName()));
     {if (true) return new Template(architype);}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateDeclaration(ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String listName;
  Token privateToken = null;
  QualifiedName contextName = context.getContextName();
    templateToken = jj_consume_token(TEMPLATE);
    template = Template(context, false);
    label_10:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_10;
      }
      jj_consume_token(PLUS);
      listName = ListDeclaration(context);
      context.setQualifiedName(template.getName(), listName);
    }
    jj_consume_token(LPAREN);
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(templateToken, template.getQualifiedName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case DOT:
      privateToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    expression = TemplateExpression(template, context);
      if (privateToken != null)
        expression.setPrivate(true);
      privateToken = null;
      template.addTerm(expression);
      sourceItem = addSourceVariable(expression, context);
    label_11:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_11;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      expression = TemplateExpression(template, context);
        if (privateToken != null)
          expression.setPrivate(true);
        privateToken = null;
        template.addTerm(expression);
        sourceItem = addSourceVariable(expression, context);
    }
    delimitToken = jj_consume_token(RPAREN);
    context.setContextName(contextName);
    sourceItem.setEnd(delimitToken);
  }

  final public Template Template(ParserContext context, boolean isCalculator) throws ParseException
  {
  Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), templateToken.image);
    context.setContextName(qualifiedTemplateName);
    {if (true) return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, isCalculator);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorTemplate(ParserContext context) throws ParseException
  {
  Template template;
  Token calcToken;
  Token delimitToken;
  Operand operand;
  SourceItem sourceItem;
  String listName;
  Token typeToken = null;
  List<Term> termList = new ArrayList<Term>();
  ParserAssembler parserAssembler = context.getParserAssembler();
  QualifiedName contextName = context.getContextName();
    calcToken = jj_consume_token(CALC);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      typeToken = jj_consume_token(TERM);
      jj_consume_token(GT);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    template = Template(context, true);
    label_12:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_12;
      }
      jj_consume_token(PLUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LIST:
      case LOCAL:
      case EXPORT:
        listName = ListDeclaration(context);
        context.setQualifiedName(template.getName(), listName);
        break;
      case CURSOR:
        operand = CursorDeclaration(context);
        jj_consume_token(SEMICOLON);
        template.addTerm(operand);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(LPAREN);
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(calcToken, template.getQualifiedName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case REGEX:
    case SCOPE:
    case TERM:
    case CURRENCY:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case DOT:
    case BANG:
    case COLON:
    case QMARK:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 98:
      operand = CalculatorExpression(template, template.getQualifiedName(), context);
      break;
    case LARROW:
      operand = CalculatorQuery(template, context);
      operand.setPrivate(true);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    sourceItem = addSourceVariable(operand, context);
    label_13:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_13;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case REGEX:
      case SCOPE:
      case TERM:
      case CURRENCY:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case DOT:
      case BANG:
      case COLON:
      case QMARK:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 98:
        operand = CalculatorExpression(template, template.getQualifiedName(), context);
        break;
      case LARROW:
        operand = CalculatorQuery(template, context);
        operand.setPrivate(true);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      sourceItem = addSourceVariable(operand, context);
    }
    delimitToken = jj_consume_token(RPAREN);
      sourceItem.setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      TermList(termList, context);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    if (termList.size() > 0)
        template.addProperties(termList);
    context.setContextName(contextName);
    if (typeToken == null)
      {if (true) return;}
    VariableType varType = new VariableType(OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, template.getQualifiedName());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, template.getName());
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }

  final public Operand TemplateExpression(Template template, ParserContext context) throws ParseException
  {
  boolean isList = false;
  String name = null;
  QualifiedName qname = null;
  QualifiedName axiomQname;
  String axiomName = null;
  VariableType varType = null;
  Operand var = null;
  Token privateToken = null;
  Token scToken = null;
  Token assignToken = null;
  Token equalsToken = null;
  Token interceptToken = null;
  Token notToken = null;
  Operand expression = null;
  Operand shortCircuit = null;
  Operand regexOp = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  ListAssembler listAssembler = parserAssembler.getListAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  List<Parameter> literalList = null;
  List<Template> axiomList = null;
  Template parameterTemplate = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
        varType = Type(context);
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      name = Name(context);
      qname = parserAssembler.getContextName(name);
      axiomQname = qname;
      isList = (varType == null) && (template.isInnerTemplate() || template.isCalculator()) && listAssembler.existsKey(ListType.basic, qname);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACKET:
      case RARROW:
        listIndexData = IndexExpression(context.getQualifiedName(name), context);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
      case LBRACE:
      case ASSIGN:
      case BANG:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case ASSIGN:
        case PLUSASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case ASSIGN:
            equalsToken = jj_consume_token(ASSIGN);
            break;
          case PLUSASSIGN:
            assignToken = jj_consume_token(PLUSASSIGN);
            break;
          default:
            jj_la1[43] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case AXIOM:
            jj_consume_token(AXIOM);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
            {
            case IDENTIFIER:
              axiomName = Name(context);
                axiomQname = QualifiedName.parseName(axiomName);
              break;
            default:
              jj_la1[44] = jj_gen;
              ;
            }
            axiomList = AxiomList(axiomQname, context);
              VariableType axiomListVarType = new VariableType(OperandType.LIST);
              axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
              if (axiomName != null)
                axiomListVarType.setProperty(VariableType.AXIOM_KEY, axiomQname);
              expression = axiomListVarType.getInstance(parserAssembler, axiomQname);
            break;
          case SCOPE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case STRING_LITERAL:
          case TRUE:
          case FALSE:
          case UNKNOWN:
          case IDENTIFIER:
          case LPAREN:
          case BANG:
          case INCR:
          case DECR:
          case PLUS:
          case MINUS:
          case 98:
            expression = Expression(context);
            break;
          default:
            jj_la1[45] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case MINUSASSIGN:
            assignToken = jj_consume_token(MINUSASSIGN);
            break;
          case STARASSIGN:
            assignToken = jj_consume_token(STARASSIGN);
            break;
          case SLASHASSIGN:
            assignToken = jj_consume_token(SLASHASSIGN);
            break;
          case ANDASSIGN:
            assignToken = jj_consume_token(ANDASSIGN);
            break;
          case ORASSIGN:
            assignToken = jj_consume_token(ORASSIGN);
            break;
          case XORASSIGN:
            assignToken = jj_consume_token(XORASSIGN);
            break;
          case REMASSIGN:
            assignToken = jj_consume_token(REMASSIGN);
            break;
          case LSHIFTASSIGN:
            assignToken = jj_consume_token(LSHIFTASSIGN);
            break;
          case RSIGNEDSHIFTASSIGN:
            assignToken = jj_consume_token(RSIGNEDSHIFTASSIGN);
            break;
          case RUNSIGNEDSHIFTASSIGN:
            assignToken = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
            break;
          default:
            jj_la1[46] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          expression = Expression(context);
          break;
        case LBRACE:
        case BANG:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case BANG:
            notToken = jj_consume_token(BANG);
            break;
          default:
            jj_la1[47] = jj_gen;
            ;
          }
          interceptToken = jj_consume_token(LBRACE);
          literalList = LiteralList(context);
          jj_consume_token(RBRACE);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case INTEGER:
          case DOUBLE:
          case DECIMAL:
          case BOOLEAN:
          case STRING:
          case TERM:
          case CURRENCY:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case STRING_LITERAL:
          case TRUE:
          case FALSE:
          case UNKNOWN:
          case IDENTIFIER:
            parameterTemplate = Parameters(name, context, true);
            break;
          default:
            jj_la1[48] = jj_gen;
            ;
          }
          jj_consume_token(RPAREN);
              template.addTerm(parserAssembler.getCallOperand(qname, parameterTemplate));
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
      case QMARK:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case QMARK:
          scToken = jj_consume_token(QMARK);
          break;
        default:
          jj_la1[51] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        shortCircuit = Expression(context);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      break;
    case REGEX:
      regexOp = RegularExpression(template, context);
      var = new Evaluator(regexOp.getLeftOperand().getQualifiedName(), regexOp, "?", regexOp.getLeftOperand());
      if (privateToken != null)
        var.setPrivate(true);
      {if (true) return var;}
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (isList)
      varType = new VariableType(OperandType.APPENDER);
    boolean isDeclaration = varType != null;
    boolean isNot = notToken != null;
    if (isNot)
      interceptToken = notToken;
    boolean hasOperand = operandMap.hasOperand(name, parserAssembler.getQualifiedContextname());
    if (!isDeclaration)
      varType = new VariableType(OperandType.UNKNOWN);
    Operand assignExpression = (assignToken != null) ? expression : null;
    if (assignToken != null)
      expression = null;
    if (expression != null)
      varType.setProperty(VariableType.EXPRESSION, expression);
    if (isList)
      varType.setProperty(VariableType.EXPRESSION, assignExpression);
    if (listIndexData !=null)
      var = listIndexData.length == 1 ? listItemOperand(context, listIndexData[0]) : axiomContainerOperand(parserAssembler, listIndexData);
    else if (literalList != null)
      var = new LiteralListOperand(qname, literalList, isNot);
    else
      var = operandMap.getOperand(qname);
    if ((var != null) && isDeclaration)
       operandMap.duplicateOperandCheck(qname);
    if ((var == null) && !hasOperand)
      var = varType.getInstance(parserAssembler, name);
    if (var == null)
      var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
    if ((listIndexData == null) && (!hasOperand))
      operandMap.addOperand(var);
    if ((assignToken != null) && !isList)
      var = parserAssembler.createReflexiveEvaluator(var, assignToken.image, assignExpression);
    if ((equalsToken != null) && ((listIndexData !=null) || (axiomList != null)))
      var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
    else if (hasOperand && (equalsToken != null))
      var = new Evaluator(parserAssembler.getContextName(var.getName() + var.getQualifiedName().incrementReferenceCount()), var, "=", expression);
    else if (scToken != null)
      var = new Evaluator(qname, shortCircuit, scToken.image, var);
    if (interceptToken != null)
      context.onTokenIntercept(interceptToken);
    {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorExpression(Template template, QualifiedName outerTemplateName, ParserContext context) throws ParseException
  {
  Token delimitToken;
  Token privateToken = null;
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
    case QMARK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        scToken = jj_consume_token(COLON);
        break;
      case QMARK:
        scToken = jj_consume_token(QMARK);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      context.onTokenIntercept(scToken);
      expression = Expression(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        delimitToken = jj_consume_token(LBRACE);
        Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
        context.addSourceItem(scToken.image+expression.toString()).setEnd(delimitToken);
        context.pushSourceMarker();
        Token token = Token.newToken(QueryParserConstants.CALC);
        token.beginLine = delimitToken.beginLine;
        token.beginColumn = delimitToken.beginColumn;
        context.setSourceMarker(token, innerTemplate.getQualifiedName());
        innerLoop = InnerCalculator(innerTemplate, outerTemplateName, context, true);
        context.popSourceMarker();
        context.onTokenIntercept(delimitToken);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      String operator = scToken.image == "?" ? "&&" : "||";
      expression = innerLoop == null ? new Evaluator(expression, operator, Orientation.unary_postfix) : new Evaluator(expression, operator, innerLoop);
      expression.setPrivate(true);
      template.addTerm(expression);
      {if (true) return expression;}
      break;
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case REGEX:
    case SCOPE:
    case TERM:
    case CURRENCY:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case DOT:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 98:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      expression = CalculatorExpression2(template, outerTemplateName, context);
      if (privateToken != null)
        expression.setPrivate(true);
      {if (true) return expression;}
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorExpression2(Template template, QualifiedName outerTemplateName, ParserContext context) throws ParseException
  {
  Token literalToken;
  Token delimitToken;
  Token choiceToken;
  Operand expression = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  List<Template> axiomList;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case REGEX:
    case SCOPE:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 98:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case REGEX:
      case TERM:
      case CURRENCY:
      case IDENTIFIER:
        expression = TemplateExpression(template, context);
        break;
      case SCOPE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 98:
        expression = Expression(context);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        template.addTerm(expression);
      break;
    case LBRACE:
      delimitToken = jj_consume_token(LBRACE);
          context.onTokenIntercept(delimitToken);
          context.pushSourceMarker();
          Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
          Token token = Token.newToken(QueryParserConstants.CALC);
          token.beginLine = delimitToken.beginLine;
          token.beginColumn = delimitToken.beginColumn;
          context.setSourceMarker(token, innerTemplate.getQualifiedName());
      expression = InnerCalculator(innerTemplate, outerTemplateName, context, false);
          context.checkForShortCircuit();
          context.popSourceMarker();
        template.addTerm(expression);
        context.onTokenIntercept(delimitToken);
      break;
    case CHOICE:
      literalToken = jj_consume_token(CHOICE);
          context.onTokenIntercept(literalToken);
      choiceToken = jj_consume_token(IDENTIFIER);
          qualifiedAxiomName = QualifiedName.parseName(choiceToken.image);
          qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
          Template choiceTemplate = parserAssembler.getTemplateAssembler().createChoiceTemplate(template, qualifiedTemplateName);
          OperandMap operandMap = parserAssembler.getOperandMap();
          AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
          for (String termName: axiomAssembler.getTermNameList(qualifiedAxiomName))
            operandMap.addOperand(termName, null, parserAssembler.getQualifiedContextname());
          QualifiedName contextName = context.getContextName();
          QualifiedName qname = QualifiedName.parseName(qualifiedAxiomName.getName(), contextName);
          Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
          expression = new ChoiceOperand(qname, choiceTemplate, choice);
          template.addTerm(expression);
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public Operand RegularExpression(Template template, ParserContext context) throws ParseException
  {
  String inputName;
  QualifiedName qname;
  Token regexLit = null;
  Token regexId = null;
  Group group = null;
  int flags = 0;
  ParserAssembler parserAssembler = context.getParserAssembler();
    jj_consume_token(REGEX);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      flags = RegexFlags();
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    inputName = Name(context);
    qname = parserAssembler.getContextName(inputName);
    jj_consume_token(EQ);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case STRING_LITERAL:
      regexLit = jj_consume_token(STRING_LITERAL);
      break;
    case IDENTIFIER:
      regexId = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACE:
      group = GroupDeclaration(qname.getName(), template, parserAssembler);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    Operand regexOp = null;
    if (regexLit != null)
      regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
    else
      regexOp = parserAssembler.getOperandMap().addOperand(regexId.image, null, parserAssembler.getQualifiedContextname());
    Operand inputOp = null;
    inputOp = parserAssembler.getOperandMap().addOperand(inputName, null, parserAssembler.getQualifiedContextname());
    Operand var = new RegExOperand(qname, regexOp, inputOp, flags, group);
    {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public int RegexFlags() throws ParseException
  {
  int flags = 0;
    jj_consume_token(LPAREN);
    label_14:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case unix_lines:
      case case_insensitive:
      case comments:
      case multiline:
      case literal:
      case dotall:
      case unicode_case:
      case canon_eq:
      case unicode_character_class:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case unix_lines:
        jj_consume_token(unix_lines);
                      flags |= 0x01;
        break;
      case case_insensitive:
        jj_consume_token(case_insensitive);
                            flags |= 0x02;
        break;
      case comments:
        jj_consume_token(comments);
                    flags |= 0x04;
        break;
      case multiline:
        jj_consume_token(multiline);
                     flags |= 0x08;
        break;
      case literal:
        jj_consume_token(literal);
                   flags |= 0x10;
        break;
      case dotall:
        jj_consume_token(dotall);
                  flags |= 0x20;
        break;
      case unicode_case:
        jj_consume_token(unicode_case);
                        flags |= 0x40;
        break;
      case canon_eq:
        jj_consume_token(canon_eq);
                    flags |= 0x80;
        break;
      case unicode_character_class:
        jj_consume_token(unicode_character_class);
                                   flags |= 0x100;
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    {if (true) return flags;}
    throw new Error("Missing return statement in function");
  }

  final public Operand CalculatorQuery(Template template, ParserContext context) throws ParseException
  {
  Token queryToken;
  Token delimitToken;
  String queryName;
  String callName;
  QualifiedName qname;
  QualifiedName outerTemplateName = template.getQualifiedName();
  Template innerTemplate = null;
  Template parameterTemplate = null;
    queryToken = jj_consume_token(LARROW);
    context.onTokenIntercept(queryToken);
    context.pushSourceMarker();
    queryName = Name(context);
    qname = context.getQualifiedName(queryName);
    callName = qname.getName();
    Token token = Token.newToken(QueryParserConstants.QUERY);
    token.beginLine = queryToken.beginLine;
    token.beginColumn = queryToken.beginColumn;
    context.setSourceMarker(token, queryName);
    context.setSourceItemPending(false);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
      parameterTemplate = Parameters(callName, context, false);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(RPAREN);
    int reference = qname.incrementReferenceCount();
    if (reference > 0)
       qname = new QualifiedName(qname.getName() + reference, qname);
    context.addCalcQuery(qname, parameterTemplate).setEnd(delimitToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case RARROW:
      innerTemplate = InnerTemplateDeclaration(outerTemplateName, callName, context);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    Operand queryOperand = context.getParserAssembler().getQueryOperand(queryName, qname, parameterTemplate, innerTemplate);
    template.addTerm(queryOperand);
    context.popSourceMarker();
    {if (true) return queryOperand;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplateDeclaration(QualifiedName outerTemplateName, String callName, ParserContext context) throws ParseException
  {
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String queryKey = outerTemplateName.getTemplate() + "." + callName;
    templateToken = jj_consume_token(RARROW);
      ParserAssembler parserAssembler = context.getParserAssembler();
      template = parserAssembler.getTemplateAssembler().createQueryTemplate(outerTemplateName, callName);
      template.setKey(queryKey);
      context.onTokenIntercept(templateToken);
    delimitToken = jj_consume_token(LPAREN);
      context.addSourceItem("-> " + template.getQualifiedName().toString()).setEnd(delimitToken);
    expression = TemplateExpression(template, context);
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
    label_15:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[67] = jj_gen;
        break label_15;
      }
      delimitToken = jj_consume_token(COMMA);
          sourceItem.setEnd(delimitToken);
      expression = TemplateExpression(template, context);
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
    }
    delimitToken = jj_consume_token(RPAREN);
        sourceItem.setEnd(delimitToken);
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Operand InnerCalculator(Template template, QualifiedName outerTemplateName, ParserContext context, boolean runOnce) throws ParseException
  {
  Operand operand;
  SourceItem sourceItem;
  Token delimitToken;
  context.setSourceItemPending(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case REGEX:
    case SCOPE:
    case TERM:
    case CURRENCY:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case DOT:
    case BANG:
    case COLON:
    case QMARK:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 98:
      operand = CalculatorExpression(template, outerTemplateName, context);
      break;
    case LARROW:
      operand = CalculatorQuery(template, context);
      operand.setPrivate(true);
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     sourceItem=addSourceVariable(operand, context);
    label_16:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_16;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case REGEX:
      case SCOPE:
      case TERM:
      case CURRENCY:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case DOT:
      case BANG:
      case COLON:
      case QMARK:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 98:
        operand = CalculatorExpression(template, outerTemplateName, context);
        break;
      case LARROW:
        operand = CalculatorQuery(template, context);
        operand.setPrivate(true);
        break;
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      sourceItem=addSourceVariable(operand, context);
    }
    delimitToken = jj_consume_token(RBRACE);
    TemplateOperand templateOperand = new TemplateOperand(template, runOnce);
    sourceItem.setEnd(delimitToken);
    {if (true) return templateOperand;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName ChoiceDeclaration(ParserContext context) throws ParseException
  {
  Token choiceToken;
  Token nameToken;
  Token delimitToken;
  QualifiedName qualifiedChoiceName;
  Template template;
  String termName;
  int selection = 0;
  boolean isSourceItemPending = context.isSourceItemPending();
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  QualifiedName contextName = context.getContextName();
  StringBuilder builder = new StringBuilder();
    choiceToken = jj_consume_token(CHOICE);
    nameToken = jj_consume_token(IDENTIFIER);
    qualifiedChoiceName = parserAssembler.getContextName(nameToken.image);
    parserAssembler.getListAssembler().createAxiomItemList(qualifiedChoiceName);
    template = parserAssembler.getTemplateAssembler().createTemplate(qualifiedChoiceName, true);
    context.setContextName(new QualifiedTemplateName(context.getScope().getAlias(), nameToken.image));
    context.setSourceMarker(choiceToken, qualifiedChoiceName);
    builder.append("choice ").append(nameToken.image).append('(');
    jj_consume_token(LPAREN);
    termName = TermName(qualifiedChoiceName, parserAssembler);
      builder.append(termName);
    label_17:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      termName = TermName(qualifiedChoiceName, parserAssembler);
      builder.append(',').append(termName);
    }
    delimitToken = jj_consume_token(RPAREN);
    builder.append(')');
    context.addSourceItem(builder.toString()).setEnd(delimitToken);
    label_18:
    while (true) 
    {
      ChoiceItem(selection++, qualifiedChoiceName, template, context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_18;
      }
    }
    context.setContextName(contextName);
    {if (true) return qualifiedChoiceName;}
    throw new Error("Missing return statement in function");
  }

  final public void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, Template template, ParserContext context) throws ParseException
  {
    Operand operand;
    String fact;
    Token delimToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    String name = axiomAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new StringTerm(name + selection));
    QualifiedName term0Name = context.getParserAssembler().getContextName(name);
    StringBuilder builder = new StringBuilder();
    jj_consume_token(LBRACE);
    operand = ChoiceExpression(term0Name, template, context);
     builder.append('{').append(operand.toString());
    label_19:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      fact = Fact(qualifiedAxiomName, context);
        builder.append(',').append(fact);
    }
    delimToken = jj_consume_token(RBRACE);
       parserAssembler.getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.getTemplateAssembler().addTemplate(qualifiedTemplateName, operand);
       builder.append('}');
       context.addSourceItem(builder.toString()).setEnd(delimToken);
  }

  final public Operand ChoiceExpression(QualifiedName qname, Template template, ParserContext context) throws ParseException
  {
  Operand operand;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      operand = Literal(context);
      if (operand.getValueClass() == Unknown.class)
        {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, true);}
      Variable choiceOperand = new Variable(qname);
      {if (true) return new Evaluator(parserAssembler.getContextName(qname.getName() + qname.incrementReferenceCount()), choiceOperand, "==", operand);}
      break;
    case SCOPE:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 98:
      operand = Expression(context);
      {if (true) return operand;}
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void InitialiserList(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String property;
  SourceItem sourceItem;
  Token delimitToken;
    jj_consume_token(LPAREN);
    property = InitialiserDeclaration(properties, context);
    sourceItem = context.addSourceItem(property);
    label_20:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_20;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      property = InitialiserDeclaration(properties, context);
      sourceItem = context.addSourceItem(property);
    }
    delimitToken = jj_consume_token(RPAREN);
    sourceItem.setEnd(delimitToken);
  }

  final public String InitialiserDeclaration(Map<String, Object> properties, ParserContext context) throws ParseException
  {
  String name;
  Parameter param;
    name = Name(context);
    jj_consume_token(ASSIGN);
    param = LiteralTerm(context);
     properties.put(name, param.getValue());
     {if (true) return name + "=" + param.getValue().toString();}
    throw new Error("Missing return statement in function");
  }

  final public void TermList(List<Term> termList, ParserContext context) throws ParseException
  {
  String property;
  SourceItem sourceItem;
  Token delimitToken;
    jj_consume_token(LPAREN);
    property = TermDeclaration(termList, context);
    sourceItem = context.addSourceItem(property);
    label_21:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_21;
      }
      delimitToken = jj_consume_token(COMMA);
      sourceItem.setEnd(delimitToken);
      property = TermDeclaration(termList, context);
      sourceItem = context.addSourceItem(property);
    }
    delimitToken = jj_consume_token(RPAREN);
    sourceItem.setEnd(delimitToken);
  }

  final public String TermDeclaration(List<Term> termList, ParserContext context) throws ParseException
  {
  Parameter param;
  String name = Term.ANONYMOUS;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      name = Name(context);
      jj_consume_token(ASSIGN);
      break;
    default:
      jj_la1[77] = jj_gen;
      ;
    }
    param = LiteralTerm(context);
     termList.add(new Parameter(name, param.getValue()));
     if (name.isEmpty())
       {if (true) return param.getValue().toString();}
     {if (true) return name + "=" + param.getValue().toString();}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(String name, Template template, ParserAssembler parserAssembler) throws ParseException
  {
  Group group = new Group(name);
    jj_consume_token(LBRACE);
    Group(group, template, parserAssembler);
    label_22:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_22;
      }
      jj_consume_token(COMMA);
      Group(group, template, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Template template, ParserAssembler parserAssembler) throws ParseException
  {
  Token groupToken;
  Token dotToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case DOT:
      dotToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    groupToken = jj_consume_token(IDENTIFIER);
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null, parserAssembler.getQualifiedContextname());
    template.addTerm(var);
    group.addGroup(var);
    if (dotToken != null)
        var.setPrivate(true);
  }

  final public List<Parameter> LiteralList(ParserContext context) throws ParseException
  {
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
    parameter = LiteralTerm(context);
    literalList.add(parameter);
    label_23:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_23;
      }
      jj_consume_token(COMMA);
      parameter = LiteralTerm(context);
      literalList.add(parameter);
    }
    {if (true) return literalList;}
    throw new Error("Missing return statement in function");
  }

  final public void VariableInitialization(ParserContext context) throws ParseException
  {
  Operand var;
  Token delimitToken;
    var = VariableDeclaration(context);
    delimitToken = jj_consume_token(SEMICOLON);
      if (var == null)
        {if (true) return;}
      context.getOperandMap().addOperand(var);
      context.setSourceMarker(context.getItemToken(), var.getQualifiedName());
      addSourceVariable(var, context).setEnd(delimitToken);
  }

  final public Operand VariableDeclaration(ParserContext context) throws ParseException
  {
  Token nameToken;
  String name;
  boolean isUntyped = true;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  Operand expression = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  context.setSourceItemPending(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      isUntyped = false;
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    name = nameToken.image;
    if (isUntyped)
      context.onTokenIntercept(nameToken);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
    case RARROW:
      listIndexData = IndexExpression(context.getQualifiedName(nameToken.image), context);
      break;
    default:
      jj_la1[82] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(context);
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
      if ((listIndexData !=null) && (listIndexData.length > 1))
       {if (true) throw new ParseException("Axiom list variable \u005c"" + name + "\u005c" cannot be declared here");}
     if (listIndexData !=null)
       {if (true) return initList(context, listIndexData[0], expression);}
     if (isUntyped)
       varType = new VariableType(OperandType.UNKNOWN);
     if (expression != null) //  Need literal condition? && !(expression instanceof Evaluator)
       varType.setProperty(expression.isEmpty() ? VariableType.EXPRESSION : VariableType.LITERAL, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public String ListDeclaration(ParserContext context) throws ParseException
  {
  Token keywordToken;
  Token nameToken;
  Token delimitToken;
  String listName;
  Token axiomToken = null;
  Token exportToken = null;
  VariableType varType = null;
  QualifiedName qualifiedAxiomName = null;
  QualifiedName contextName = null;
  Template template = null;
  Template initializeTemplate = null;
  Token beginToken = null;
  Token endToken = null;
  Operand operand = null;
  SourceItem sourceItem = null;
  List<Template> axiomList;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LIST:
    case EXPORT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EXPORT:
        exportToken = jj_consume_token(EXPORT);
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
      keywordToken = jj_consume_token(LIST);
      break;
    case LOCAL:
      keywordToken = jj_consume_token(LOCAL);
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
        varType = Type(context);
        break;
      case AXIOM:
        axiomToken = jj_consume_token(AXIOM);
        break;
      default:
        jj_la1[86] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[87] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    listName = nameToken.image;
    if (axiomToken != null)
      contextName = context.getContextName();
    if (contextName != null)
      template = createDynamicAxiomTemplate(listName, context);
    if (template != null)
      qualifiedAxiomName = parserAssembler.getContextName(listName);
    context.setSourceMarker(keywordToken, listName);
    context.setSourceItemPending(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
    case LBRACE:
    case ASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case IDENTIFIER:
          qualifiedAxiomName = Axiom(context);
          break;
        case INTEGER_LITERAL:
          beginToken = jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(COMMA);
          endToken = jj_consume_token(INTEGER_LITERAL);
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case ASSIGN:
        jj_consume_token(ASSIGN);
        jj_consume_token(LBRACE);
        template = ListParameters(listName, varType, context);
        jj_consume_token(RBRACE);
        break;
      case LBRACE:
        axiomList = AxiomList(qualifiedAxiomName, context);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LPAREN:
          jj_consume_token(LPAREN);
          initializeTemplate = Parameters(listName, context, true);
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[89] = jj_gen;
          ;
        }
      varType = new VariableType(OperandType.LIST);
      varType.setProperty(VariableType.PARAMS, axiomList);
      if (initializeTemplate != null)
        varType.setProperty(VariableType.TEMPLATE, initializeTemplate);
      operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
      template.addTerm(operand);
      context.getOperandMap().addOperand(operand);
      sourceItem = context.addSourceItem(operand);
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(SEMICOLON);
    if (contextName != null)
      context.setContextName(contextName);
    if (sourceItem != null)
      sourceItem.setEnd(delimitToken);
    if (axiomToken != null)
      {if (true) return listName;}
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    if ((varType == null) && (qualifiedAxiomName == null))
      {if (true) throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Missing type or axiom name.");}
    if ((varType != null) && isLocal)
      {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Type in declaration not allowed.");}
    if (varType == null)
      varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
      varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList;
    if (template != null)
      itemList = varType.getDynamicListInstance(parserAssembler, listName, template);
    else
      itemList = varType.getItemListInstance(parserAssembler, listName);
    if (exportToken !=null)
      itemList.setPublic(true);
    if (beginToken != null)
      sizeList(itemList, varType.getOperandType(), Integer.parseInt(beginToken.image), Integer.parseInt(endToken.image));
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
    if (sourceItem == null)
      context.addSourceItem(itemList).setEnd(delimitToken);
    {if (true) return listName;}
    throw new Error("Missing return statement in function");
  }

  final public Operand CursorDeclaration(ParserContext context) throws ParseException
  {
  Token keywordToken;
  Token nameToken;
  Token listToken;
  Token delimitToken;
  String cursorName;
  VariableType varType = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    keywordToken = jj_consume_token(CURSOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      varType = Type(context);
      jj_consume_token(GT);
      break;
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    cursorName = nameToken.image;
    context.setSourceMarker(keywordToken, cursorName);
    context.setSourceItemPending(false);
    delimitToken = new Token(QueryParserConstants.SEMICOLON, ";");
    delimitToken.beginColumn = nameToken.endColumn;
    delimitToken.endColumn = nameToken.endColumn;
    delimitToken.beginLine = nameToken.beginLine;
    delimitToken.endLine = nameToken.endLine;
    jj_consume_token(LPAREN);
    listToken = jj_consume_token(IDENTIFIER);
    delimitToken = jj_consume_token(RPAREN);
    if (varType == null)
      varType = new VariableType(OperandType.UNKNOWN);
    QualifiedName listName = context.getQualifiedName(listToken.image);
    QualifiedName qname = new QualifiedName(listName.getName() + "_cursor", listName);
    ArrayIndex arrayIndex = new ArrayIndex(listName, 0, "cursor");
    Cursor cursor = new Cursor(qname, listName, arrayIndex);
    ParserTask parserTask = parserAssembler.addPending(cursor);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    varType.setProperty(VariableType.EXPRESSION, cursor);
    Operand var = varType.getInstance(parserAssembler, cursorName);
    parserAssembler.getOperandMap().addOperand(var);
    delimitToken.beginColumn += 1;
    delimitToken.endColumn += 1;
    context.addSourceItem(var).setEnd(delimitToken);
    {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public Template ListParameters(String listName, VariableType varType, ParserContext context) throws ParseException
  {
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  Operand var = null;
  if (varType == null)
      throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Type omitted from declaration.");
    expression = Expression(context);
    if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
      var = expression;
    if (var == null)
      var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
    template.addTerm(var);
    label_24:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_24;
      }
      jj_consume_token(COMMA);
      expression = Expression(context);
      var = null;
      if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
        var = expression;
      if (var == null)
        var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
      template.addTerm(var);
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public void Include(ParserContext context) throws ParseException
  {
  Token includeToken = null;
    jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    includeResource(includeToken.image, context);
  }

  final public Operand Expression(ParserContext context) throws ParseException
  {
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
    param = ConditionalOrExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      case LSHIFTASSIGN:
        assignToken = jj_consume_token(LSHIFTASSIGN);
        break;
      case RSIGNEDSHIFTASSIGN:
        assignToken = jj_consume_token(RSIGNEDSHIFTASSIGN);
        break;
      case RUNSIGNEDSHIFTASSIGN:
        assignToken = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
        break;
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      assignOperand = Expression(context);
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return new Evaluator(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PrimaryExpression(ParserContext context) throws ParseException
  {
  Operand operand;
  QualifiedName qname;
  ListItemSpec[] listIndexData;
  String name = null;
  Token literal = null;
  Operand param1 = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal(context);
    {if (true) return param1;}
      break;
    case IDENTIFIER:
      name = Name(context);
      if (jj_2_2(2)) 
      {
        param1 = NamedExpression(name, context);
      } else 
      {
        ;
      }
    if (param1 == null)
        {if (true) return parserAssembler.addOperand(name);}
    {if (true) return param1;}
      break;
    case SCOPE:
      literal = jj_consume_token(SCOPE);
      listIndexData = IndexExpression(context.getQualifiedName("scope"), context);
    if (listIndexData.length > 1)
         {if (true) throw new ParseException("Scope cannot be accessed using axiom list variable");}
    operand = listItemOperand(context, listIndexData[0]);
    context.onTokenIntercept(literal);
    {if (true) return operand;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      param1 = Expression(context);
      jj_consume_token(RPAREN);
    {if (true) return param1;}
      break;
    default:
      jj_la1[96] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ListItemSpec[] IndexExpression(QualifiedName listName, ParserContext context) throws ParseException
  {
  Object index1;
  Object index2 = null;
  int dimension = 1;
    index1 = ListSelection1(context);
    if (jj_2_3(2)) 
    {
      index2 = ListSelection2(context);
                                                                                       ++dimension;
    } else 
    {
      ;
    }
     if ((dimension == 2) && (index1 instanceof String))
       {if (true) throw new ParseException("Axiom list \u005c"" + listName.getName() + "\u005c" axiom cannot be selected by name");}
     if ((dimension == 1) && (index1 instanceof String))
       {if (true) return new ListItemSpec[] { new ListIndex(listName, (String)index1) };}
     if (dimension == 1)
       {if (true) return new ListItemSpec[] { new ListIndex(listName, (Operand)index1) };}
     ListItemSpec listItemSpec1 = null;
     if (index1 instanceof String)
         listItemSpec1 = new ListIndex(listName, (String)index1);
     else
         listItemSpec1 = new ArrayIndex(listName, (Operand)index1);
     ListItemSpec listItemSpec2 = null;
     if (index2 instanceof String)
       listItemSpec2 = new ListIndex(listName, (String)index2);
     else
       listItemSpec2 = new ListIndex(listName, (Operand)index2);
     {if (true) return new ListItemSpec[] { listItemSpec1, listItemSpec2 };}
    throw new Error("Missing return statement in function");
  }

  final public Object ListSelection1(ParserContext context) throws ParseException
  {
  Token name;
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      param = Expression(context);
      jj_consume_token(RBRACKET);
    {if (true) return param;}
      break;
    case RARROW:
      jj_consume_token(RARROW);
      name = jj_consume_token(IDENTIFIER);
    {if (true) return name.image;}
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Object ListSelection2(ParserContext context) throws ParseException
  {
  Token name;
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      param = Expression(context);
      jj_consume_token(RBRACKET);
    {if (true) return param;}
      break;
    case DOT:
      jj_consume_token(DOT);
      name = jj_consume_token(IDENTIFIER);
    {if (true) return name.image;}
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand Literal(ParserContext context) throws ParseException
  {
  Token lit;
  Operand operand;
  boolean flag;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    Long litValue = Long.decode(lit.image);
    operand = new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    operand = new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    operand = new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
        parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    {if (true) return operand;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableType Type(ParserContext context) throws ParseException
  {
  Token literalToken;
  VariableType varType;
  Token qualifierLit = null;
  String qualifierId = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
      literalToken = jj_consume_token(INTEGER);
      varType = new VariableType(OperandType.INTEGER);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case BOOLEAN:
      literalToken = jj_consume_token(BOOLEAN);
      varType = new VariableType(OperandType.BOOLEAN);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DOUBLE:
      literalToken = jj_consume_token(DOUBLE);
      varType = new VariableType(OperandType.DOUBLE);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case STRING:
      literalToken = jj_consume_token(STRING);
      varType = new VariableType(OperandType.STRING);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case DECIMAL:
      literalToken = jj_consume_token(DECIMAL);
      varType = new VariableType(OperandType.DECIMAL);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case TERM:
      literalToken = jj_consume_token(TERM);
      varType = new VariableType(OperandType.TERM);
      context.onTokenIntercept(literalToken);
      {if (true) return varType;}
      break;
    case CURRENCY:
      literalToken = jj_consume_token(CURRENCY);
      context.onTokenIntercept(literalToken);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 97:
        jj_consume_token(97);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          qualifierLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          qualifierId = Name(context);
          break;
        default:
          jj_la1[100] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[101] = jj_gen;
        ;
      }
      varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, context.getOperandMap().addOperand(qualifierId, null, context.getParserAssembler().getQualifiedContextname()));
       {if (true) return varType;}
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(PARAMETER);
    parserAssembler.setParameter(qualifiedAxiomName);
  }

  final public String Name(ParserContext context) throws ParseException
  {
  String name;
  Token partToken;
    partToken = jj_consume_token(IDENTIFIER);
    name = partToken.image;
    context.onTokenIntercept(partToken);
    label_25:
    while (true) 
    {
      if (jj_2_4(2)) 
      {
        ;
      } else 
      {
        break label_25;
      }
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      name += ("." + partToken.image);
    }
    {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public Operand NamedExpression(String name, ParserContext context) throws ParseException
  {
  ListItemSpec[] indexData;
  QualifiedName listName;
  ParserTask parserTask;
  Template parametersTemplate = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
    case RARROW:
      indexData = IndexExpression(context.getQualifiedName(name), context);
    {if (true) return indexData.length == 1 ?
    listItemOperand(context, indexData[0]) :
    axiomContainerOperand(parserAssembler, indexData);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
        parametersTemplate = Parameters(name, context, true);
        break;
      default:
        jj_la1[103] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    QualifiedName qname = parserAssembler.getContextName(name);
    {if (true) return parserAssembler.getCallOperand(qname, parametersTemplate);}
      break;
    case DOT:
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LENGTH:
        jj_consume_token(LENGTH);
      listName = context.getQualifiedName(name);
      qname = new QualifiedName(listName.getName() + "_length", listName);
      ListLength listLength = new ListLength(qname, listName);
      parserTask = context.getParserAssembler().addPending(listLength);
      parserTask.setPriority(ParserTask.Priority.variable.ordinal());
      {if (true) return listLength;}
        break;
      case FORMAT:
        jj_consume_token(FORMAT);
      Operand operand = parserAssembler.addOperand(name);
      qname = parserAssembler.getContextName(name + "_format");
      Scope scope = parserAssembler.getScope();
      FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
      if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
      {if (true) return formatter;}
        break;
      case FACT:
        jj_consume_token(FACT);
      Operand factOperand = parserAssembler.addOperand(name);
      {if (true) return new FactOperand(factOperand);}
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Template Parameters(String callName, ParserContext context, boolean nameRequired) throws ParseException
  {
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  String functionKey = outerTemplateName.getTemplate() + "." + callName;
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  template.setKey(functionKey);
    expression = ParameterExpression(context, nameRequired);
      template.addTerm(expression);
    label_26:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_26;
      }
      jj_consume_token(COMMA);
      expression = ParameterExpression(context, nameRequired);
        template.addTerm(expression);
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Operand ParameterExpression(ParserContext context, boolean nameRequired) throws ParseException
  {
  Token identifier = null;
  Parameter parameter = null;
  Operand expression = null;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      break;
    default:
      jj_la1[107] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      identifier = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACKET:
      case RARROW:
        listIndexData = IndexExpression(context.getQualifiedName(identifier.image), context);
        break;
      default:
        jj_la1[108] = jj_gen;
        ;
      }
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      parameter = LiteralTerm(context);
      break;
    default:
      jj_la1[109] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(context);
      break;
    default:
      jj_la1[110] = jj_gen;
      ;
    }
     String name = (identifier == null) ? Term.ANONYMOUS : identifier.image;
     QualifiedName qname = parserAssembler.getContextName(name);
     Operand var = null;
     if (parameter != null)
       var = new Variable(qname);
     if (var != null)
       var.assign(parameter);
     if ((var == null) && (varType == null))
       var = parserAssembler.getOperandMap().getOperand(qname);
     if (var != null)
       {if (true) return var;}
     if (operandMap.hasOperand(name, parserAssembler.getQualifiedContextname()))
         var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
     if (var != null)
       {if (true) {if (true) return var;}}
     if (listIndexData !=null)
       var = listIndexData.length == 1 ? listItemOperand(context, name, listIndexData[0]) : axiomContainerOperand(parserAssembler, name, listIndexData);
     if (var != null)
       {if (true) return var;}
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     if (varType.getOperandType() == OperandType.TERM)
       varType.setUnknownType();
     if (expression != null)
       varType.setProperty(VariableType.EXPRESSION, expression);
     {if (true) return varType.getInstance(parserAssembler, name);}
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm(ParserContext context) throws ParseException
  {
  Token lit;
  Parameter param;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    param = new IntegerTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    param = new DoubleTerm(lit.image);
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    param = new StringTerm(getText(lit));
    context.onTokenIntercept(lit);
    {if (true) return param;}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(context);
    {if (true) return new BooleanTerm(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(context);
    {if (true) return new LiteralParameter(Term.ANONYMOUS, new Unknown(), LiteralType.unknown);}
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Parameter MacroLiteralTerm(ParserContext context) throws ParseException
  {
  VariableType varType;
  Parameter literal;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(context);
      jj_consume_token(LPAREN);
      literal = LiteralTerm(context);
      jj_consume_token(RPAREN);
    {if (true) return varType.getParameter(literal);}
      break;
    case IDENTIFIER:
      literal = Function(context);
    {if (true) return literal;}
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Parameter Function(ParserContext context) throws ParseException
  {
  Token name;
  Token library;
  List<Term> termList = new ArrayList<Term>();
    library = jj_consume_token(IDENTIFIER);
    jj_consume_token(DOT);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      TermList(termList, context);
      break;
    default:
      jj_la1[113] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
     {if (true) return context.getParserAssembler().callFunction(library.image, name.image, termList);}
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TRUE:
      lit = jj_consume_token(TRUE);
    context.onTokenIntercept(lit);
    {if (true) return true;}
      break;
    case FALSE:
      lit = jj_consume_token(FALSE);
    context.onTokenIntercept(lit);
    {if (true) return false;}
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral(ParserContext context) throws ParseException
  {
  Token lit;
    lit = jj_consume_token(UNKNOWN);
    context.onTokenIntercept(lit);
  }

  final public Operand ConditionalOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ConditionalAndExpression(context);
    label_27:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_27;
      }
      op = jj_consume_token(SC_OR);
      params[1] = ConditionalAndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalAndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = InclusiveOrExpression(context);
    label_28:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[116] = jj_gen;
        break label_28;
      }
      op = jj_consume_token(SC_AND);
      params[1] = InclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand InclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ExclusiveOrExpression(context);
    label_29:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[117] = jj_gen;
        break label_29;
      }
      op = jj_consume_token(BIT_OR);
      params[1] = ExclusiveOrExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ExclusiveOrExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AndExpression(context);
    label_30:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case XOR:
        ;
        break;
      default:
        jj_la1[118] = jj_gen;
        break label_30;
      }
      op = jj_consume_token(XOR);
      params[1] = AndExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AndExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = EqualityExpression(context);
    label_31:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[119] = jj_gen;
        break label_31;
      }
      op = jj_consume_token(BIT_AND);
      params[1] = EqualityExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand EqualityExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = RelationalExpression(context);
    label_32:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[120] = jj_gen;
        break label_32;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = RelationalExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand RelationalExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AdditiveExpression(context);
    label_33:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
      case LE:
      case GE:
      case GT:
        ;
        break;
      default:
        jj_la1[122] = jj_gen;
        break label_33;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = ShiftExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ShiftExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  String op;
    params[0] = AdditiveExpression(context);
    label_34:
    while (true) 
    {
      if (jj_2_5(1)) 
      {
        ;
      } else 
      {
        break label_34;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LSHIFT:
        jj_consume_token(LSHIFT);
        op="<<";
        break;
      default:
        jj_la1[124] = jj_gen;
        if (jj_2_6(1)) 
        {
          RSIGNEDSHIFT();
        op=">>";
        } else if (jj_2_7(1)) 
        {
          RUNSIGNEDSHIFT();
         op=">>>";
        } else 
        {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      params[1] = AdditiveExpression(context);
       params[0] = new Evaluator(params[0], op, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AdditiveExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = MultiplicativeExpression(context);
    label_35:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[125] = jj_gen;
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = MultiplicativeExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand MultiplicativeExpression(ParserContext context) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = UnaryExpression(context);
    label_36:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[127] = jj_gen;
        break label_36;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = UnaryExpression(context);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case PLUS:
    case MINUS:
    case 98:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        jj_consume_token(PLUS);
      plus = true;
        break;
      case MINUS:
        jj_consume_token(MINUS);
      minus = true;
        break;
      case 98:
        jj_consume_token(98);
      tilde = true;
        break;
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      param = UnaryExpression(context);
    if (plus)
      {if (true) return new Evaluator(param, "+", Orientation.unary_prefix);}
    else if (minus)
      {if (true) return new Evaluator(param, "-", Orientation.unary_prefix);}
    else if (tilde)
      {if (true) return new Evaluator(param, "~", Orientation.unary_prefix);}
    {if (true) return param;}
      break;
    case INCR:
      param = PreIncrementExpression(context);
    {if (true) return param;}
      break;
    case DECR:
      param = PreDecrementExpression(context);
    {if (true) return param;}
      break;
    case SCOPE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
      param = UnaryExpressionNotPlusMinus(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[130] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PreIncrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(INCR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator(param, "++", Orientation.unary_prefix);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PreDecrementExpression(ParserContext context) throws ParseException
  {
  Operand param;
    jj_consume_token(DECR);
    param = PrimaryExpression(context);
    {if (true) return new Evaluator(param, "--", Orientation.unary_prefix);}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpressionNotPlusMinus(ParserContext context) throws ParseException
  {
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BANG:
      jj_consume_token(BANG);
      param = UnaryExpression(context);
    {if (true) return new Evaluator(param, "!", Orientation.unary_prefix);}
      break;
    case SCOPE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
      param = PostfixExpression(context);
    {if (true) return param;}
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PostfixExpression(ParserContext context) throws ParseException
  {
  Operand param;
  boolean incr = false;
  boolean decr = false;
    param = PrimaryExpression(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INCR:
        jj_consume_token(INCR);
      incr = true;
        break;
      case DECR:
        jj_consume_token(DECR);
      decr = true;
        break;
      default:
        jj_la1[132] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[133] = jj_gen;
      ;
    }
    if (incr)
       {if (true) return new Evaluator(param, "++", Orientation.unary_postfix);}
    else if (decr)
       {if (true) return new Evaluator(param, "--", Orientation.unary_postfix);}
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */
  final public void RUNSIGNEDSHIFT() throws ParseException
  {
    if (getToken(1).kind == GT &&
                    ((MyToken)getToken(1)).realKind == RUNSIGNEDSHIFT) 
    {

    } else 
    {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
    jj_consume_token(GT);
  }

  final public void RSIGNEDSHIFT() throws ParseException
  {
    if (getToken(1).kind == GT &&
                    ((MyToken)getToken(1)).realKind == RSIGNEDSHIFT) 
    {

    } else 
    {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_3R_124() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(FACT)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(RARROW)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT &&
                ((MyToken)getToken(1)).realKind == RSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_50()) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    }
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT &&
                ((MyToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_51()) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(LSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_5() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(CURRENCY)) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(NAN)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(DECIMAL)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_60()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    }
    return false;
  }

  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_60()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(98)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    }
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[134];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static 
  {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
    jj_la1_init_3();
  }
  private static void jj_la1_init_0() 
  {
    jj_la1_0 = new int[] { 0x800000,0x2d47dfc0,0x2d47dfc0,0x0,0x0,0x20001000,0x0,0x0,0x0,0x2d475fc0,0x2d475fc0,0x401000,0x0,0x0,0x0,0x0,0x0,0x2d465fc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14007c0,0x14007c0,0x0,0x14007c0,0x0,0x0,0x0,0x0,0x0,0x0,0x24140000,0x940a7c0,0x0,0x940a7c0,0x0,0x14007c0,0x0,0x0,0x0,0x9000,0x0,0x0,0x14007c0,0x0,0x0,0x0,0x0,0x14027c0,0x0,0x0,0x0,0x940a7c0,0x140a7c0,0x940a7c0,0x0,0x0,0x0,0xc0000000,0xc0000000,0x14007c0,0x0,0x0,0x940a7c0,0x0,0x940a7c0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x14007c0,0x0,0x0,0x20000000,0x24040000,0x14017c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x14007c0,0x14007c0,0x2280000,0x0,0x0,0x14007c0,0x0,0x0,0x0,0x0,0x14007c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0, };
  }
  private static void jj_la1_init_1() 
  {
    jj_la1_1 = new int[] { 0x0,0x20000,0x20000,0x2000000,0x40000,0x0,0x20000000,0x0,0x40000,0x20000,0x20000,0x0,0x40000000,0x8000000,0x2000000,0x40000,0x0,0x20000,0x100000,0x100000,0x100000,0x2000000,0x20000,0x0,0x2000000,0x0,0x2f480,0x3f480,0x100000,0x2f480,0x0,0x4000000,0x2000000,0x4000000,0x40000000,0x0,0x0,0x9416f480,0x2000000,0x9416f480,0x40000,0x0,0x8400000,0x20000000,0x20000,0x8006f480,0x0,0x80000000,0x2f480,0xa0140000,0xa0140000,0x0,0x0,0x20000,0x0,0x100000,0x4000000,0x8416f480,0x8006f480,0x8016f480,0x40000,0x21000,0x100000,0x7f,0x7f,0x2f480,0x8000000,0x2000000,0x9416f480,0x2000000,0x9416f480,0x2000000,0x100000,0x2000000,0x8006f480,0x2000000,0x2000000,0x20000,0x2000000,0x4000000,0x2000000,0x0,0x8400000,0x20000000,0x0,0x0,0x0,0x40000000,0x20080,0x40000,0x20140000,0x20140000,0x40000000,0x2000000,0x20000000,0x20000000,0x6f480,0x8400000,0x4400000,0xf480,0x21000,0x0,0x0,0x2f480,0x0,0xc440000,0x2000000,0x0,0x8400000,0x2f480,0x20000000,0xf480,0x20000,0x40000,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8006f480,0x8006f480,0x0,0x0, };
  }
  private static void jj_la1_init_2() 
  {
    jj_la1_2 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x1,0x0,0x0,0x8000,0x8000,0x8000,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x400,0x0,0xf03,0x0,0xf03,0x0,0x0,0x0,0x80000,0x0,0xf00,0x3ff00000,0x0,0x0,0x3ff80000,0x3ff80000,0x3,0x3,0x0,0x3,0x0,0x0,0xf03,0xf00,0xf00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf03,0x0,0xf03,0x0,0x0,0x0,0xf00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ff80000,0x3ff80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x80,0x8000,0x10000,0x4000,0x24,0x24,0x18,0x18,0x40000,0xc00,0xc00,0x23000,0x23000,0xc00,0xf00,0x0,0x300,0x300, };
  }
  private static void jj_la1_init_3() 
  {
    jj_la1_3 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0, };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[7];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) 
  {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) 
   {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) 
  {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) 
  {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 134; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException 
  {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) 
    {
      jj_gen++;
      if (++jj_gc > 100) 
      {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) 
        {
          JJCalls c = jj_2_rtns[i];
          while (c != null) 
          {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) 
  {
    if (jj_scanpos == jj_lastpos) 
    {
      jj_la--;
      if (jj_scanpos.next == null) 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else 
    {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) 
    {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() 
  {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) 
  {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) 
    {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() 
  {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) 
  {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) 
    {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) 
    {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) 
    {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) 
      {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) 
        {
          for (int i = 0; i < jj_expentry.length; i++) 
          {
            if (oldentry[i] != jj_expentry[i]) 
            {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() 
  {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[99];
    if (jj_kind >= 0) 
    {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 134; i++) 
    {
      if (jj_la1[i] == jj_gen) 
      {
        for (int j = 0; j < 32; j++) 
        {
          if ((jj_la1_0[i] & (1<<j)) != 0) 
          {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) 
          {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) 
          {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) 
          {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 99; i++) 
    {
      if (la1tokens[i]) 
      {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) 
    {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() 
  {
  }

  /** Disable tracing. */
  final public void disable_tracing() 
  {
  }

  private void jj_rescan_token() 
  {
    jj_rescan = true;
    for (int i = 0; i < 7; i++) 
    {
    try 
      {
      JJCalls p = jj_2_rtns[i];
      do 
        {
        if (p.gen > jj_gen) 
          {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) 
            {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) 
  {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) 
    {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls 
  {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
