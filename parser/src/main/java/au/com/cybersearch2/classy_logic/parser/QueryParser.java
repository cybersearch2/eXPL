/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
package au.com.cybersearch2.classy_logic.parser;

import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.LoopEvaluator;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.NumberTerm;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.helper.Null;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;
import au.com.cybersearch2.classy_logic.helper.OperandParam;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser implements QueryParserConstants 
{

  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    parser.input(queryProgram);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    input(queryProgram);
    return queryProgram;
   }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, QueryProgram queryProgram) throws ParseException
  {
     if (resourceName.length() < 3)
        throw new ParseException("Include resourceName \u005c"\u005c" is invalid");
     ParserResources parserResources = new ParserResources(queryProgram);
     try
     {
         parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
     }
     catch (IOException e)
     {
         throw new ParseException(e.getMessage());
     }
  }

  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  }

/** Root production. */
  final public void input(QueryProgram queryProgram) throws ParseException
  {
    label_1:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case RESOURCE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ResourceDeclaration(queryProgram);
      jj_consume_token(SEMICOLON);
    }
    label_2:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(queryProgram, queryProgram.getGlobalScope());
        break;
      case QUERY:
        QueryChain(queryProgram.getGlobalScope());
        break;
      case SCOPE:
        ScopeDeclaration(queryProgram);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case SCOPE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(0);
  }

  final public void ScopeDeclaration(QueryProgram queryProgram) throws ParseException
  {
  Scope scope;
    jj_consume_token(SCOPE);
    scope = Scope(queryProgram);
    jj_consume_token(LBRACE);
    label_3:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(queryProgram, scope);
        break;
      case QUERY:
        QueryChain(scope);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);

  }

  final public Scope Scope(QueryProgram queryProgram) throws ParseException
  {
  Token scopeToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    scopeToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
      {if (true) return queryProgram.scopeInstance(scopeToken.image , properties);}
    throw new Error("Missing return statement in function");
  }

  final public void QueryChain(Scope scope) throws ParseException
  {
    QuerySpec querySpec;
    jj_consume_token(QUERY);
    querySpec = Query();
    querySpec = QueryDeclaration(querySpec, scope);
    label_4:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 78:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      jj_consume_token(78);
      QueryDeclaration(querySpec.chain(), scope);
    }
    jj_consume_token(SEMICOLON);
      scope.addQuerySpec(querySpec);
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, Scope scope) throws ParseException
  {
  KeyName firstKeyname;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec);
    label_5:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      KeyName(querySpec);
            ++keynameCount;
    }
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
        {if (true) return scope.buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec Query() throws ParseException
  {
    Token queryToken;
    queryToken = jj_consume_token(IDENTIFIER);
    {if (true) return new QuerySpec(queryToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public void Statement(QueryProgram queryProgram, Scope scope) throws ParseException
  {
  Operand var;
  ParserAssembler parserAssembler = scope.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      var = VariableDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      parserAssembler.getOperandMap().addOperand(var);
      break;
    case TEMPLATE:
      TemplateDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case CALC:
      CalculatorTemplate(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case AXIOM:
      AxiomDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case CHOICE:
      ChoiceDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case LIST:
    case LOCAL:
      ListDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case INCLUDE:
      Include(queryProgram);
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Include(QueryProgram queryProgram) throws ParseException
  {
  Token includeToken = null;
    jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    includeResource(includeToken.image, queryProgram);
  }

  final public void ListDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Token keywordToken;
    Token nameToken;
    VariableType varType = null;
    QualifiedName qualifiedBindingName = null;
    QualifiedName qualifiedAxiomName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LIST:
      keywordToken = jj_consume_token(LIST);
      break;
    case LOCAL:
      keywordToken = jj_consume_token(LOCAL);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      varType = Type(parserAssembler.getOperandMap());
      jj_consume_token(GT);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      qualifiedAxiomName = Axiom(parserAssembler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        qualifiedBindingName = ResourceBinding(QueryParserConstants.TEMPLATE, qualifiedAxiomName, parserAssembler);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    String listName = nameToken.image;
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    boolean isTermList = (varType != null) && varType.getOperandType() == OperandType.TERM;
    if ((varType == null) && (qualifiedAxiomName == null))
        {if (true) throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Missing type or axiom name.");}
    if ((varType != null) && isLocal)
        {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Type in declaration not allowed.");}
    if ((qualifiedBindingName != null) && !isTermList)
        {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Only Term Type list can be bound to a resource");}
    if (qualifiedBindingName != null)
        qualifiedAxiomName = qualifiedBindingName;
    if (varType == null)
        varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
        varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getOperandMap().addItemList(itemList.getQualifiedName(), itemList);
  }

  final public VariableType Type(OperandMap operandMap) throws ParseException
  {
    Token qualifierLit = null;
    String qualifierId = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
      jj_consume_token(INTEGER);
      {if (true) return new VariableType(OperandType.INTEGER);}
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
      {if (true) return new VariableType(OperandType.BOOLEAN);}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      {if (true) return new VariableType(OperandType.DOUBLE);}
      break;
    case STRING:
      jj_consume_token(STRING);
      {if (true) return new VariableType(OperandType.STRING);}
      break;
    case DECIMAL:
      jj_consume_token(DECIMAL);
      {if (true) return new VariableType(OperandType.DECIMAL);}
      break;
    case TERM:
      jj_consume_token(TERM);
      {if (true) return new VariableType(OperandType.TERM);}
      break;
    case CURRENCY:
      jj_consume_token(CURRENCY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          qualifierLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          qualifierId = Name();
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      VariableType varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, operandMap.addOperand(qualifierId, null));
      {if (true) return varType;}
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TemplateDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    jj_consume_token(TEMPLATE);
    template = Template(parserAssembler, false);
    jj_consume_token(LPAREN);
    TemplateExpression(template, parserAssembler);
    label_6:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      TemplateExpression(template, parserAssembler);
    }
    jj_consume_token(RPAREN);
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
  }

  final public Template Template(ParserAssembler parserAssembler, boolean isCalculator) throws ParseException
  {
    Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
      QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), templateToken.image);
      parserAssembler.getOperandMap().setQualifiedContextname(qualifiedTemplateName);
      {if (true) return parserAssembler.createTemplate(qualifiedTemplateName, isCalculator);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorTemplate(ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    Map<String, Object> properties = new HashMap<String, Object>();
    int loopNumber = 0;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    jj_consume_token(CALC);
    template = Template(parserAssembler, true);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case AXIOM:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case BANG:
    case COLON:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 79:
    case 81:
      CalculatorExpression(loopNumber, template, template.getName(), parserAssembler);
      break;
    case TEMPLATE:
    case 80:
      CalculatorQuery(template, parserAssembler);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_7:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case AXIOM:
      case SCOPE:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case COLON:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 79:
      case 81:
        CalculatorExpression(loopNumber, template, template.getName(), parserAssembler);
        break;
      case TEMPLATE:
      case 80:
        CalculatorQuery(template, parserAssembler);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
      if (properties.size() > 0)
          template.addProperties(properties);
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
  }

  final public void InitialiserList(Map<String, Object> properties) throws ParseException
  {
    InitialiserDeclaration(properties);
    label_8:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      InitialiserDeclaration(properties);
    }
  }

  final public void InitialiserDeclaration(Map<String, Object> properties) throws ParseException
  {
    String name;
    Parameter param;
    name = Name();
    jj_consume_token(ASSIGN);
    param = LiteralTerm();
     properties.put(name, param.getValue());
  }

  final public Operand VariableDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Token nameToken;
    VariableType varType = null;
    Operand index = null;
    Operand expression = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(operandMap);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(parserAssembler);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(parserAssembler);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
     String name = nameToken.image;
     if (index !=null)
         {if (true) return parserAssembler.setListVariable(name, index, expression);}
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     boolean isLiteral = (expression != null) &&
                          !expression.isEmpty() && !(expression instanceof Evaluator);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateExpression(Template template, ParserAssembler parserAssembler) throws ParseException
  {
    String name;
    VariableType varType = null;
    Operand index = null;
    Operand var = null;
    Token scToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Operand expression = null;
    Group group = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
    List<Parameter> literalList = null;
    List<OperandParam> axiomList = null;
    QualifiedName qname = null;
    List<OperandParam> operandParamList = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(operandMap);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    name = Name();
       qname = parserAssembler.getContextName(name);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(parserAssembler);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case REGEX:
    case LPAREN:
    case LBRACE:
    case ASSIGN:
    case COLON:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case 79:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
      case COLON:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case 79:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case 79:
          scToken = jj_consume_token(79);
          break;
        case ASSIGN:
          equalsToken = jj_consume_token(ASSIGN);
          break;
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case PLUSASSIGN:
            assignToken = jj_consume_token(PLUSASSIGN);
            break;
          case MINUSASSIGN:
            assignToken = jj_consume_token(MINUSASSIGN);
            break;
          case STARASSIGN:
            assignToken = jj_consume_token(STARASSIGN);
            break;
          case SLASHASSIGN:
            assignToken = jj_consume_token(SLASHASSIGN);
            break;
          case ANDASSIGN:
            assignToken = jj_consume_token(ANDASSIGN);
            break;
          case ORASSIGN:
            assignToken = jj_consume_token(ORASSIGN);
            break;
          case XORASSIGN:
            assignToken = jj_consume_token(XORASSIGN);
            break;
          case REMASSIGN:
            assignToken = jj_consume_token(REMASSIGN);
            break;
          default:
            jj_la1[28] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case AXIOM:
          jj_consume_token(AXIOM);
          axiomList = AxiomList(qname, parserAssembler);
          VariableType axiomListVarType = new VariableType(OperandType.LIST);
          axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
          expression = axiomListVarType.getInstance(parserAssembler, qname);
          break;
        case SCOPE:
        case FACT:
        case LENGTH:
        case FORMAT:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case NUMBER_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case 81:
          expression = Expression(parserAssembler);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case REGEX:
        jj_consume_token(REGEX);
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          regexLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          regexId = jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LBRACE:
          group = GroupDeclaration(template, name, parserAssembler);
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
        literalList = LiteralList();
        jj_consume_token(RBRACE);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case INTEGER:
        case DOUBLE:
        case DECIMAL:
        case BOOLEAN:
        case STRING:
        case SCOPE:
        case FACT:
        case LENGTH:
        case TERM:
        case CURRENCY:
        case FORMAT:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case NUMBER_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case 81:
          operandParamList = ArgumentList(parserAssembler, true);
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
             template.addTerm(parserAssembler.getCallOperand(qname, operandParamList));
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     Operand assignExpression = (assignToken != null) ? expression : null;
     Operand regexOp = null;
     if (regexLit != null)
         regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
     else if (regexId != null)
         regexOp = operandMap.addOperand(regexId.image, null);
     if (assignToken != null)
         expression = null;
     boolean isLiteral = (expression != null) && !expression.isEmpty() && (equalsToken != null);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     if (index !=null)
         var = parserAssembler.setListVariable(name, index, null);
     else if (regexOp != null)
         var = new RegExOperand(qname, regexOp, 0, group);
     else if (scToken != null)
         var = new Evaluator(qname, expression, (scToken.image == "?" ? "&&" : "||"));
     else if (literalList != null)
         var = new LiteralListOperand(qname, literalList);
     else if (!operandMap.hasOperand(name))
         var = varType.getInstance(parserAssembler, name);
     else
         var = operandMap.addOperand(name, expression);
     if ((index == null) && (!operandMap.hasOperand(name)))
         operandMap.addOperand(var);
     if (assignToken != null)
         var = new Evaluator(qname, var, assignToken.image, assignExpression);
     if ((index !=null) && (equalsToken != null) && !isLiteral)
         var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
     template.addTerm(var);
  }

  final public void CalculatorExpression(int loop_number, Template template, String templateName, ParserAssembler parserAssembler) throws ParseException
  {
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case AXIOM:
      jj_consume_token(AXIOM);
      qualifiedAxiomName = Axiom(parserAssembler);
      expression = AxiomVariable(qualifiedAxiomName, parserAssembler);
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
      break;
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      TemplateExpression(template, parserAssembler);
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case LPAREN:
    case BANG:
    case COLON:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 79:
    case 81:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
      case 79:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case 79:
          scToken = jj_consume_token(79);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      expression = Expression(parserAssembler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        innerLoop = InnerCalculator(loop_number + 1, templateName, parserAssembler, scToken != null);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
    if (scToken != null)
      expression = new Evaluator(expression, (scToken.image == "?" ? "&&" : "||"), innerLoop);
    template.addTerm(expression);
      break;
    case LBRACE:
      innerLoop = InnerCalculator(loop_number + 1, templateName, parserAssembler, false);
    template.addTerm(innerLoop);
      break;
    case CHOICE:
      qualifiedAxiomName = ChoiceDeclaration(parserAssembler);
    qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplate(qualifiedTemplateName);
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    QualifiedName qname = QualifiedName.parseName(choiceTemplate.getName(), contextName);
        Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Operand InnerCalculator(int loop_number, String templateName, ParserAssembler parserAssembler, boolean runOnce) throws ParseException
  {
  String loopName = templateName + loop_number;
  QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), templateName);
  Template template = parserAssembler.chainTemplate(qualifiedTemplateName, loopName);
    jj_consume_token(LBRACE);
    CalculatorExpression(loop_number, template, templateName, parserAssembler);
    label_9:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      CalculatorExpression(loop_number, template, templateName, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return new LoopEvaluator(template, runOnce);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorQuery(Template template, ParserAssembler parserAssembler) throws ParseException
  {
  String queryName;
  List<OperandParam> operandParamList = null;
  Template innerTemplate = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TEMPLATE:
      innerTemplate = InnerTemplateDeclaration(template.getQualifiedName(), parserAssembler);
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(80);
    queryName = Name();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      operandParamList = ArgumentList(parserAssembler, false);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    QualifiedName qname = QualifiedName.parseName(queryName);
    Operand queryOperand = parserAssembler.getQueryOperand(qname, operandParamList, innerTemplate);
    template.addTerm(queryOperand);
    if (innerTemplate != null)
        template.setNext(innerTemplate);
  }

  final public Operand CalculatorFunction(ParserAssembler parserAssembler) throws ParseException
  {
    String fnName;
    List<OperandParam> operandParamList = null;
    fnName = Name();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      operandParamList = ArgumentList(parserAssembler, true);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    {if (true) return parserAssembler.getCallOperand(parserAssembler.getContextName(fnName), operandParamList);}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplateDeclaration(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    jj_consume_token(TEMPLATE);
    template = InnerTemplate(ownerQualifiedName, parserAssembler);
    jj_consume_token(LPAREN);
    TemplateExpression(template, parserAssembler);
    label_10:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_10;
      }
      jj_consume_token(COMMA);
      TemplateExpression(template, parserAssembler);
    }
    jj_consume_token(RPAREN);
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplate(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) throws ParseException
  {
    Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedName(templateToken.image, ownerQualifiedName);
    Template innerTemplate = parserAssembler.createTemplate(qualifiedTemplateName, false);
    innerTemplate.setInnerTemplate(true);
    innerTemplate.setKey(templateToken.image);
    {if (true) return innerTemplate;}
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Operand expression = null;
    List<OperandParam> axiomList = null;
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      expression = Expression(parserAssembler);
      break;
    case LBRACE:
      axiomList = AxiomList(qualifiedAxiomName, parserAssembler);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     VariableType varType = new VariableType(axiomList == null ? OperandType.AXIOM : OperandType.LIST);
     if (expression != null)
         varType.setProperty(VariableType.EXPRESSION, expression);
     else
         varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     if (expression != null)
         parserAssembler.setParameter(operand.getQualifiedName());
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> AxiomList(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  String axiomName = qualifiedAxiomName.getName();
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  Operand operand;
    operand = AxiomInitializer(axiomName, axiomName, parserAssembler);
    operandParamList.add(new OperandParam(axiomName, operand));
    label_11:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_11;
      }
      operand = AxiomInitializer(axiomName, axiomName, parserAssembler);
      operandParamList.add(new OperandParam(axiomName, operand));
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomInitializer(String listName, String axiomName, ParserAssembler parserAssembler) throws ParseException
  {
    List<OperandParam> initializeList = null;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case SCOPE:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 81:
      initializeList = ArgumentList(parserAssembler, true);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
     VariableType varType = new VariableType(OperandType.TERM);
     varType.setProperty(VariableType.AXIOM_KEY, axiomName);
     if (initializeList != null)
        varType.setProperty(VariableType.PARAMS, initializeList);
     Operand operand = varType.getInstance(parserAssembler, listName);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Group group = new Group(name);
    jj_consume_token(LBRACE);
    Group(group, template, name, parserAssembler);
    label_12:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_12;
      }
      jj_consume_token(COMMA);
      Group(group, template, name, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Token groupToken;
    groupToken = jj_consume_token(IDENTIFIER);
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null);
    template.addTerm(var);
    group.addGroup(var);
  }

  final public void AxiomDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    QualifiedName qualifiedAxiomName;
    Operand operand = null;
    jj_consume_token(AXIOM);
    qualifiedAxiomName = Axiom(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      AxiomSpecification(qualifiedAxiomName, parserAssembler);
      break;
    case ASSIGN:
      operand = AxiomVariable(qualifiedAxiomName, parserAssembler);
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (operand != null)
            parserAssembler.getOperandMap().addOperand(operand);
  }

  final public void AxiomSpecification(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    parserAssembler.createAxiom(qualifiedAxiomName);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case IDENTIFIER:
      TermName(qualifiedAxiomName, parserAssembler);
      label_13:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        TermName(qualifiedAxiomName, parserAssembler);
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACE:
    case COLON:
      if (jj_2_1(2)) 
      {
        ResourceBinding(QueryParserConstants.AXIOM, qualifiedAxiomName, parserAssembler);
      } else if (jj_2_2(2)) 
      {
        ParameterDeclaration(qualifiedAxiomName, parserAssembler);
      } else 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LBRACE:
          label_14:
          while (true) 
          {
            jj_consume_token(LBRACE);
            AxiomItem(qualifiedAxiomName, parserAssembler);
            jj_consume_token(RBRACE);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
            {
            case LBRACE:
              ;
              break;
            default:
              jj_la1[52] = jj_gen;
              break label_14;
            }
          }
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
  }

  final public QualifiedName ChoiceDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    QualifiedName qualifiedAxiomName;
    int selection = 0;
    OperandMap operandMap = parserAssembler.getOperandMap();
    jj_consume_token(CHOICE);
    qualifiedAxiomName = Choice(parserAssembler);
    jj_consume_token(LPAREN);
    TermName(qualifiedAxiomName, parserAssembler);
    label_15:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      TermName(qualifiedAxiomName, parserAssembler);
    }
    jj_consume_token(RPAREN);
    label_16:
    while (true) 
    {
      ChoiceItem(selection, qualifiedAxiomName, parserAssembler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_16;
      }
    }
      QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
      if (contextName.getTemplate().isEmpty())
          {if (true) return qualifiedAxiomName;}
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
      List<String> termNameList = parserAssembler.getAxiomTermNameList(qualifiedAxiomName);
      for (String termName: termNameList)
          parserAssembler.getOperandMap().addOperand(termName, null);
      operandMap.setQualifiedContextname(contextName);
      {if (true) return qualifiedAxiomName;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Axiom(ParserAssembler parserAssembler) throws ParseException
  {
    String axiomName;
    axiomName = Name();
    {if (true) return axiomName.indexOf(".") == -1 ?
        parserAssembler.getContextName(axiomName) :
        QualifiedName.parseName(axiomName);}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Choice(ParserAssembler parserAssembler) throws ParseException
  {
    Token choiceToken;
    choiceToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.createAxiom(qualifiedChoiceName);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(qualifiedChoiceName.getScope(), qualifiedChoiceName.getName());
    Template template = parserAssembler.createTemplate(qualifiedTemplateName, true);
    template.setChoice(true);
    {if (true) return qualifiedChoiceName;}
    throw new Error("Missing return statement in function");
  }

  final public void TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
      parserAssembler.addAxiomTermName(qualifiedAxiomName, nameToken.image);
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Fact(qualifiedAxiomName, parserAssembler);
    label_17:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, parserAssembler);
    }
      parserAssembler.saveAxiom(qualifiedAxiomName);
  }

  final public void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Operand operand;
    String name = parserAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.addAxiom(qualifiedAxiomName, new Parameter(Term.ANONYMOUS, new Null()));
    jj_consume_token(LBRACE);
    operand = ChoiceExpression(name, parserAssembler);
    label_18:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, parserAssembler);
    }
    jj_consume_token(RBRACE);
       parserAssembler.saveAxiom(qualifiedAxiomName);
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.addTemplate(qualifiedTemplateName, operand);
  }

  final public Operand ChoiceExpression(String name, ParserAssembler parserAssembler) throws ParseException
  {
    Operand operand;
    QualifiedName qname = parserAssembler.getContextName(name);
    operand = Expression(parserAssembler);
      if (operand instanceof Evaluator)
          {if (true) return new Evaluator(qname, operand, "&&" );}
      if (operand instanceof StringOperand)
          {if (true) return new RegExOperand(qname, operand, 0, null);}
      {if (true) return new MatchOperand(qname, operand);}
    throw new Error("Missing return statement in function");
  }

  final public void ResourceDeclaration(QueryProgram queryProgram) throws ParseException
  {
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(RESOURCE);
    nameToken = jj_consume_token(STRING_LITERAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    queryProgram.openResource(getText(nameToken), properties);
  }

  final public QualifiedName ResourceBinding(int kind, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken = null;
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case STRING_LITERAL:
      nameToken = jj_consume_token(STRING_LITERAL);
      break;
    case RESOURCE:
      jj_consume_token(RESOURCE);
      break;
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    QualifiedName qualifiedBindingName =
        kind == QueryParserConstants.TEMPLATE ?
        new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName()) :
        qualifiedAxiomName;
    AxiomProvider axiomProvider = (nameToken != null) ?
        parserAssembler.bindResource(QualifiedName.parseName(getText(nameToken)), qualifiedBindingName) :
        parserAssembler.bindResource(qualifiedBindingName);
    {if (true) return qualifiedBindingName;}
    throw new Error("Missing return statement in function");
  }

  final public void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(COLON);
    jj_consume_token(PARAMETER);
    parserAssembler.setParameter(qualifiedAxiomName);
  }

  final public void Fact(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Parameter param = null;
  Token lit = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param = LiteralTerm();
    parserAssembler.addAxiom(qualifiedAxiomName, param);
      break;
    case NUMBER_LITERAL:
      lit = jj_consume_token(NUMBER_LITERAL);
    parserAssembler.addAxiom(qualifiedAxiomName, new NumberTerm(getText(lit), parserAssembler.getScopeLocale()));
      break;
    case NAN:
      jj_consume_token(NAN);
    parserAssembler.addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String Name() throws ParseException
  {
  String name;
  Token partToken;
    partToken = jj_consume_token(IDENTIFIER);
    name = partToken.image;
    label_19:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_19;
      }
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      name += ("." + partToken.image);
    }
    {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec) throws ParseException
  {
  String name1;
  String name2 = null;
    name1 = Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case COLON:
      jj_consume_token(COLON);
      name2 = Name();
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    {if (true) return keyname;}
    throw new Error("Missing return statement in function");
  }

  final public Operand Expression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
    param = ConditionalOrExpression(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      assignOperand = Expression(parserAssembler);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return new Evaluator(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ConditionalAndExpression(parserAssembler);
    label_20:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[66] = jj_gen;
        break label_20;
      }
      op = jj_consume_token(SC_OR);
      params[1] = ConditionalAndExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalAndExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = InclusiveOrExpression(parserAssembler);
    label_21:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[67] = jj_gen;
        break label_21;
      }
      op = jj_consume_token(SC_AND);
      params[1] = InclusiveOrExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand InclusiveOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ExclusiveOrExpression(parserAssembler);
    label_22:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_22;
      }
      op = jj_consume_token(BIT_OR);
      params[1] = ExclusiveOrExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ExclusiveOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AndExpression(parserAssembler);
    label_23:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case XOR:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_23;
      }
      op = jj_consume_token(XOR);
      params[1] = AndExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AndExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = EqualityExpression(parserAssembler);
    label_24:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_24;
      }
      op = jj_consume_token(BIT_AND);
      params[1] = EqualityExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand EqualityExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = RelationalExpression(parserAssembler);
    label_25:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_25;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = RelationalExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand RelationalExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AdditiveExpression(parserAssembler);
    label_26:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case GT:
      case LT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_26;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = AdditiveExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AdditiveExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = MultiplicativeExpression(parserAssembler);
    label_27:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_27;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = MultiplicativeExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand MultiplicativeExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = UnaryExpression(parserAssembler);
    label_28:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[77] = jj_gen;
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = UnaryExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case PLUS:
    case MINUS:
    case 81:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        jj_consume_token(PLUS);
    plus = true;
        break;
      case MINUS:
        jj_consume_token(MINUS);
    minus = true;
        break;
      case 81:
        jj_consume_token(81);
    tilde = true;
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      param = UnaryExpression(parserAssembler);
    if (plus)
      {if (true) return new Evaluator("+", param);}
    else if (minus)
      {if (true) return new Evaluator("-", param);}
    else if (tilde)
      {if (true) return new Evaluator("~", param);}
    {if (true) return param;}
      break;
    case INCR:
      param = PreIncrementExpression(parserAssembler);
    {if (true) return param;}
      break;
    case DECR:
      param = PreDecrementExpression(parserAssembler);
    {if (true) return param;}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
      param = UnaryExpressionNotPlusMinus(parserAssembler);
    {if (true) return param;}
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PreIncrementExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(INCR);
    param = PrimaryExpression(parserAssembler);
    {if (true) return new Evaluator("++", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PreDecrementExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(DECR);
    param = PrimaryExpression(parserAssembler);
    {if (true) return new Evaluator("--", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpressionNotPlusMinus(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BANG:
      jj_consume_token(BANG);
      param = UnaryExpression(parserAssembler);
    {if (true) return new Evaluator("!", param);}
      break;
    case SCOPE:
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
      param = PostfixExpression(parserAssembler);
    {if (true) return param;}
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PostfixExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  boolean incr = false;
  boolean decr = false;
    param = PrimaryExpression(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INCR:
        jj_consume_token(INCR);
    incr = true;
        break;
      case DECR:
        jj_consume_token(DECR);
    decr = true;
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
    if (incr)
       {if (true) return new Evaluator(param, "++");}
    else if (decr)
       {if (true) return new Evaluator(param, "--");}
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public Operand PrimaryExpression(ParserAssembler parserAssembler) throws ParseException
  {
  String name = null;
  QualifiedName qname;
  Token literal = null;
  Operand param1 = null;
  Operand operand;
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal();
    {if (true) return param1;}
      break;
    case NUMBER_LITERAL:
      literal = jj_consume_token(NUMBER_LITERAL);
    NumberTerm numberTerm = new NumberTerm(getText(literal), parserAssembler.getScopeLocale());
    Variable var = new Variable(QualifiedName.ANONYMOUS);
    var.assign(numberTerm);
    {if (true) return var;}
      break;
    case IDENTIFIER:
      name = Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
      case LBRACKET:
        param1 = NamedExpression(name, parserAssembler);
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
    if (param1 == null)
        {if (true) return operandMap.addOperand(name, null);}
    {if (true) return param1;}
      break;
    case SCOPE:
      jj_consume_token(SCOPE);
      param1 = IndexExpression(parserAssembler);
    {if (true) return parserAssembler.setListVariable("scope", param1, null);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      param1 = Expression(parserAssembler);
      jj_consume_token(RPAREN);
    {if (true) return param1;}
      break;
    case LENGTH:
      jj_consume_token(LENGTH);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    operand = parserAssembler.findOperandByName(name);
    if (operand != null)
        {if (true) return new ListLength(qname, operand);}
    else
        {if (true) return new ListLength(qname, parserAssembler.getItemList(name));}
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        {if (true) throw new ParseException("Variable \u005c"" + name + "\u005c" not found");}
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    {if (true) return formatter;}
      break;
    case FACT:
      jj_consume_token(FACT);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    Operand factOperand = parserAssembler.findOperandByName(name);
    if (factOperand != null)
        {if (true) return new FactOperand(factOperand);}
    else
        {if (true) throw new ParseException("Operand " + name + " not found");}
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand NamedExpression(String name, ParserAssembler parserAssembler) throws ParseException
  {
  Operand param1 = null;
  Operand param2 = null;
  List<OperandParam> operandParamList = null;
  QualifiedName qname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      param1 = IndexExpression(parserAssembler);
      if (jj_2_3(2)) 
      {
        param2 = IndexExpression(parserAssembler);
      } else 
      {
        ;
      }
    {if (true) return parserAssembler.newListVariableInstance(name, param1, param2);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case SCOPE:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 81:
        operandParamList = ArgumentList(parserAssembler, true);
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    {if (true) return parserAssembler.getCallOperand(qname, operandParamList);}
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand IndexExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(LBRACKET);
    param = Expression(parserAssembler);
    jj_consume_token(RBRACKET);
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> ArgumentList(ParserAssembler parserAssembler, boolean nameRequired) throws ParseException
  {
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  OperandParam operandParam;
    operandParam = Argument(parserAssembler, nameRequired);
    operandParamList.add(operandParam);
    label_29:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_29;
      }
      jj_consume_token(COMMA);
      operandParam = Argument(parserAssembler, nameRequired);
      operandParamList.add(operandParam);
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public OperandParam Argument(ParserAssembler parserAssembler, boolean nameRequired) throws ParseException
  {
    Token nameToken = null;
    VariableType varType = null;
    Operand operand = null;
    Operand expression;
    OperandMap operandMap = parserAssembler.getOperandMap();
    if (jj_2_4(2)) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
        varType = Type(operandMap);
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      nameToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(ASSIGN);
    } else 
    {
      ;
    }
    expression = Expression(parserAssembler);
     String name = nameToken == null ? Term.ANONYMOUS : nameToken.image;
     if (nameRequired && name.isEmpty())
         name = expression.getName();
     if ((nameToken == null) ||(varType == null))
         {if (true) return new OperandParam(name, expression);}
     boolean isLiteral = !expression.isEmpty();
     if (varType != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     operand = varType.getInstance(parserAssembler, name);
     {if (true) return new OperandParam(name, operand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand Literal() throws ParseException
  {
  Token lit;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    Long litValue = Long.decode(lit.image);
    {if (true) return new IntegerOperand(QualifiedName.ANONYMOUS, litValue);}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    {if (true) return new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    {if (true) return new StringOperand(QualifiedName.ANONYMOUS, getText(lit));}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral();
    {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, flag);}
      break;
    case UNKNOWN:
      UnknownLiteral();
    {if (true) return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm() throws ParseException
  {
  Token lit;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    {if (true) return new IntegerTerm(lit.image);}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    {if (true) return new DoubleTerm(lit.image);}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    {if (true) return new StringTerm(getText(lit));}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral();
    {if (true) return new BooleanTerm(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral();
    {if (true) return new Parameter(Term.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List<Parameter> LiteralList() throws ParseException
  {
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
    parameter = LiteralTerm();
    literalList.add(parameter);
    label_30:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_30;
      }
      jj_consume_token(COMMA);
      parameter = LiteralTerm();
      literalList.add(parameter);
    }
    {if (true) return literalList;}
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral() throws ParseException
  {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TRUE:
      jj_consume_token(TRUE);
    {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
    {if (true) return false;}
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral() throws ParseException
  {
    jj_consume_token(UNKNOWN);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) return true;
    }
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(CURRENCY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(DECIMAL)) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(37)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(PARAMETER)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(FACT)) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    }
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[94];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static 
  {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
  }
  private static void jj_la1_init_0() 
  {
    jj_la1_0 = new int[] { 0x400000,0x6a7dfc0,0x6a7dfc0,0x6a75fc0,0x6a75fc0,0x0,0x0,0x0,0x0,0x6a65fc0,0x2040000,0x0,0x0,0x0,0x0,0x0,0xa007c0,0x0,0x95b89fc0,0x0,0x95b89fc0,0x0,0x0,0xa007c0,0x0,0x0,0xa007c0,0x0,0x0,0x0,0x91189000,0x0,0x0,0x91b887c0,0x2000,0x2000,0x0,0x0,0x0,0x95b897c0,0x0,0x800,0x91b887c0,0x91b887c0,0x0,0x91188000,0x0,0x91b887c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x90000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x91188000,0x91188000,0x0,0x0,0x0,0x91188000,0x91b887c0,0x0,0x0,0xa007c0,0x90000000,0x90000000,0x0,0x0, };
  }
  private static void jj_la1_init_1() 
  {
    jj_la1_1 = new int[] { 0x0,0x80,0x80,0x80,0x80,0x100,0x0,0x8000,0x100,0x80,0x0,0x80000,0x200000,0x100,0x84,0x100,0x0,0x8000,0xf03005bd,0x8000,0xf03005bd,0x100,0x8000,0x0,0x1000,0x20000,0x0,0x1000,0x0,0x220000,0xf01001bd,0x84,0x400,0xf01001bd,0x220500,0x220500,0x200000,0x200000,0x400,0xf03005bd,0x8000,0x0,0xf01001bd,0xf01001bd,0x8000,0xf01005bd,0x400,0xf01001bd,0x8000,0x20100,0x8000,0x80,0x400,0x400,0x200400,0x8000,0x400,0x8000,0x8000,0x100,0x4,0x7d,0x10000,0x200000,0x20000,0x20000,0x4000000,0x8000000,0x0,0x0,0x0,0x2400000,0x2400000,0x18c0000,0x18c0000,0xc0000000,0xc0000000,0x0,0x0,0xc0000000,0xf01001bd,0x1001bd,0x30000000,0x30000000,0x1100,0x1bd,0xf01001bd,0x1100,0x8000,0x0,0x3c,0x3c,0x8000,0x18, };
  }
  private static void jj_la1_init_2() 
  {
    jj_la1_2 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38000,0x0,0x38000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc0,0xbfc0,0x20000,0x0,0x0,0x20000,0xbfc0,0xbfc0,0x8000,0x8000,0x0,0x28000,0x0,0x0,0x20000,0x20000,0x0,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc0,0x3fc0,0x0,0x0,0x8,0x10,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x23,0x23,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0, };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) 
  {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) 
   {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) 
  {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) 
  {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException 
  {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) 
    {
      jj_gen++;
      if (++jj_gc > 100) 
      {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) 
        {
          JJCalls c = jj_2_rtns[i];
          while (c != null) 
          {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) 
  {
    if (jj_scanpos == jj_lastpos) 
    {
      jj_la--;
      if (jj_scanpos.next == null) 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else 
    {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) 
    {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() 
  {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) 
  {
    Token t = token;
    for (int i = 0; i < index; i++) 
    {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() 
  {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) 
  {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) 
    {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) 
    {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) 
    {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) 
      {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) 
        {
          for (int i = 0; i < jj_expentry.length; i++) 
          {
            if (oldentry[i] != jj_expentry[i]) 
            {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() 
  {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[82];
    if (jj_kind >= 0) 
    {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 94; i++) 
    {
      if (jj_la1[i] == jj_gen) 
      {
        for (int j = 0; j < 32; j++) 
        {
          if ((jj_la1_0[i] & (1<<j)) != 0) 
          {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) 
          {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) 
          {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 82; i++) 
    {
      if (la1tokens[i]) 
      {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) 
    {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() 
  {
  }

  /** Disable tracing. */
  final public void disable_tracing() 
  {
  }

  private void jj_rescan_token() 
  {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) 
    {
    try 
      {
      JJCalls p = jj_2_rtns[i];
      do 
        {
        if (p.gen > jj_gen) 
          {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) 
            {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) 
  {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) 
    {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls 
  {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
