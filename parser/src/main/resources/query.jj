options 
{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(QueryParser)
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.LoopEvaluator;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.NumberTerm;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.helper.Null;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;
import au.com.cybersearch2.classy_logic.helper.OperandParam;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser 
{
  
  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    parser.input(queryProgram);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    input(queryProgram);
    return queryProgram;
   }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, QueryProgram queryProgram) throws ParseException
  {
     if (resourceName.length() < 3)
        throw new ParseException("Include resourceName \"\" is invalid");
     ParserResources parserResources = new ParserResources(queryProgram);
     try
     {
         parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
     }
     catch (IOException e)
     {
         throw new ParseException(e.getMessage());
     }
  } 
 
  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  } 
}

PARSER_END(QueryParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN :
{
  < INTEGER: "integer" >
| < DOUBLE: "double" >
| < DECIMAL: "decimal" >
| < BOOLEAN: "boolean" >
| < STRING: "string" >
| < TEMPLATE: "template" >
| < AXIOM: "axiom" >
| < REGEX: "regex" >
| < INCLUDE: "include" >
| < SCOPE: "scope" >
| < QUERY: "query" >
| < CALC: "calc" >
| < LIST: "list" >
| < FACT: "fact" >
| < LENGTH: "length" >
| < TERM: "term" >
| < RESOURCE: "resource" >
| < CURRENCY: "currency" >
| < FORMAT: "format" >
| < LOCAL: "local" >
| < CHOICE: "choice" >
| < PARAMETER: "parameter" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | "0"
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < NUMBER_LITERAL:
       "'" 
       ((["0"-"9"])+ ([",","."]))+ (["0"-"9"])+
       "'"
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (     
        (~["\"","\\","\n","\r"])
        | 
        ("\\" ( ["n","t","b","r","f","\\","'","\"","."] ) )
      )*
      "\""
  >
|
  < TRUE: "true" >
|
  < FALSE: "false" >
|
   <UNKNOWN: "unknown" >
|
   <NAN: "NaN" >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
}

/** Root production. */
void input(QueryProgram queryProgram) :
{
}
{
  ( ResourceDeclaration(queryProgram) ";" )*
  ( Statement(queryProgram, queryProgram.getGlobalScope()) | QueryChain(queryProgram.getGlobalScope()) | ScopeDeclaration(queryProgram) )+
  <EOF>
}

void ScopeDeclaration(QueryProgram queryProgram) :
{
  Scope scope;
}
{
  <SCOPE> scope=Scope(queryProgram) 
  "{" 
     ( Statement(queryProgram, scope) | QueryChain(scope) )*
  "}" 
  {
  }
}

Scope Scope(QueryProgram queryProgram) :
{
  Token scopeToken;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
   scopeToken = <IDENTIFIER>  [ "(" InitialiserList(properties) ")" ]
   {
      return queryProgram.scopeInstance(scopeToken.image , properties);
   }
}

void QueryChain(Scope scope) :
{
    QuerySpec querySpec;
}
{  
  <QUERY> querySpec=Query() querySpec=QueryDeclaration(querySpec, scope) ( ">>" QueryDeclaration(querySpec.chain(), scope) )* ";"
  {
      scope.addQuerySpec(querySpec);
  }  
}

QuerySpec QueryDeclaration(QuerySpec querySpec, Scope scope) :
{
  KeyName firstKeyname;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
   "(" 
      ( 
        firstKeyname = KeyName(querySpec)
      )
      (
        "," 
        (
          KeyName(querySpec)
        )
        {
            ++keynameCount;
        }
      )* ")" ( "(" InitialiserList(properties) ")" )?
    {
        return scope.buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);
    }
}

QuerySpec Query() :
{
    Token queryToken;
}
{
  queryToken=<IDENTIFIER>
  {
    return new QuerySpec(queryToken.image);
  }    
}

void Statement(QueryProgram queryProgram, Scope scope):
{
  Operand var;
  ParserAssembler parserAssembler = scope.getParserAssembler();
}
{
    var=VariableDeclaration(parserAssembler) ";" 
    {
      parserAssembler.getOperandMap().addOperand(var);
    }
  | TemplateDeclaration(parserAssembler) ";" 
  | CalculatorTemplate(parserAssembler) ";"   
  | AxiomDeclaration(parserAssembler) ";" 
  | ChoiceDeclaration(parserAssembler) ";"
  | ListDeclaration(parserAssembler) ";"
  | Include(queryProgram) ";"
}

void Include(QueryProgram queryProgram) :
{
  Token includeToken = null;
}
{
  <INCLUDE> includeToken=<STRING_LITERAL>
  {
    includeResource(includeToken.image, queryProgram);
  }
}


void ListDeclaration(ParserAssembler parserAssembler) :
{
    Token keywordToken;
    Token nameToken;
    VariableType varType = null;
    QualifiedName qualifiedBindingName = null;
    QualifiedName qualifiedAxiomName = null;
}
{
  ( keywordToken=<LIST> | keywordToken=<LOCAL> ) 
  [ "<" varType=Type(parserAssembler.getOperandMap()) ">" ] 
  nameToken=<IDENTIFIER> 
  [ "(" qualifiedAxiomName=Axiom(parserAssembler)  ( qualifiedBindingName = ResourceBinding(QueryParserConstants.TEMPLATE, qualifiedAxiomName, parserAssembler) )? ")" ]
  {
    String listName = nameToken.image;
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    boolean isTermList = (varType != null) && varType.getOperandType() == OperandType.TERM;
    if ((varType == null) && (qualifiedAxiomName == null))
        throw new ParseException("Invalid declaration for list \"" + listName + "\". Missing type or axiom name.");
    if ((varType != null) && isLocal)
        throw new ParseException("Invalid declaration for local \"" + listName + "\". Type in declaration not allowed.");
    if ((qualifiedBindingName != null) && !isTermList)
        throw new ParseException("Invalid declaration for local \"" + listName + "\". Only Term Type list can be bound to a resource");
    if (qualifiedBindingName != null)
        qualifiedAxiomName = qualifiedBindingName;
    if (varType == null)
        varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
        varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getOperandMap().addItemList(itemList.getQualifiedName(), itemList);
  }
}

VariableType Type(OperandMap operandMap) :
{
    Token qualifierLit = null;
    String qualifierId = null;
}
{
    <INTEGER>
    { 
      return new VariableType(OperandType.INTEGER); 
    }
|   <BOOLEAN>
    { 
      return new VariableType(OperandType.BOOLEAN); 
    }
|   <DOUBLE>
    { 
      return new VariableType(OperandType.DOUBLE); 
    }
|   <STRING>
    { 
      return new VariableType(OperandType.STRING); 
    }
|   <DECIMAL>
    { 
      return new VariableType(OperandType.DECIMAL); 
    }
|   <TERM>
    { 
      return new VariableType(OperandType.TERM); 
    }
|   <CURRENCY> ( "(" ( qualifierLit=<STRING_LITERAL> | qualifierId=Name() ) ")" )?
    { 
      VariableType varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, operandMap.addOperand(qualifierId, null));
      return varType; 
    }

}

void TemplateDeclaration(ParserAssembler parserAssembler) :
{
    Template template;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
}
{
    <TEMPLATE> template=Template(parserAssembler, false) "(" 
      ( 
        TemplateExpression(template, parserAssembler)
      )
      (
        "," 
        (
          TemplateExpression(template, parserAssembler)
        )
      )* ")" 
    {
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
    }
}

Template Template(ParserAssembler parserAssembler, boolean isCalculator) :
{
    Token templateToken;
}
{
  templateToken=<IDENTIFIER>
  { 
      QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), templateToken.image);
      parserAssembler.getOperandMap().setQualifiedContextname(qualifiedTemplateName);
      return parserAssembler.createTemplate(qualifiedTemplateName, isCalculator); 
  }
}

void CalculatorTemplate(ParserAssembler parserAssembler) :
{
    Template template;
    Map<String, Object> properties = new HashMap<String, Object>();
    int loopNumber = 0;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
}
{  
    <CALC> template=Template(parserAssembler, true) "(" 
      (  
        ( CalculatorExpression(loopNumber, template, template.getName(), parserAssembler) |
          CalculatorQuery(template, parserAssembler))
      )
      (
        "," 
        (  
          ( CalculatorExpression(loopNumber, template, template.getName(), parserAssembler) |
            CalculatorQuery(template, parserAssembler))
        )
      )* ")" [ "(" InitialiserList(properties) ")" ]
    {
      if (properties.size() > 0)
          template.addProperties(properties);
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
    }
}

void InitialiserList(Map<String, Object> properties) :
{
}
{
    InitialiserDeclaration(properties)
    ("," InitialiserDeclaration(properties) )* 
}

void InitialiserDeclaration(Map<String, Object> properties) :
{
    String name;
    Parameter param;
}
{
  name=Name() "=" param=LiteralTerm()
  {
     properties.put(name, param.getValue());
  }
}

Operand VariableDeclaration(ParserAssembler parserAssembler) :
{
    Token nameToken;
    VariableType varType = null;
    Operand index = null;
    Operand expression = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  ( varType=Type(operandMap) )? nameToken=<IDENTIFIER> ( index=IndexExpression(parserAssembler) )? ( "=" expression=Expression(parserAssembler) )?
  {
     String name = nameToken.image;
     if (index !=null)
         return parserAssembler.setListVariable(name, index, expression);
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     boolean isLiteral = (expression != null) &&
                          !expression.isEmpty() && !(expression instanceof Evaluator);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     return operand;
  }
}


void TemplateExpression(Template template, ParserAssembler parserAssembler) :
{
    String name;
    VariableType varType = null;
    Operand index = null;
    Operand var = null;
    Token scToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Operand expression = null;
    Group group = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
    List<Parameter> literalList = null;
    List<OperandParam> axiomList = null;
    QualifiedName qname = null;
    List<OperandParam> operandParamList = null;
}
{
   ( varType=Type(operandMap) )? name=Name() 
   {
       qname = parserAssembler.getContextName(name);
   }
   ( index=IndexExpression(parserAssembler) )? 
   (
    (     
      ( 
        scToken=":" | scToken="?" | equalsToken="=" |
        ( assignToken=<PLUSASSIGN>
        | assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN>)
      ) 
      (
        <AXIOM> axiomList=AxiomList(qname, parserAssembler) 
        {
          VariableType axiomListVarType = new VariableType(OperandType.LIST);
          axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
          expression = axiomListVarType.getInstance(parserAssembler, qname);
        } 
        |
        expression=Expression(parserAssembler) 
      )
     )
     |
        <REGEX> "(" ( regexLit=<STRING_LITERAL> | regexId=<IDENTIFIER> ) ( group=GroupDeclaration(template, name, parserAssembler) )? ")"
     |
        <LBRACE> literalList = LiteralList() <RBRACE> 
     |
     "(" ( operandParamList = ArgumentList(parserAssembler, true) )? ")"
	 {
	     template.addTerm(parserAssembler.getCallOperand(qname, operandParamList));
	 }
    )?
  {
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     Operand assignExpression = (assignToken != null) ? expression : null;
     Operand regexOp = null;
     if (regexLit != null)
         regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
     else if (regexId != null)
         regexOp = operandMap.addOperand(regexId.image, null);
     if (assignToken != null)
         expression = null;
     boolean isLiteral = (expression != null) && !expression.isEmpty() && (equalsToken != null);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     if (index !=null)
         var = parserAssembler.setListVariable(name, index, null);
     else if (regexOp != null)
         var = new RegExOperand(qname, regexOp, 0, group);
     else if (scToken != null) 
         var = new Evaluator(qname, expression, (scToken.image == "?" ? "&&" : "||"));
     else if (literalList != null)
         var = new LiteralListOperand(qname, literalList);
     else if (!operandMap.hasOperand(name))
         var = varType.getInstance(parserAssembler, name);
     else
         var = operandMap.addOperand(name, expression);
     if ((index == null) && (!operandMap.hasOperand(name)))
         operandMap.addOperand(var);
     if (assignToken != null) 
         var = new Evaluator(qname, var, assignToken.image, assignExpression);
     if ((index !=null) && (equalsToken != null) && !isLiteral) 
         var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
     template.addTerm(var);
  }
}

void CalculatorExpression(int loop_number, Template template, String templateName, ParserAssembler parserAssembler) :
{
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
}
{
  <AXIOM> qualifiedAxiomName=Axiom(parserAssembler) expression = AxiomVariable(qualifiedAxiomName, parserAssembler) 
  {
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
  }
  |
  TemplateExpression(template, parserAssembler)
  |
  ( scToken=":" | scToken="?" )? expression=Expression(parserAssembler) 
    ( innerLoop=InnerCalculator(loop_number + 1, templateName, parserAssembler, scToken != null) )?  
  {
    if (scToken != null)
      expression = new Evaluator(expression, (scToken.image == "?" ? "&&" : "||"), innerLoop);
    template.addTerm(expression);
  }
  |
  innerLoop=InnerCalculator(loop_number + 1, templateName, parserAssembler, false)
  {
    template.addTerm(innerLoop);
  }
  |
  qualifiedAxiomName = ChoiceDeclaration(parserAssembler)
  {
    qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplate(qualifiedTemplateName);
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    QualifiedName qname = QualifiedName.parseName(choiceTemplate.getName(), contextName); 
 	Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
  }
}

Operand InnerCalculator(int loop_number, String templateName, ParserAssembler parserAssembler, boolean runOnce) :
{
  String loopName = templateName + loop_number;
  QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), templateName);
  Template template = parserAssembler.chainTemplate(qualifiedTemplateName, loopName);
}
{
  "{" 
    CalculatorExpression(loop_number, template, templateName, parserAssembler)
    ("," 
        CalculatorExpression(loop_number, template, templateName, parserAssembler)
    )* 
  "}"
  {
    return new LoopEvaluator(template, runOnce);
  }
}

void CalculatorQuery(Template template, ParserAssembler parserAssembler) :
{
  String queryName;
  List<OperandParam> operandParamList = null;
  Template innerTemplate = null;
}
{
  ( innerTemplate=InnerTemplateDeclaration(template.getQualifiedName(), parserAssembler) )? "<<" queryName=Name()  
   "(" ( operandParamList = ArgumentList(parserAssembler, false) )? ")"
  {
    QualifiedName qname = QualifiedName.parseName(queryName);
    Operand queryOperand = parserAssembler.getQueryOperand(qname, operandParamList, innerTemplate);
    template.addTerm(queryOperand);
    if (innerTemplate != null)
        template.setNext(innerTemplate);
  }
}

Operand CalculatorFunction(ParserAssembler parserAssembler) :
{
    String fnName;
    List<OperandParam> operandParamList = null;
}
{
  fnName=Name() "(" ( operandParamList = ArgumentList(parserAssembler, true) )? ")"
  {
    return parserAssembler.getCallOperand(parserAssembler.getContextName(fnName), operandParamList);
  }
}

Template InnerTemplateDeclaration(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) :
{
    Template template;
}
{
    <TEMPLATE> template=InnerTemplate(ownerQualifiedName, parserAssembler) "(" 
      ( 
        TemplateExpression(template, parserAssembler)
      )
      (
        "," 
        (
          TemplateExpression(template, parserAssembler)
        )
      )* ")" 
    {
        return template;
    }
}

Template InnerTemplate(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) :
{
    Token templateToken;
}
{
  templateToken=<IDENTIFIER>
  { 
    QualifiedName qualifiedTemplateName = new QualifiedName(templateToken.image, ownerQualifiedName);
    Template innerTemplate = parserAssembler.createTemplate(qualifiedTemplateName, false);
    innerTemplate.setInnerTemplate(true);
    innerTemplate.setKey(templateToken.image);
    return innerTemplate; 
  }
}


Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
    Operand expression = null;
    List<OperandParam> axiomList = null;
}
{
  "="
  ( 
     expression=Expression(parserAssembler) 
  | 
     axiomList=AxiomList(qualifiedAxiomName, parserAssembler) 
  )
  {
     VariableType varType = new VariableType(axiomList == null ? OperandType.AXIOM : OperandType.LIST);
     if (expression != null)
         varType.setProperty(VariableType.EXPRESSION, expression);
     else
         varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     if (expression != null)
         parserAssembler.setParameter(operand.getQualifiedName());
     return operand;
  }
} 

List<OperandParam> AxiomList(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  String axiomName = qualifiedAxiomName.getName();
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  Operand operand;
}
{
  operand = AxiomInitializer(axiomName, axiomName, parserAssembler)
  {
    operandParamList.add(new OperandParam(axiomName, operand));
  }
  ( 
    operand = AxiomInitializer(axiomName, axiomName, parserAssembler)
    {
      operandParamList.add(new OperandParam(axiomName, operand));
    }
  )*
  {
    return operandParamList;
  }
}

Operand AxiomInitializer(String listName, String axiomName, ParserAssembler parserAssembler) :
{
    List<OperandParam> initializeList = null;
}
{
  <LBRACE> ( initializeList = ArgumentList(parserAssembler, true) )? <RBRACE>
  {
     VariableType varType = new VariableType(OperandType.TERM);
     varType.setProperty(VariableType.AXIOM_KEY, axiomName);
     if (initializeList != null)
        varType.setProperty(VariableType.PARAMS, initializeList);
     Operand operand = varType.getInstance(parserAssembler, listName);
     return operand;
  }
}

Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) :
{
  Group group = new Group(name);
}
{
  "{" Group(group, template, name, parserAssembler) ("," Group(group, template, name, parserAssembler) )* "}"
  {
    return group;
  }
}

 
void Group(Group group, Template template, String name, ParserAssembler parserAssembler) :
{
  Token groupToken;
}
{
  groupToken=<IDENTIFIER> 
  {
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null);   
    template.addTerm(var);
    group.addGroup(var);
  }
}

void AxiomDeclaration(ParserAssembler parserAssembler) :
{
    QualifiedName qualifiedAxiomName;
    Operand operand = null;
}
{
  <AXIOM> qualifiedAxiomName=Axiom(parserAssembler) 
          ( AxiomSpecification(qualifiedAxiomName, parserAssembler) |
            operand=AxiomVariable(qualifiedAxiomName, parserAssembler) )
    {
        if (operand != null)
            parserAssembler.getOperandMap().addOperand(operand);
    }
} 


void AxiomSpecification(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
    parserAssembler.createAxiom(qualifiedAxiomName);
}
{
  "(" ( TermName(qualifiedAxiomName, parserAssembler) ("," TermName(qualifiedAxiomName, parserAssembler) )* )?  ")"  
  (
    LOOKAHEAD(2) ResourceBinding(QueryParserConstants.AXIOM, qualifiedAxiomName, parserAssembler)
    |
    LOOKAHEAD(2) ParameterDeclaration(qualifiedAxiomName, parserAssembler) 
    |
    ( <LBRACE> AxiomItem(qualifiedAxiomName, parserAssembler) <RBRACE> )+
  )?
}

QualifiedName ChoiceDeclaration(ParserAssembler parserAssembler) :
{
    QualifiedName qualifiedAxiomName;
    int selection = 0;
    OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  <CHOICE> qualifiedAxiomName=Choice(parserAssembler) "(" TermName(qualifiedAxiomName, parserAssembler) ("," TermName(qualifiedAxiomName, parserAssembler) )*  ")" 
                                                        ( ChoiceItem(selection, qualifiedAxiomName, parserAssembler) )+ 
  {
      QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
      if (contextName.getTemplate().isEmpty())
          return qualifiedAxiomName;
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
      List<String> termNameList = parserAssembler.getAxiomTermNameList(qualifiedAxiomName);
      for (String termName: termNameList)
          parserAssembler.getOperandMap().addOperand(termName, null);
      operandMap.setQualifiedContextname(contextName);
      return qualifiedAxiomName;
  }
} 

QualifiedName Axiom(ParserAssembler parserAssembler) :
{
    String axiomName;
}
{
  axiomName=Name()
  { 
    return axiomName.indexOf(".") == -1 ? 
        parserAssembler.getContextName(axiomName) :
        QualifiedName.parseName(axiomName); 
  }
}

QualifiedName Choice(ParserAssembler parserAssembler) :
{
    Token choiceToken;
}
{
  choiceToken=<IDENTIFIER>
  { 
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.createAxiom(qualifiedChoiceName);
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(qualifiedChoiceName.getScope(), qualifiedChoiceName.getName());
    Template template = parserAssembler.createTemplate(qualifiedTemplateName, true);
    template.setChoice(true);
    return qualifiedChoiceName;
  }
}
 
void TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
    Token nameToken;
}
{
    nameToken=<IDENTIFIER>
    {
      parserAssembler.addAxiomTermName(qualifiedAxiomName, nameToken.image);
    }
}

void AxiomItem(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
}
{
    Fact(qualifiedAxiomName, parserAssembler) ("," Fact(qualifiedAxiomName, parserAssembler) )*  
    {
      parserAssembler.saveAxiom(qualifiedAxiomName);
    }
}

void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
    Operand operand;
    String name = parserAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.addAxiom(qualifiedAxiomName, new Parameter(Term.ANONYMOUS, new Null()));
}
{
   <LBRACE> operand=ChoiceExpression(name, parserAssembler) ("," Fact(qualifiedAxiomName, parserAssembler) )* <RBRACE> 
    {
       parserAssembler.saveAxiom(qualifiedAxiomName);
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.addTemplate(qualifiedTemplateName, operand);
    }
}

Operand ChoiceExpression(String name, ParserAssembler parserAssembler) :
{
    Operand operand;
    QualifiedName qname = parserAssembler.getContextName(name);
}
{
    operand=Expression(parserAssembler)
    {
      if (operand instanceof Evaluator)
          return new Evaluator(qname, operand, "&&" ); 
      if (operand instanceof StringOperand)
          return new RegExOperand(qname, operand, 0, null);
      return new MatchOperand(qname, operand);
    }
}

void ResourceDeclaration(QueryProgram queryProgram) :
{
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
  <RESOURCE> nameToken=<STRING_LITERAL> ( "(" InitialiserList(properties) ")" )?
  {
    queryProgram.openResource(getText(nameToken), properties);
  }
}

QualifiedName ResourceBinding(int kind, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  Token nameToken = null;
}
{
  ":" ( nameToken=<STRING_LITERAL> | <RESOURCE> )
  {
    QualifiedName qualifiedBindingName = 
        kind == QueryParserConstants.TEMPLATE ?
        new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName()) :
        qualifiedAxiomName;
    AxiomProvider axiomProvider = (nameToken != null) ?
        parserAssembler.bindResource(QualifiedName.parseName(getText(nameToken)), qualifiedBindingName) :
        parserAssembler.bindResource(qualifiedBindingName);
    return qualifiedBindingName;
  }
}

void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
}
{
  ":" <PARAMETER>
  {
    parserAssembler.setParameter(qualifiedAxiomName);
  }
}

void Fact(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  Parameter param = null;
  Token lit = null;
}
{
  param=LiteralTerm()
  {
    parserAssembler.addAxiom(qualifiedAxiomName, param);
  }
  |
  lit=<NUMBER_LITERAL>
  {
    parserAssembler.addAxiom(qualifiedAxiomName, new NumberTerm(getText(lit), parserAssembler.getScopeLocale()));
  }
  |
  <NAN>
  {
    parserAssembler.addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
  }
}

String Name() :
{
  String name;
  Token partToken;
}
{
  partToken=<IDENTIFIER> 
  {
    name = partToken.image;
  }
  ( 
    "." 
    partToken=<IDENTIFIER>
    {
      name += ("." + partToken.image);
    } 
  )*
  {
    return name;
  }
}

KeyName KeyName(QuerySpec querySpec) :
{
  String name1;
  String name2 = null;
}
{
  name1=Name() (":" name2=Name() )?
  {
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    return keyname;
  }
}


Operand Expression(ParserAssembler parserAssembler) :
{
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
}
{
  param=ConditionalOrExpression(parserAssembler) 
    ( ( assignToken=<ASSIGN>
        | assignToken=<PLUSASSIGN>
        | assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN>
      )
      assignOperand=Expression(parserAssembler) )?
  {
    if (assignOperand == null)
      return param;
    return new Evaluator(param, assignToken.image, assignOperand);
  }
}

Operand ConditionalOrExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ConditionalAndExpression(parserAssembler)
  ( 
    op="||" 
    params[1]=ConditionalAndExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand ConditionalAndExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=InclusiveOrExpression(parserAssembler)
  ( 
    op="&&" 
    params[1]=InclusiveOrExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand InclusiveOrExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ExclusiveOrExpression(parserAssembler)
  ( 
    op="|" 
    params[1]=ExclusiveOrExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand ExclusiveOrExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AndExpression(parserAssembler)
  ( 
    op="^" 
    params[1]=AndExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AndExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=EqualityExpression(parserAssembler)
  ( 
    op="&" 
    params[1]=EqualityExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand EqualityExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=RelationalExpression(parserAssembler)
  ( 
    ( 
    op="==" 
    | 
    op="!=" 
    ) 
    params[1]=RelationalExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand RelationalExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AdditiveExpression(parserAssembler)
  ( 
    ( 
    op="<" 
    | 
    op=">" 
    |
    op="<=" 
    | 
    op=">=" 
    ) 
    params[1]=AdditiveExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AdditiveExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=MultiplicativeExpression(parserAssembler)
  ( 
    ( 
    op="+" 
    | 
    op="-" 
    ) 
    params[1]=MultiplicativeExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand MultiplicativeExpression(ParserAssembler parserAssembler) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=UnaryExpression(parserAssembler)
  ( 
    ( 
    op="*" 
    | 
    op="/" 
    | 
    op="%" 
    ) 
    params[1]=UnaryExpression(parserAssembler) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand UnaryExpression(ParserAssembler parserAssembler) :
{
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
}
{
  ( 
    "+"
  {
    plus = true;
  }
  | 
    "-"
  {
    minus = true;
  }
  |
    "~"
  {
    tilde = true;
  }
  ) 
  param=UnaryExpression(parserAssembler)
  {
    if (plus)
      return new Evaluator("+", param);
    else if (minus)
      return new Evaluator("-", param);
    else if (tilde)
      return new Evaluator("~", param);
    return param;
  }
  |
  param=PreIncrementExpression(parserAssembler)
  {
    return param;
  }
  |
  param=PreDecrementExpression(parserAssembler)
  {
    return param;
  }
  |
  param=UnaryExpressionNotPlusMinus(parserAssembler)
  {
    return param;
  }
}

Operand PreIncrementExpression(ParserAssembler parserAssembler) :
{
  Operand param;
}
{
  "++" param=PrimaryExpression(parserAssembler)
  {
    return new Evaluator("++", param);
  }
}

Operand PreDecrementExpression(ParserAssembler parserAssembler) :
{
  Operand param;
}
{
  "--" param=PrimaryExpression(parserAssembler)
  {
    return new Evaluator("--", param);
  }
}

Operand UnaryExpressionNotPlusMinus(ParserAssembler parserAssembler) :
{
  Operand param;
}
{
  "!" param=UnaryExpression(parserAssembler)
  {
    return new Evaluator("!", param);
  }
  |
  param=PostfixExpression(parserAssembler)  
  {
    return param;
  }
}

Operand PostfixExpression(ParserAssembler parserAssembler) :
{
  Operand param;
  boolean incr = false;
  boolean decr = false;
}
{
  param=PrimaryExpression(parserAssembler)
  [ 
    "++"
  {
    incr = true;
  }
  | 
    "--"
  {
    decr = true; 
  }
  ]
  {
    if (incr)
       return new Evaluator(param, "++");
    else if (decr)
       return new Evaluator(param, "--");
    return param;
  } 
}

Operand PrimaryExpression(ParserAssembler parserAssembler) :
{
  String name = null;
  QualifiedName qname;
  Token literal = null;
  Operand param1 = null;
  Operand operand;
  OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  param1=Literal()
  {
    return param1;
  }
  |
  literal=<NUMBER_LITERAL>
  {
    NumberTerm numberTerm = new NumberTerm(getText(literal), parserAssembler.getScopeLocale());
    Variable var = new Variable(QualifiedName.ANONYMOUS);
    var.assign(numberTerm);
    return var;
  }
  |
  name=Name() ( param1=NamedExpression(name, parserAssembler) )?
  {
    if (param1 == null)
        return operandMap.addOperand(name, null);
    return param1;
  }
  |
  <SCOPE> param1=IndexExpression(parserAssembler)
  {
    return parserAssembler.setListVariable("scope", param1, null);
  }
  |
  "(" ( param1 = Expression(parserAssembler) ) ")" 
  {
    return param1;
  }
  |
  <LENGTH> "("  name=Name() ")"
  {
    qname = parserAssembler.getContextName(name);
    operand = parserAssembler.findOperandByName(name);
    if (operand != null)
        return new ListLength(qname, operand);
    else 
        return new ListLength(qname, parserAssembler.getItemList(name));
  }
  |
  <FORMAT> "("  name=Name() ")"
  {
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        throw new ParseException("Variable \"" + name + "\" not found");
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    return formatter;
  }
  |
  <FACT> "("  name=Name() ")"
  {
    Operand factOperand = parserAssembler.findOperandByName(name);
    if (factOperand != null)
        return new FactOperand(factOperand);
    else 
        throw new ParseException("Operand " + name + " not found");
  }
}

Operand NamedExpression(String name, ParserAssembler parserAssembler) :
{
  Operand param1 = null;
  Operand param2 = null;
  List<OperandParam> operandParamList = null;
  QualifiedName qname;
}
{
  param1=IndexExpression(parserAssembler) ( LOOKAHEAD(2) param2=IndexExpression(parserAssembler) )?
  {
    return parserAssembler.newListVariableInstance(name, param1, param2);
  }
  |
  "(" ( operandParamList = ArgumentList(parserAssembler, true) )? ")"
  {
    qname = parserAssembler.getContextName(name);
    return parserAssembler.getCallOperand(qname, operandParamList);
  }
}

Operand IndexExpression(ParserAssembler parserAssembler) :
{
  Operand param;
}
{
  <LBRACKET> 
  (
    ( 
    param=Expression(parserAssembler)
    )
   )
  <RBRACKET> 
  {
    return param;
  }
}

List<OperandParam> ArgumentList(ParserAssembler parserAssembler, boolean nameRequired) :
{
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  OperandParam operandParam;
}
{
  operandParam = Argument(parserAssembler, nameRequired)
  {
    operandParamList.add(operandParam);
  }
  ( 
    "," 
    operandParam=Argument(parserAssembler, nameRequired) 
    {
      operandParamList.add(operandParam);
    }
  )*
  {
    return operandParamList;
  }
}

OperandParam Argument(ParserAssembler parserAssembler, boolean nameRequired) :
{
    Token nameToken = null;
    VariableType varType = null;
    Operand operand = null;
    Operand expression;
    OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  ( LOOKAHEAD(2) ( varType=Type(operandMap) )? nameToken=<IDENTIFIER> "=" )? expression=Expression(parserAssembler) 
  {
     String name = nameToken == null ? Term.ANONYMOUS : nameToken.image;
     if (nameRequired && name.isEmpty())
         name = expression.getName();
     if ((nameToken == null) ||(varType == null))
         return new OperandParam(name, expression);
     boolean isLiteral = !expression.isEmpty();
     if (varType != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     operand = varType.getInstance(parserAssembler, name);
     return new OperandParam(name, operand);
  }
}

Operand Literal() :
{
  Token lit;
  boolean flag;
}
{
  lit=<INTEGER_LITERAL>
  {
    Long litValue = Long.decode(lit.image);
    return new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
  }
  |
  lit=<FLOATING_POINT_LITERAL>
  {
    return new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
  }
  |
  lit=<STRING_LITERAL>
  {
    return new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
  }
  |
  flag=BooleanLiteral()
  {
    return new BooleanOperand(QualifiedName.ANONYMOUS, flag);
  }
  |
  UnknownLiteral()
  {
    return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());
  }
}

Parameter LiteralTerm() :
{
  Token lit;
  boolean flag;
}
{
  lit=<INTEGER_LITERAL>
  {
    return new IntegerTerm(lit.image);
  }
|
  lit=<FLOATING_POINT_LITERAL>
  {
    return new DoubleTerm(lit.image);
  }
|
  lit=<STRING_LITERAL>
  {
    return new StringTerm(getText(lit));
  }
|
  flag=BooleanLiteral()
  {
    return new BooleanTerm(flag);
  }
|
  UnknownLiteral()
  {
    return new Parameter(Term.ANONYMOUS, new Unknown());
  }
}

List<Parameter> LiteralList() :
{
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
}
{
  parameter=LiteralTerm()
  {
    literalList.add(parameter);
  }
  ( 
    "," 
    parameter = LiteralTerm() 
    {
      literalList.add(parameter);
    }
  )*
  {
    return literalList;
  }
}


boolean BooleanLiteral() :
{}
{
  <TRUE> 
  { 
    return true; 
  }
  |
  <FALSE> 
  { 
    return false; 
  }
}

void UnknownLiteral() :
{}
{
  <UNKNOWN>
}

