options 
{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(QueryParser)
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.TemplateArchetype;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserContext;
import au.com.cybersearch2.classy_logic.compile.AxiomAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.ParserTask;
import au.com.cybersearch2.classy_logic.compile.SourceItem;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.TemplateOperand;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.expression.Orientation;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.list.ListItemVariable;
import au.com.cybersearch2.classy_logic.list.ArrayIndex;
import au.com.cybersearch2.classy_logic.list.ArrayItemList;
import au.com.cybersearch2.classy_logic.list.ListIndex;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.LiteralParameter;
import au.com.cybersearch2.classy_logic.terms.LiteralType;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.interfaces.ListItemSpec;
import au.com.cybersearch2.classy_logic.interfaces.LocaleListener;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser 
{
  
  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    parser.input(context);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    input(context);
    return queryProgram;
  }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, ParserContext context) throws ParseException
  {
    if (resourceName.length() < 3)
      throw new ParseException("Include resourceName \"" + resourceName + "\" is invalid");
    ParserResources parserResources = new ParserResources(context);
    try
    {
      parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
    }
    catch (IOException e)
    {
      throw new ParseException(e.getMessage());
    }
  } 
 
  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  } 

  protected Operand axiomContainerOperand(
          ParserAssembler parserAssembler,
          ListItemSpec[] indexData)
  {
      return axiomContainerOperand(parserAssembler, null, indexData);
  }
  
  protected Operand axiomContainerOperand(
      ParserAssembler parserAssembler,
      String name,
      ListItemSpec[] indexData)
  {
    QualifiedName listName = indexData[0].getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName.getName() + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = parserAssembler.addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand listItemOperand(
      ParserContext context,
      ListItemSpec indexData) throws ParseException
  {
      return listItemOperand(context, null, indexData);
  }
  
  protected Operand listItemOperand(
          ParserContext context,
          String name,
          ListItemSpec indexData) throws ParseException
  {
  
    QualifiedName listName = indexData.getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = context.getParserAssembler().addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand initList(
      ParserContext context, 
      ListItemSpec indexData, 
      Operand assignExpression) throws ParseException
  {
    if (assignExpression == null)
         throw new ParseException("Statement to initialize List \"" + indexData.getListName() + "\"  must be assigned a value");
    ParserAssembler parserAssembler = context.getParserAssembler();
    ArrayItemList<?> itemList = (ArrayItemList<?>) parserAssembler.getListAssembler().findItemList(indexData.getQualifiedListName());
    if (itemList == null)
         throw new ParseException("List \"" + indexData.getListName() + "\" must be declared before being initialized");
    int index = indexData.getItemIndex();
    if (index == -1)
         throw new ParseException("Invalid index \"" + assignExpression.toString() + "\" for list \"" + indexData.getListName() + "\" ");
    itemList.assignItem(index, assignExpression);
    return null; // No operand created indicated by null returned
  }
   
  protected SourceItem addSourceVariable(Operand var, ParserContext context)
  {
     int kind = context.getItemToken().kind;
     switch (kind)
     {
     case QueryParserConstants.INTEGER:
     case QueryParserConstants.BOOLEAN:
     case QueryParserConstants.DOUBLE:
     case QueryParserConstants.STRING:
     case QueryParserConstants.DECIMAL:
     case QueryParserConstants.CURRENCY:
     {
          String type = QueryParserConstants.tokenImage[kind];
          return context.addSourceItem(type.substring(1, type.length() - 1) + " " + var.toString());
     }
     default:
         return context.addSourceItem(var);
     }
  }
  
  void initializeList(ItemList<?> itemList, List<Parameter> literalList)
  {
    for (int i = 0; i < literalList.size(); ++i)
    {
      Parameter param = literalList.get(i);
      if (param instanceof IntegerTerm)
        ((ItemList<Long>)itemList).assignItem(i, (Long)param.getValue());
      else if (param instanceof DoubleTerm)
        ((ItemList<Double>)itemList).assignItem(i, (Double)param.getValue());
      else if (param instanceof StringTerm)
        ((ItemList<String>)itemList).assignItem(i, (String)param.getValue());
      else if (param instanceof BooleanTerm)
        ((ItemList<BooleanTerm>)itemList).assignItem(i, (BooleanTerm)param.getValue());
    }
  }
}
PARSER_END(QueryParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN :
{
  < INTEGER: "integer" >
| < DOUBLE: "double" >
| < DECIMAL: "decimal" >
| < BOOLEAN: "boolean" >
| < STRING: "string" >
| < TEMPLATE: "template" >
| < AXIOM: "axiom" >
| < REGEX: "regex" >
| < INCLUDE: "include" >
| < SCOPE: "scope" >
| < QUERY: "query" >
| < CALC: "calc" >
| < LIST: "list" >
| < FACT: "fact" >
| < LENGTH: "length" >
| < TERM: "term" >
| < RESOURCE: "resource" >
| < CURRENCY: "currency" >
| < FORMAT: "format" >
| < LOCAL: "local" >
| < CHOICE: "choice" >
| < PARAMETER: "parameter" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
  >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT> | (["d","D"]))
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (     
        (~["\"","\\","\n","\r"])
        | 
        ("\\" ( ["n","t","b","r","f","\\","'","\"","."] ) )
      )*
      "\""
  >
|
  < TRUE: "true" >
|
  < FALSE: "false" >
|
   <UNKNOWN: "unknown" >
|
   <NAN: "NaN" >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < COLON: ":" >
| < QMARK: "?" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
}

/** Root production. */
void input(ParserContext context) :
{
}
{
  ( ResourceDeclaration(context) ";" )*
  ( Statement(context) | QueryChain(context) | ScopeDeclaration(context) )+
  <EOF>
  {
    context.getQueryProgram().runPending();
  }
}

void ResourceDeclaration(ParserContext context) :
{
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
  <RESOURCE> nameToken=<STRING_LITERAL> ( InitialiserList(properties, context) )?
  {
    context.getQueryProgram().openResource(getText(nameToken), properties);
  }
}


void ScopeDeclaration(ParserContext context) :
{
  Token scopeToken;
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
  scopeToken=<SCOPE> nameToken=<IDENTIFIER>   
  {
    context.setSourceMarker(scopeToken, nameToken.image);
  }
  [ InitialiserList(properties, context) ]
  {
    Scope scope = context.getQueryProgram().scopeInstance(nameToken.image , properties);
    context.setScope(scope);
  }
  "{" 
  {
  }
     ( Statement(context) | QueryChain(context) )*
  "}" 
  {
    context.resetScope();
  }
}

void QueryChain(ParserContext context) :
{
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
  Token typeToken = null;
}
{  
  queryToken=<QUERY> ( "<" (typeToken=<AXIOM> | typeToken=<TERM>) ">" )? querySpec=Query(context)
  {
    context.setSourceMarker(queryToken, querySpec.getName());
  }
  querySpec=QueryDeclaration(querySpec, context) 
  ( 
    chainToken=">>" 
    {
      context.onTokenIntercept(chainToken);
    }
    QueryDeclaration(querySpec.chain(), context) 
  )* ";"
  {
    context.getScope().addQuerySpec(querySpec);
    if (typeToken == null)
      return;
    ParserAssembler parserAssembler = context.getParserAssembler();
    VariableType varType = typeToken.kind == QueryParserConstants.AXIOM ? new VariableType(OperandType.AXIOM) : new VariableType(OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, querySpec.getKey());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, querySpec.getName());
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }  
}

QuerySpec Query(ParserContext context) :
{
   Token queryToken;
}
{
  queryToken=<IDENTIFIER> 
  {
    return new QuerySpec(queryToken.image);
  }    
}

QuerySpec QueryDeclaration(QuerySpec querySpec, ParserContext context) :
{
  KeyName firstKeyname;
  KeyName keyname;
  Token delimitToken;
  SourceItem sourceItem;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
   "(" 
      ( 
        firstKeyname = KeyName(querySpec, context)
        {
          sourceItem = context.addSourceItem(firstKeyname.toString());
        }
      )
      (
        delimitToken="," 
        {
          sourceItem.setEnd(delimitToken);
        }
        (
          keyname = KeyName(querySpec, context)
          {
          sourceItem = context.addSourceItem(keyname.toString());
          }
        )
        {
            ++keynameCount;
        }
      )* delimitToken=")" 
      {
        sourceItem.setEnd(delimitToken);
      }
      ( InitialiserList(properties, context) )?
    {
        return context.getScope().buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);
    }
}

KeyName KeyName(QuerySpec querySpec, ParserContext context) :
{
  String name1;
  String name2 = null;
}
{
  name1=Name(context) (":" name2=Name(context) )?
  {
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    return keyname;
  }
}

void Statement(ParserContext context):
{
  context.setSourceItemPending(false);
}
{
    VariableInitialization(context) 
  | AxiomDeclaration(context) 
  | ListDeclaration(context)
  | TemplateDeclaration(context) ";" 
  | CalculatorTemplate(context) ";"   
  | ChoiceDeclaration(context) ";"
  | Include(context) ";"
}

void AxiomDeclaration(ParserContext context) :
{
  QualifiedName qualifiedAxiomName;
  SourceItem sourceItem;
  Token axiomToken;
  Token delimitToken;
  String axiomSpec;
  Operand operand = null;
}
{
  axiomToken=<AXIOM> qualifiedAxiomName=Axiom(context) 
  {
    context.setSourceMarker(axiomToken, qualifiedAxiomName);
    context.setSourceItemPending(false);
  }
  ( 
    axiomSpec = AxiomSpecification(qualifiedAxiomName, context) 
    {
      sourceItem = context.addSourceItem(axiomSpec);
    }
    |
    operand=AxiomVariable(qualifiedAxiomName, context) 
    {
       context.getOperandMap().addOperand(operand);
       sourceItem = context.addSourceItem(operand);
    }
  ) delimitToken=";"
  {
     sourceItem.setEnd(delimitToken);
  }
} 

QualifiedName Axiom(ParserContext context) :
{
  String axiomName;
}
{
  axiomName=Name(context)
  { 
    return axiomName.indexOf(".") == -1 ? 
        context.getParserAssembler().getContextName(axiomName) :
        QualifiedName.parseName(axiomName); 
  }
}

String AxiomSpecification(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  String termName;
  Token resouceToken;
  QualifiedName resourceBinding;
  int index = 0;
  StringBuilder builder = new StringBuilder(qualifiedAxiomName.getName());
  ParserAssembler parserAssembler = context.getParserAssembler();
  parserAssembler.getListAssembler().createAxiomItemList(qualifiedAxiomName);
}
{
  "(" 
  {
    builder.append('(');
  } 
     ( termName=TermName(qualifiedAxiomName, parserAssembler) 
        {
          builder.append(termName);
        }
        ( 
          "," termName=TermName(qualifiedAxiomName, parserAssembler)
          {
            builder.append(',').append(termName);
          } 
        )* 
      )?  
  ")" 
  {
    builder.append(')');
  } 
  (
    resouceToken=":" ( 
          resourceBinding=ResourceBinding(QueryParserConstants.AXIOM, qualifiedAxiomName, parserAssembler)
          {
            builder.append(':');
            if (resouceToken.next != null)
            	builder.append(resouceToken.next);
          }
          |
          ParameterDeclaration(qualifiedAxiomName, parserAssembler) 
          {
            builder.append(":parameter");
          }
        )
    |
    ( 
      <LBRACE> 
      ( AxiomItem(qualifiedAxiomName, context)
        |
        AltAxiomItem(qualifiedAxiomName, context)
      )
      {
        ++index;
      }
      <RBRACE> 
    )+
    {
      builder.append('[').append(Integer.toString(index)).append(']');
    }
  )?
  {
    return builder.toString();
  }
}

String TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  Token nameToken;
}
{
  nameToken=<IDENTIFIER>
  {
    parserAssembler.getAxiomAssembler().addAxiomTermName(qualifiedAxiomName, nameToken.image);
    return nameToken.image;
  }
}

QualifiedName ResourceBinding(int kind, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  Token nameToken = null;
}
{
  ( nameToken=<STRING_LITERAL> | <RESOURCE> )
  {
    QualifiedName qualifiedBindingName = 
        kind == QueryParserConstants.TEMPLATE ?
        new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName()) :
        qualifiedAxiomName;
    AxiomProvider axiomProvider = (nameToken != null) ?
        parserAssembler.bindResource(QualifiedName.parseName(getText(nameToken)), qualifiedBindingName) :
        parserAssembler.bindResource(qualifiedBindingName);
    return qualifiedBindingName;
  }
}

void AxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) :
{
}
{
  Fact(qualifiedAxiomName, context) ("," Fact(qualifiedAxiomName, context) )*  
  {
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }
}

void AltAxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) :
{
}
{
  <BIT_OR> Fact(qualifiedAxiomName, context) ( <BIT_OR> Fact(qualifiedAxiomName, context) )*
  {
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }
}

String Fact(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  Parameter param = null;
  Token lit = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  param=LiteralTerm(context)
  {
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, param);
    return param.getValue().toString();
  }
  |
  <NAN>
  {
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
    return "NaN";
  }
}

Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  List<Template> axiomList;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  "=" axiomList=AxiomList(qualifiedAxiomName, context) 
  {
     VariableType varType = new VariableType(OperandType.LIST);
     varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     parserAssembler.setParameter(operand.getQualifiedName());
     return operand;
  }
} 

List<Template> AxiomList(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  List<Template> templateParamList = new ArrayList<Template>();
  Template template;
}
{
  template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context)
  {
    templateParamList.add(template);
  }
  ( 
    template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context)
    {
     templateParamList.add(template);
    }
  )*
  {
    return templateParamList;
  }
}

Template AxiomInitializer(String listName, QualifiedName axiomName, ParserContext context) :
{
  Template initializeTemplate = null;
}
{
  <LBRACE> ( initializeTemplate = Parameters(listName, context, true) )? <RBRACE>
  {
     if (initializeTemplate != null)
       return initializeTemplate;
     TemplateArchetype architype = new TemplateArchetype(new QualifiedTemplateName(context.getScope().getAlias(), axiomName.getName()));
     return new Template(architype);
  }
}

void TemplateDeclaration(ParserContext context) :
{
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  QualifiedName contextName = context.getContextName();
}
{
  templateToken=<TEMPLATE> template=Template(context, false) "(" 
  {
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(templateToken, template.getQualifiedName());
  }
  ( 
    expression=TemplateExpression(template, context)
    {
      template.addTerm(expression);
      sourceItem = addSourceVariable(expression, context);
    }
  )
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    (
      expression=TemplateExpression(template, context)
      {
        template.addTerm(expression);
        sourceItem = addSourceVariable(expression, context);
      }
    )
  )* delimitToken=")" 
  {
    context.setContextName(contextName);
    sourceItem.setEnd(delimitToken);
  }
}

Template Template(ParserContext context, boolean isCalculator) :
{
  Token templateToken;
}
{
  templateToken=<IDENTIFIER>
  { 
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), templateToken.image);
    context.setContextName(qualifiedTemplateName);
    return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, isCalculator); 
  }
}

void CalculatorTemplate(ParserContext context) :
{
  Template template;
  Token calcToken;
  Token delimitToken;
  Operand operand;
  SourceItem sourceItem;
  Token privateToken = null;
  Map<String, Object> properties = new HashMap<String, Object>();
  ParserAssembler parserAssembler = context.getParserAssembler();
  QualifiedName contextName = context.getContextName();
}
{  
  calcToken=<CALC> template=Template(context, true) "(" 
  {
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(calcToken, template.getQualifiedName());
  }
  ( privateToken="." )?  
  ( 
    operand = CalculatorExpression(template, template.getQualifiedName(), context) 
    |
    operand = CalculatorQuery(template, context)
  )
  {
    if (privateToken != null)
      operand.setPrivate(true);
    privateToken = null;
    sourceItem = addSourceVariable(operand, context);
  }        
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    ( privateToken="." )?  
    (  
      operand = CalculatorExpression(template, template.getQualifiedName(), context) |
      operand = CalculatorQuery(template, context)
    )
    {
      if (privateToken != null)
        operand.setPrivate(true);
      privateToken = null;
      sourceItem = addSourceVariable(operand, context);
    }        
  )* 
  delimitToken=")" 
    {
      sourceItem.setEnd(delimitToken);
    }
  [ InitialiserList(properties, context) ]
  {
    if (properties.size() > 0)
        template.addProperties(properties);
    context.setContextName(contextName);
  }
}

Operand TemplateExpression(Template template, ParserContext context) :
{
    String name;
    QualifiedName qname;
    QualifiedName axiomQname;
    String axiomName = null;
    VariableType varType = null;
    Operand var = null;
    Token scToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Token interceptToken = null;
    Operand expression = null;
    ListItemSpec[] listIndexData = null;
    Group group = null;
    ParserAssembler parserAssembler = context.getParserAssembler();
    OperandMap operandMap = parserAssembler.getOperandMap();
    List<Parameter> literalList = null;
    List<Template> axiomList = null;
    Template parameterTemplate = null;
}
{
  ( varType=Type(context) )? name=Name(context) 
  {
    qname = parserAssembler.getContextName(name);
    axiomQname = qname;
  }
  ( listIndexData=IndexExpression(context.getQualifiedName(name), context) )? 
  (
     ( 
       ( equalsToken="=" | assignToken=<PLUSASSIGN> )
       ( <AXIOM> 
         ( 
           axiomName=Name(context) 
           {
             axiomQname = QualifiedName.parseName(axiomName);
           }
         ) ? 
         axiomList=AxiomList(axiomQname, context) 
       {
         VariableType axiomListVarType = new VariableType(OperandType.LIST);
         axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
         if (axiomName != null)
           axiomListVarType.setProperty(VariableType.AXIOM_KEY, axiomQname);
         expression = axiomListVarType.getInstance(parserAssembler, axiomQname);
       } 
       |
       expression=Expression(context) )
    )
    |
    (  
      ( 
        scToken=<COLON> | scToken=<QMARK>  
        | assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN> 
      )
      expression=Expression(context) 
    )
    |
        interceptToken=<REGEX> "(" ( regexLit=<STRING_LITERAL> | regexId=<IDENTIFIER> ) ( group=GroupDeclaration(template, name, parserAssembler) )? ")"
    |
        interceptToken=<LBRACE> literalList = LiteralList(context) <RBRACE> 
    |
     "(" ( parameterTemplate = Parameters(name, context, true) )? ")"
	{
	     template.addTerm(parserAssembler.getCallOperand(qname, parameterTemplate));
	}
  )?
  {
    boolean isDeclaration = varType != null; 
    boolean hasOperand = operandMap.hasOperand(name, parserAssembler.getQualifiedContextname());
    if (!isDeclaration)
      varType = new VariableType(OperandType.UNKNOWN);
    Operand assignExpression = (assignToken != null) ? expression : null;
    Operand regexOp = null;
    if (regexLit != null)
      regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
    else if (regexId != null)
      regexOp = operandMap.addOperand(regexId.image, null, parserAssembler.getQualifiedContextname());
    if (assignToken != null)
      expression = null;
    if (expression != null)
      varType.setProperty(VariableType.EXPRESSION, expression);
    if (listIndexData !=null)
      var = listIndexData.length == 1 ? listItemOperand(context, listIndexData[0]) : axiomContainerOperand(parserAssembler, listIndexData);
    else if (regexOp != null)
      var = new RegExOperand(qname, regexOp, 0, group);
    else if (scToken != null) 
      var = new Evaluator(qname, expression, (scToken.image == "?" ? "&&" : "||"), Orientation.unary_postfix);
    else if (literalList != null)
      var = new LiteralListOperand(qname, literalList);
    else 
      var = operandMap.getOperand(qname);
    if ((var != null) && isDeclaration)
       operandMap.duplicateOperandCheck(qname); 
    if ((var == null) && !hasOperand)
      var = varType.getInstance(parserAssembler, name);
    if (var == null)
      var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
    if ((listIndexData == null) && (!hasOperand))
      operandMap.addOperand(var);
    if (assignToken != null) 
      var = parserAssembler.createReflexiveEvaluator(var, assignToken.image, assignExpression);
    if ((equalsToken != null) && (listIndexData !=null))
      var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
    else if (hasOperand && (equalsToken != null))
      var = new Evaluator(parserAssembler.getContextName(var.getName() + var.getQualifiedName().incrementReferenceCount()), var, "=", expression);
    if (interceptToken != null)
      context.onTokenIntercept(interceptToken);
    return var;
  }
}

Operand CalculatorExpression(Template template, QualifiedName outerTemplateName, ParserContext context) :
{
  Token literalToken;
  Token delimitToken;
  Token choiceToken;
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  ( scToken=":" | scToken="?" ) 
    {
      context.onTokenIntercept(scToken);
    }  
    expression=Expression(context)
    ( 
      delimitToken="{"
      {
        Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
        context.addSourceItem(scToken.image+expression.toString()).setEnd(delimitToken);
        context.pushSourceMarker();
        Token token = Token.newToken(QueryParserConstants.CALC);
        token.beginLine = delimitToken.beginLine;
        token.beginColumn = delimitToken.beginColumn;
        context.setSourceMarker(token, innerTemplate.getQualifiedName());
      }
      innerLoop=InnerCalculator(innerTemplate, outerTemplateName, context, true) 
      {
      context.popSourceMarker();
      context.onTokenIntercept(delimitToken);
      }
     )?  
  {
    String operator = scToken.image == "?" ? "&&" : "||";
    expression = innerLoop == null ? new Evaluator(expression, operator, Orientation.unary_postfix) : new Evaluator(expression, operator, innerLoop);
    expression.setPrivate(true);
    template.addTerm(expression);
    return expression;
  }
  |
  (expression=TemplateExpression(template, context) |
   expression=Expression(context))
  {
    template.addTerm(expression);
    return expression;
  }
  |
  (
    delimitToken="{"
    {
      context.onTokenIntercept(delimitToken);
      context.pushSourceMarker();
      Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
      Token token = Token.newToken(QueryParserConstants.CALC);
      token.beginLine = delimitToken.beginLine;
      token.beginColumn = delimitToken.beginColumn;
      context.setSourceMarker(token, innerTemplate.getQualifiedName());
    }
    innerLoop=InnerCalculator(innerTemplate, outerTemplateName, context, false)
    {
      context.checkForShortCircuit();
      context.popSourceMarker();
    }
  )
  {
    template.addTerm(innerLoop);
    context.onTokenIntercept(delimitToken);
    return innerLoop;
  }
  |
  literalToken=<AXIOM> 
  {
    context.onTokenIntercept(literalToken);
  }
  qualifiedAxiomName=Axiom(context) expression = AxiomVariable(qualifiedAxiomName, context) 
  {
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
    return expression;
  }
  |
  literalToken=<CHOICE>
  {
    context.onTokenIntercept(literalToken);
  }
  choiceToken=<IDENTIFIER>
  {
    qualifiedAxiomName = QualifiedName.parseName(choiceToken.image);
    qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplateAssembler().createChoiceTemplate(template, qualifiedTemplateName);
    OperandMap operandMap = parserAssembler.getOperandMap();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    for (String termName: axiomAssembler.getTermNameList(qualifiedAxiomName))
      operandMap.addOperand(termName, null, parserAssembler.getQualifiedContextname());
    QualifiedName contextName = context.getContextName();
    QualifiedName qname = QualifiedName.parseName(qualifiedAxiomName.getName(), contextName); 
 	Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
    return choiceOperand;
  }
}

Operand CalculatorQuery(Template template, ParserContext context) :
{
  Token queryToken;
  Token delimitToken;
  String queryName;
  String callName;
  QualifiedName qname;
  QualifiedName outerTemplateName = template.getQualifiedName();
  Template innerTemplate = null;
  Template parameterTemplate = null;
}
{
  queryToken="<<"
  {
    context.onTokenIntercept(queryToken);
    context.pushSourceMarker();
  }
  queryName=Name(context)  
  {
    qname = context.getQualifiedName(queryName);
    callName = qname.getName();
    Token token = Token.newToken(QueryParserConstants.QUERY);
    token.beginLine = queryToken.beginLine;
    token.beginColumn = queryToken.beginColumn;
    context.setSourceMarker(token, queryName);
    context.setSourceItemPending(false);
  }
  "(" ( parameterTemplate = Parameters(callName, context, false) )? delimitToken=")"
  {
    int reference = qname.incrementReferenceCount();
    if (reference > 0)
       qname = new QualifiedName(qname.getName() + reference, qname);
    context.addCalcQuery(qname, parameterTemplate).setEnd(delimitToken);
  }
  ( innerTemplate=InnerTemplateDeclaration(outerTemplateName, callName, context) )?
  {
    Operand queryOperand = context.getParserAssembler().getQueryOperand(queryName, qname, parameterTemplate, innerTemplate);
    template.addTerm(queryOperand);
    context.popSourceMarker();
    return queryOperand;
  }
}

Template InnerTemplateDeclaration(QualifiedName outerTemplateName, String callName, ParserContext context) :
{
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String queryKey = outerTemplateName.getTemplate() + "." + callName;
}
{
    templateToken=">>"
    {
      ParserAssembler parserAssembler = context.getParserAssembler();
      template = parserAssembler.getTemplateAssembler().createQueryTemplate(outerTemplateName, callName);
      template.setKey(queryKey);
      context.onTokenIntercept(templateToken);
    }
    delimitToken="(" 
    {
      context.addSourceItem(">> " + template.getQualifiedName().toString()).setEnd(delimitToken);
    }
      ( 
        expression=TemplateExpression(template, context)
        { 
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
        }
      )
      (
        delimitToken="," 
        {
          sourceItem.setEnd(delimitToken);
        }
        (
          expression=TemplateExpression(template, context)
        {
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
        }
        )
      )* 
      delimitToken=")" 
    {
        sourceItem.setEnd(delimitToken);
        return template;
    }
}

Operand InnerCalculator(Template template, QualifiedName outerTemplateName, ParserContext context, boolean runOnce) :
{

  Operand operand;
  SourceItem sourceItem;
  Token delimitToken;
  context.setSourceItemPending(true);
}
{
  ( 
    operand=CalculatorExpression(template, outerTemplateName, context)
    |
    operand = CalculatorQuery(template, context)
  )
  {
     sourceItem=addSourceVariable(operand, context);
  }
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    (
      operand=CalculatorExpression(template, outerTemplateName, context)
      |
      operand = CalculatorQuery(template, context)
    )
    {
      sourceItem=addSourceVariable(operand, context);
    }
  )* 
  delimitToken="}"
  {
    TemplateOperand templateOperand = new TemplateOperand(template, runOnce);
    sourceItem.setEnd(delimitToken);
    return templateOperand;
  }
}

QualifiedName ChoiceDeclaration(ParserContext context) :
{
  Token choiceToken;
  Token delimitToken;
  QualifiedName qualifiedAxiomName;
  int selection = 0;
  boolean isSourceItemPending = context.isSourceItemPending();
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  QualifiedName contextName = context.getContextName();
}
{
  choiceToken=<CHOICE> qualifiedAxiomName=Choice(context) 
  {
    if (!isSourceItemPending)
      context.setSourceMarker(choiceToken, qualifiedAxiomName);
  }
  "(" 
    TermName(qualifiedAxiomName, parserAssembler) ("," TermName(qualifiedAxiomName, parserAssembler) )*  
  delimitToken=")" 
  {
    context.addChoiceItem(qualifiedAxiomName).setEnd(delimitToken); 
  }
  ( ChoiceItem(selection++, qualifiedAxiomName, context) )+ 
  {
    context.setContextName(contextName);
    return qualifiedAxiomName;
  }
} 

QualifiedName Choice(ParserContext context) :
{
    Token choiceToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    Scope scope = context.getScope();
}
{
  choiceToken=<IDENTIFIER>
  { 
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.getListAssembler().createAxiomItemList(qualifiedChoiceName);
    parserAssembler.getTemplateAssembler().createTemplate(qualifiedChoiceName, true);
    context.setContextName(new QualifiedTemplateName(scope.getAlias(), choiceToken.image));
    return qualifiedChoiceName;
  }
}
 
void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserContext context) :
{
    Operand operand;
    String fact;
    Token delimToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    String name = axiomAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new StringTerm(name + selection));
    StringBuilder builder = new StringBuilder();
}
{
   <LBRACE> operand=ChoiceExpression(name, context)
   {
     builder.append('{').append(operand.toString());
   }
    ( "," 
      fact=Fact(qualifiedAxiomName, context) 
      {
        builder.append(',').append(fact);
      }
    )* delimToken=<RBRACE> 
    {
       parserAssembler.getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.getTemplateAssembler().addTemplate(qualifiedTemplateName, operand);
       builder.append('}');
       context.addSourceItem(builder.toString()).setEnd(delimToken);
    }
}

Operand ChoiceExpression(String name, ParserContext context) :
{
    Operand operand;
    QualifiedName qname = context.getParserAssembler().getContextName(name);
}
{
    operand=Expression(context)
    {
      if (operand instanceof Evaluator)
          return new Evaluator(qname, operand, "&&", Orientation.unary_postfix ); 
      if (operand instanceof StringOperand)
          return new RegExOperand(qname, operand, 0, null);
      return new MatchOperand(qname, operand);
    }
}


void InitialiserList(Map<String, Object> properties, ParserContext context) :
{
  String property;
  SourceItem sourceItem;
  Token delimitToken;
}
{
  "("
  property = InitialiserDeclaration(properties, context)
  {
    sourceItem = context.addSourceItem(property);
  }
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    property = InitialiserDeclaration(properties, context) 
    {
      sourceItem = context.addSourceItem(property);
    }
  )* 
  delimitToken=")"
  {
    sourceItem.setEnd(delimitToken);
  }
}

String InitialiserDeclaration(Map<String, Object> properties, ParserContext context) :
{
  String name;
  Parameter param;
}
{
  name=Name(context) "=" param=LiteralTerm(context)
  {
     properties.put(name, param.getValue());
     return name + "=" + param.getValue().toString();
  }
}

Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) :
{
  Group group = new Group(name);
}
{
  "{" Group(group, template, name, parserAssembler) ("," Group(group, template, name, parserAssembler) )* "}"
  {
    return group;
  }
}

 
void Group(Group group, Template template, String name, ParserAssembler parserAssembler) :
{
  Token groupToken;
}
{
  groupToken=<IDENTIFIER> 
  {
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null, parserAssembler.getQualifiedContextname());   
    template.addTerm(var);
    group.addGroup(var);
    var.setPrivate(true);
  }
}

List<Parameter> LiteralList(ParserContext context) :
{
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
}
{
  parameter=LiteralTerm(context)
  {
    literalList.add(parameter);
  }
  ( 
    "," 
    parameter = LiteralTerm(context) 
    {
      literalList.add(parameter);
    }
  )*
  {
    return literalList;
  }
}

void VariableInitialization(ParserContext context) :
{
  Operand var;
  Token delimitToken;
}
{
    var=VariableDeclaration(context) delimitToken=";" 
    {
      if (var == null)
        return;
      context.getOperandMap().addOperand(var);
      context.setSourceMarker(context.getItemToken(), var.getQualifiedName());
      addSourceVariable(var, context).setEnd(delimitToken);
    }
}

Operand VariableDeclaration(ParserContext context) :
{
  Token nameToken;
  String name;
  boolean isUntyped = true;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  Operand expression = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  context.setSourceItemPending(true);
}
{
  ( varType=Type(context)
    {
      isUntyped = false;
    }
  )? 
  nameToken=<IDENTIFIER> 
  {
    name = nameToken.image;
    if (isUntyped)
      context.onTokenIntercept(nameToken);
  }
  ( listIndexData=IndexExpression(context.getQualifiedName(nameToken.image), context) )? 
  ( "=" expression=Expression(context) )?
  {
      if ((listIndexData !=null) && (listIndexData.length > 1))
       throw new ParseException("Axiom list variable \"" + name + "\" cannot be declared here");
     if (listIndexData !=null)
       return initList(context, listIndexData[0], expression);
     if (isUntyped)
       varType = new VariableType(OperandType.UNKNOWN);
     if (expression != null) //  Need literal condition? && !(expression instanceof Evaluator)
       varType.setProperty(expression.isEmpty() ? VariableType.EXPRESSION : VariableType.LITERAL, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     return operand;
  }
}

void ListDeclaration(ParserContext context) :
{
  Token keywordToken;
  Token nameToken;
  Token delimitToken;
  String listName;
  VariableType varType = null;
  QualifiedName qualifiedBindingName = null;
  QualifiedName qualifiedAxiomName = null;
  Template template = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  ( keywordToken=<LIST> | keywordToken=<LOCAL> ) 
  ( "<" varType=Type(context) ">" )? 
  nameToken=<IDENTIFIER> 
  {
    listName = nameToken.image;
    context.setSourceMarker(keywordToken, listName);
    context.setSourceItemPending(false);
  }
  (
    ( "(" qualifiedAxiomName=Axiom(context)  ( ":" qualifiedBindingName = ResourceBinding(QueryParserConstants.TEMPLATE, qualifiedAxiomName, parserAssembler) )? ")" )
    |
    ( "=" <LBRACE> template=ListParameters(listName, varType, context) <RBRACE> )   
  )?
  delimitToken = ";"
  {
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    boolean isTermList = (varType != null) && varType.getOperandType() == OperandType.TERM;
    if ((varType == null) && (qualifiedAxiomName == null))
      throw new ParseException("Invalid declaration for list \"" + listName + "\". Missing type or axiom name.");
    if ((varType != null) && isLocal)
      throw new ParseException("Invalid declaration for local \"" + listName + "\". Type in declaration not allowed.");
    if ((qualifiedBindingName != null) && !isTermList)
      throw new ParseException("Invalid declaration for " + keywordToken.image + " \"" + listName + "\". Only Term type list can be bound to a resource");
    if (qualifiedBindingName != null)
      qualifiedAxiomName = qualifiedBindingName;
    if (varType == null)
      varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
      varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList;    
    if (template != null)
      itemList = varType.getDynamicListInstance(parserAssembler, listName, template);
    else
      itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
    context.addSourceItem(itemList).setEnd(delimitToken);
  }
}

Template ListParameters(String listName, VariableType varType, ParserContext context) :
{
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  Operand var = null;
  if (varType == null)
      throw new ParseException("Invalid declaration for list \"" + listName + "\". Type omitted from declaration.");
}
{ 
  expression=Expression(context)
  { 
    if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
      var = expression;
    if (var == null)
      var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
    template.addTerm(var);
  }
  ( ","
    expression=Expression(context)
    { 
      var = null;
      if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
        var = expression;
      if (var == null)
        var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
      template.addTerm(var);
    }
  )*
  {
    return template;
  }
}

void Include(ParserContext context) :
{
  Token includeToken = null;
}
{
  <INCLUDE> includeToken=<STRING_LITERAL>
  {
    includeResource(includeToken.image, context);
  }
}

Operand Expression(ParserContext context) :
{
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
}
{
  param=ConditionalOrExpression(context) 
    ( ( assignToken=<ASSIGN>
        | assignToken=<PLUSASSIGN>
        | assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN>
      )
      assignOperand=Expression(context) )?
  {
    if (assignOperand == null)
      return param;
    return new Evaluator(param, assignToken.image, assignOperand);
  }
}

Operand PrimaryExpression(ParserContext context) :
{
  Operand operand;
  QualifiedName qname;
  ListItemSpec[] listIndexData;
  String name = null;
  Token literal = null;
  Operand param1 = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  param1=Literal(context)
  {
    return param1;
  }
  |
  name=Name(context) (LOOKAHEAD(2) param1=NamedExpression(name, context) )?
  {
    if (param1 == null)
        return parserAssembler.addOperand(name);
    return param1;
  }
  |
  literal=<SCOPE> listIndexData=IndexExpression(context.getQualifiedName("scope"), context)
  {
    if (listIndexData.length > 1)
         throw new ParseException("Scope cannot be accessed using axiom list variable");
    operand = listItemOperand(context, listIndexData[0]);
    context.onTokenIntercept(literal);
    return operand;
  }
  |
  "(" ( param1 = Expression(context) ) ")" 
  {
    return param1;
  }
  |
  literal=<LENGTH> "("  name=Name(context) ")"
  {
    QualifiedName listName = context.getQualifiedName(name);
    qname = new QualifiedName(listName.getName().toString() + "_length", listName);
    ListLength listLength = new ListLength(qname, listName);
    ParserTask parserTask = context.getParserAssembler().addPending(listLength);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    context.onTokenIntercept(literal);
    return listLength;
  }
  |
  literal=<FORMAT> "("  name=Name(context) ")"
  {
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        throw new ParseException("Variable \"" + name + "\" not found");
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    context.onTokenIntercept(literal);
    return formatter;
  }
  |
  literal=<FACT> "("  name=Name(context) ")"
  {
    Operand factOperand = parserAssembler.findOperandByName(name);
    context.onTokenIntercept(literal);
    if (factOperand != null)
        return new FactOperand(factOperand);
    else 
        throw new ParseException("Operand " + name + " not found");
  }
}

ListItemSpec[] IndexExpression(QualifiedName listName, ParserContext context) :
{
  Object index1;
  Object index2 = null;
  int dimension = 1;
}
{ 
   index1 = ListSelection(context) ( LOOKAHEAD(2)  index2 = ListSelection(context) { ++dimension; } )?
   {
     if ((dimension == 2) && (index1 instanceof String))
       throw new ParseException("Axiom list \"" + listName.getName() + "\" axiom cannot be selected by name");
     if ((dimension == 1) && (index1 instanceof String))
       return new ListItemSpec[] { new ListIndex(listName, (String)index1) };
     if (dimension == 1)
       return new ListItemSpec[] { new ListIndex(listName, (Operand)index1) };
     ListItemSpec listItemSpec1 = null;
     if (index1 instanceof String)  
         listItemSpec1 = new ListIndex(listName, (String)index1); 
     else
         listItemSpec1 = new ArrayIndex(listName, (Operand)index1); 
     ListItemSpec listItemSpec2 = null;
     if (index2 instanceof String)
       listItemSpec2 = new ListIndex(listName, (String)index2); 
     else
       listItemSpec2 = new ListIndex(listName, (Operand)index2); 
     return new ListItemSpec[] { listItemSpec1, listItemSpec2 };
   }
}

Object ListSelection(ParserContext context) :
{
  Token name;
  Operand param;
}
{
  ( <LBRACKET> param=Expression(context) <RBRACKET> ) 
  {
    return param;
  }
  | 
  ( "^" name=<IDENTIFIER> )
  {
    return name.image;
  }
}

Operand Literal(ParserContext context) :
{
  Token lit;
  Operand operand;
  boolean flag;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  lit=<INTEGER_LITERAL>
  {
    Long litValue = Long.decode(lit.image);
    operand = new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  lit=<FLOATING_POINT_LITERAL>
  {
    operand = new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  lit=<STRING_LITERAL>
  {
    operand = new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  flag=BooleanLiteral(context)
  {
    return new BooleanOperand(QualifiedName.ANONYMOUS, flag);
  }
  |
  UnknownLiteral(context)
  {
    return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());
  }
}

VariableType Type(ParserContext context) :
{
  Token literalToken;
  VariableType varType;
  Token qualifierLit = null;
  String qualifierId = null;
}
{
    literalToken=<INTEGER>
    { 
      varType = new VariableType(OperandType.INTEGER);
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<BOOLEAN>
    { 
      varType = new VariableType(OperandType.BOOLEAN);
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<DOUBLE>
    { 
      varType = new VariableType(OperandType.DOUBLE); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<STRING>
    { 
      varType = new VariableType(OperandType.STRING); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<DECIMAL>
    { 
      varType = new VariableType(OperandType.DECIMAL); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<TERM>
    { 
      varType = new VariableType(OperandType.TERM); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<CURRENCY>
    {
      context.onTokenIntercept(literalToken);
    }
    ( "$" ( qualifierLit=<STRING_LITERAL> | qualifierId=Name(context) ))?
    { 
      varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, context.getOperandMap().addOperand(qualifierId, null, context.getParserAssembler().getQualifiedContextname()));
       return varType; 
    }
}

void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
}
{
  <PARAMETER>
  {
    parserAssembler.setParameter(qualifiedAxiomName);
  }
}

String Name(ParserContext context) :
{
  String name;
  Token partToken;
}
{
  partToken=<IDENTIFIER> 
  {
    name = partToken.image;
    context.onTokenIntercept(partToken);
  }
  (
    "." 
    partToken=<IDENTIFIER>
    {
      name += ("." + partToken.image);
    } 
  )*
  {
    return name;
  }
}

Operand NamedExpression(String name, ParserContext context) :
{
  ListItemSpec[] indexData;
  Template parametersTemplate = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  indexData=IndexExpression(context.getQualifiedName(name), context) 
  {
    return indexData.length == 1 ? 
    listItemOperand(context, indexData[0]) :  
    axiomContainerOperand(parserAssembler, indexData);
  }
  |
  "(" ( parametersTemplate = Parameters(name, context, true) )? ")"
  {
    QualifiedName qname = parserAssembler.getContextName(name);
    return parserAssembler.getCallOperand(qname, parametersTemplate);
  }
}

Template Parameters(String callName, ParserContext context, boolean nameRequired) :
{
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  String functionKey = outerTemplateName.getTemplate() + "." + callName;
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  template.setKey(functionKey);
}
{
  ( 
    expression=ParameterExpression(context, nameRequired)
    { 
      template.addTerm(expression);
     }
  )
  (
    "," 
    (
      expression=ParameterExpression(context, nameRequired)
      {
        template.addTerm(expression);
      }
    )
  )* 
  {
    return template;
  }
}

Operand ParameterExpression(ParserContext context, boolean nameRequired) :
{
  Token identifier = null;
  Parameter parameter = null;
  Operand expression = null;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  (varType=Type(context))? 
  (
    (identifier=<IDENTIFIER> ( listIndexData=IndexExpression(context.getQualifiedName(identifier.image), context) )?) 
    | 
    parameter=LiteralTerm(context)
  )  
  ( "=" expression=Expression(context))? 
  {
     String name = (identifier == null) ? Term.ANONYMOUS : identifier.image;
     QualifiedName qname = parserAssembler.getContextName(name);
     Operand var = null;
     if (parameter != null)
       var = new Variable(qname);
     if (var != null)
       var.assign(parameter);
     if ((var == null) && (varType == null))
       var = parserAssembler.getOperandMap().getOperand(qname);
     if (var != null)
       return var;
     if (operandMap.hasOperand(name, parserAssembler.getQualifiedContextname()))
         var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
     if (var != null)
       {if (true) return var;}
     if (listIndexData !=null)
       var = listIndexData.length == 1 ? listItemOperand(context, name, listIndexData[0]) : axiomContainerOperand(parserAssembler, name, listIndexData);
     if (var != null)
       return var;
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     if (varType.getOperandType() == OperandType.TERM)
       varType.setUnknownType();
     if (expression != null)
       varType.setProperty(VariableType.EXPRESSION, expression);
     return varType.getInstance(parserAssembler, name);
  }
}

Parameter LiteralTerm(ParserContext context) :
{
  Token lit;
  Parameter param;
  boolean flag;
}
{
  lit=<INTEGER_LITERAL>
  {
    param = new IntegerTerm(lit.image);
    context.onTokenIntercept(lit);
    return param;
  }
  |
  lit=<FLOATING_POINT_LITERAL>
  {
    param = new DoubleTerm(lit.image);
    context.onTokenIntercept(lit);
    return param;
  }
  |
  lit=<STRING_LITERAL>
  {
    param = new StringTerm(getText(lit));
    context.onTokenIntercept(lit);
    return param;
  }
  |
  flag=BooleanLiteral(context)
  {
    return new BooleanTerm(flag);
  }
  |
  UnknownLiteral(context)
  {
    return new LiteralParameter(Term.ANONYMOUS, new Unknown(), LiteralType.unknown);
  }
}

boolean BooleanLiteral(ParserContext context) :
{
  Token lit;
}
{
  lit=<TRUE> 
  { 
    context.onTokenIntercept(lit);
    return true; 
  }
  |
  lit=<FALSE> 
  { 
    context.onTokenIntercept(lit);
    return false; 
  }
}

void UnknownLiteral(ParserContext context) :
{
  Token lit;
}
{
  lit=<UNKNOWN>
  {
    context.onTokenIntercept(lit);
  }
}

Operand ConditionalOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ConditionalAndExpression(context)
  ( 
    op="||" 
    params[1]=ConditionalAndExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand ConditionalAndExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=InclusiveOrExpression(context)
  ( 
    op="&&" 
    params[1]=InclusiveOrExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand InclusiveOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ExclusiveOrExpression(context)
  ( 
    op="|" 
    params[1]=ExclusiveOrExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand ExclusiveOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AndExpression(context)
  ( 
    op="^" 
    params[1]=AndExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AndExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=EqualityExpression(context)
  ( 
    op="&" 
    params[1]=EqualityExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand EqualityExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=RelationalExpression(context)
  ( 
    ( 
    op="==" 
    | 
    op="!=" 
    ) 
    params[1]=RelationalExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand RelationalExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AdditiveExpression(context)
  ( 
    ( 
    op="<" 
    | 
    op=">" 
    |
    op="<=" 
    | 
    op=">=" 
    ) 
    params[1]=AdditiveExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AdditiveExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{ 
  params[0]=MultiplicativeExpression(context)
  (  
    ( 
    op="+" 
    | 
    op="-" 
    ) 
    params[1]=MultiplicativeExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand MultiplicativeExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=UnaryExpression(context)
  ( 
    ( 
    op="*" 
    | 
    op="/" 
    | 
    op="%" 
    ) 
    params[1]=UnaryExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand UnaryExpression(ParserContext context) :
{
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
}
{ 
  ( 
    "+"
    {
      plus = true;
    }
    | 
    "-"
    {
      minus = true;
    }
    |
      "~"
    {
      tilde = true;
    }
  ) 
  param=UnaryExpression(context)
  {
    if (plus)
      return new Evaluator(param, "+", Orientation.unary_prefix);
    else if (minus)
      return new Evaluator(param, "-", Orientation.unary_prefix);
    else if (tilde)
      return new Evaluator(param, "~", Orientation.unary_prefix);
    return param;
  }
  | 
  param=PreIncrementExpression(context)
  {
    return param;
  }
  |
  param=PreDecrementExpression(context)
  {
    return param;
  }
  |
  param=UnaryExpressionNotPlusMinus(context)
  {
    return param;
  }
}

Operand PreIncrementExpression(ParserContext context) :
{
  Operand param;
}
{ 
  "++" param=PrimaryExpression(context)
  {
    return new Evaluator(param, "++", Orientation.unary_prefix);
  }
}

Operand PreDecrementExpression(ParserContext context) :
{
  Operand param;
}
{
  "--" param=PrimaryExpression(context)
  {
    return new Evaluator(param, "--", Orientation.unary_prefix);
  }
}

Operand UnaryExpressionNotPlusMinus(ParserContext context) :
{
  Operand param;
}
{ 
  "!" param=UnaryExpression(context)
  {
    return new Evaluator(param, "!", Orientation.unary_prefix);
  }
  |
  param=PostfixExpression(context)  
  {
    return param;
  }
}

Operand PostfixExpression(ParserContext context) :
{
  Operand param;
  boolean incr = false;
  boolean decr = false;
}
{ 
  param=PrimaryExpression(context)
  (   
    <INCR>
    {
      incr = true;
    }
    | 
    <DECR>
    {
      decr = true; 
    }
  )?
  {
    if (incr)
       return new Evaluator(param, "++", Orientation.unary_postfix);
    else if (decr)
       return new Evaluator(param, "--", Orientation.unary_postfix);
    return param;
  } 
}


