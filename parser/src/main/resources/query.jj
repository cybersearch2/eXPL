options 
{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  TOKEN_FACTORY = "au.com.cybersearch2.classy_logic.parser.MyToken";
}

PARSER_BEGIN(QueryParser)
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.TemplateArchetype;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserContext;
import au.com.cybersearch2.classy_logic.compile.AxiomAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ListAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.ParserTask;
import au.com.cybersearch2.classy_logic.compile.SourceItem;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.AxiomOperand;
import au.com.cybersearch2.classy_logic.expression.ProxyAxiomOperand;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.TemplateOperand;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.expression.LiteralListOperand;
import au.com.cybersearch2.classy_logic.expression.Orientation;
import au.com.cybersearch2.classy_logic.expression.SelectionOperand;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.list.ListItemVariable;
import au.com.cybersearch2.classy_logic.list.ArrayIndex;
import au.com.cybersearch2.classy_logic.list.ArrayItemList;
import au.com.cybersearch2.classy_logic.list.ListIndex;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.list.Cursor;
import au.com.cybersearch2.classy_logic.list.ListType;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.LiteralParameter;
import au.com.cybersearch2.classy_logic.terms.LiteralType;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.interfaces.ListItemSpec;
import au.com.cybersearch2.classy_logic.interfaces.LocaleListener;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.QualifiedTemplateName;


/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser 
{
  
  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    parser.input(context);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    ParserContext context = new ParserContext(queryProgram);
    input(context);
    return queryProgram;
  }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, ParserContext context) throws ParseException
  {
    if (resourceName.length() < 3)
      throw new ParseException("Include resourceName \"" + resourceName + "\" is invalid");
    ParserResources parserResources = new ParserResources(context);
    try
    {
      parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
    }
    catch (IOException e)
    {
      throw new ParseException(e.getMessage());
    }
  } 
 
  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  } 

  protected Operand axiomContainerOperand(
          ParserAssembler parserAssembler,
          ListItemSpec[] indexData)
  {
      return axiomContainerOperand(parserAssembler, null, indexData);
  }
  
  protected Operand axiomContainerOperand(
      ParserAssembler parserAssembler,
      String name,
      ListItemSpec[] indexData)
  {
    QualifiedName listName = indexData[0].getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName.getName() + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = parserAssembler.addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand listItemOperand(
      ParserContext context,
      ListItemSpec indexData) throws ParseException
  {
      return listItemOperand(context, null, indexData);
  }
  
  protected Operand listItemOperand(
          ParserContext context,
          String name,
          ListItemSpec indexData) throws ParseException
  {
  
    QualifiedName listName = indexData.getQualifiedListName();
    QualifiedName qname = new QualifiedName(listName + "_var" + listName.incrementReferenceCount(), listName);
    ListItemVariable operand = name == null ? new ListItemVariable(qname, indexData) : new ListItemVariable(name, qname, indexData);
    ParserTask parserTask = context.getParserAssembler().addPending(operand);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    return operand;
  }

  protected Operand initList(
      ParserContext context, 
      ListItemSpec indexData, 
      Operand assignExpression) throws ParseException
  {
    if (assignExpression == null)
         throw new ParseException("Statement to initialize List \"" + indexData.getListName() + "\"  must be assigned a value");
    ParserAssembler parserAssembler = context.getParserAssembler();
    ArrayItemList<?> itemList = (ArrayItemList<?>) parserAssembler.getListAssembler().findItemList(indexData.getQualifiedListName());
    if (itemList == null)
         throw new ParseException("List \"" + indexData.getListName() + "\" must be declared before being initialized");
    int index = indexData.getItemIndex();
    if (index == -1)
         throw new ParseException("Invalid index \"" + assignExpression.toString() + "\" for list \"" + indexData.getListName() + "\" ");
    itemList.assignItem(index, assignExpression);
    return null; // No operand created indicated by null returned
  }
   
  protected SourceItem addSourceVariable(Operand var, ParserContext context)
  {
     int kind = context.getItemToken().kind;
     switch (kind)
     {
     case QueryParserConstants.INTEGER:
     case QueryParserConstants.BOOLEAN:
     case QueryParserConstants.DOUBLE:
     case QueryParserConstants.STRING:
     case QueryParserConstants.DECIMAL:
     case QueryParserConstants.CURRENCY:
     {
          String type = QueryParserConstants.tokenImage[kind];
          return context.addSourceItem(type.substring(1, type.length() - 1) + " " + var.toString());
     }
     default:
         return context.addSourceItem(var);
     }
  }
  
  void initializeList(ItemList<?> itemList, List<Parameter> literalList)
  {
    for (int i = 0; i < literalList.size(); ++i)
    {
      Parameter param = literalList.get(i);
      if (param instanceof IntegerTerm)
        ((ItemList<Long>)itemList).assignItem(i, (Long)param.getValue());
      else if (param instanceof DoubleTerm)
        ((ItemList<Double>)itemList).assignItem(i, (Double)param.getValue());
      else if (param instanceof StringTerm)
        ((ItemList<String>)itemList).assignItem(i, (String)param.getValue());
      else if (param instanceof BooleanTerm)
        ((ItemList<BooleanTerm>)itemList).assignItem(i, (BooleanTerm)param.getValue());
    }
  }
  
  void sizeList(ItemList<?> itemList, OperandType operandType, int begin, int end) throws ParseException
  {
    if (end <= begin)
      throw new ParseException("List \"" + itemList.getName() + "\" begin parameter must less then end");
    if (itemList instanceof ArrayItemList)
    {
      ArrayItemList arrayItemList = (ArrayItemList)itemList;
      arrayItemList.setOffset(begin);
      arrayItemList.setSize(end - begin + 1);
    }
    else
      throw new ParseException("List \"" + itemList.getName() + "\" is not sizeable");
  }

  Template createDynamicAxiomTemplate(String listName, ParserContext context)
  {
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), listName);
    context.setTemplateName(qualifiedTemplateName);
    return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, true); 
  }

  Operand createChoiceOperand(QualifiedName qualifiedAxiomName, Template template, Template parameterTemplate, ParserContext context)
  {
    ParserAssembler parserAssembler = context.getParserAssembler();
    QualifiedTemplateName qualifiedTemplateName = new QualifiedTemplateName(qualifiedAxiomName.getScope(), qualifiedAxiomName.getName());
    Template choiceTemplate = parserAssembler.getTemplateAssembler().createChoiceTemplate(template, qualifiedTemplateName);
    OperandMap operandMap = parserAssembler.getOperandMap();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    for (String termName: axiomAssembler.getTermNameList(qualifiedAxiomName))
      operandMap.addOperand(termName, null, parserAssembler.getQualifiedContextname());
    QualifiedName contextName = context.getContextName();
    QualifiedName qname = QualifiedName.parseName(qualifiedAxiomName.getName(), contextName); 
   	Choice choice = new Choice(qualifiedAxiomName, parserAssembler.getScope(), parameterTemplate);
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    operandMap.addOperand(choiceOperand);
    return choiceOperand;
  }  
  
  String createAxiomList(QualifiedName listName, boolean isPublic, ParserAssembler parserAssembler) throws ParseException
  {
    VariableType varType = new VariableType(OperandType.AXIOM);
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName.getName());
    if (isPublic)
      itemList.setPublic(true);
    return listName.getName();
  }
  
}
PARSER_END(QueryParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN :
{
  < INTEGER: "integer" >
| < DOUBLE: "double" >
| < DECIMAL: "decimal" >
| < BOOLEAN: "boolean" >
| < STRING: "string" >
| < TEMPLATE: "template" >
| < AXIOM: "axiom" >
| < REGEX: "regex" >
| < INCLUDE: "include" >
| < SCOPE: "scope" >
| < QUERY: "query" >
| < CALC: "calc" >
| < LIST: "list" >
| < FACT: "fact" >
| < CURSOR: "cursor" >
| < LENGTH: "length" >
| < TERM: "term" >
| < RESOURCE: "resource" >
| < CURRENCY: "currency" >
| < FORMAT: "format" >
| < LOCAL: "local" >
| < CHOICE: "choice" >
| < PARAMETER: "parameter" >
| < EXPORT: "export" >
}

/* Regular expression flags */
TOKEN :
{
  < unix_lines: "unix_lines" >
| < case_insensitive: "case_insensitive" >
| < comments: "comments" >
| < multiline: "multiline" >
| < literal: "literal" >
| < dotall: "dotall" >
| < unicode_case: "unicode_case" >
| < canon_eq: "canon_eq" >
| < unicode_character_class: "unicode_character_class" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
  >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT> | (["d","D"]))
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (     
        (~["\"","\\","\n","\r"])
        | 
        ("\\" ( ["n","t","b","r","f","\\","'","\"","."] ) )
      )*
      "\""
  >
|
  < TRUE: "true" >
|
  < FALSE: "false" >
|
   <UNKNOWN: "unknown" >
|
   <NAN: "NaN" >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < RARROW: "->" >
| < LARROW: "<-" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < COLON: ":" >
| < QMARK: "?" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((MyToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
     matchedToken.image = ">";
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((MyToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
     matchedToken.image = ">";
  }
| < GT: ">" >
}

/** Root production. */
void input(ParserContext context) :
{
}
{
  ( ResourceDeclaration(context) )*
  ( Statement(context) | QueryChain(context) | ScopeDeclaration(context) )+
  <EOF>
  {
    context.getQueryProgram().runPending();
  }
}

void ResourceDeclaration(ParserContext context) :
{
  Token keywordToken;
  Token delimitToken;
  QualifiedName qualifiedName;
  Token axiomToken = null;
  Token templateToken = null;
  Token resourceToken = null;
  QualifiedName qualifiedTemplateName = null;
  Map<String, Object> properties = new HashMap<String, Object>();
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  keywordToken=<RESOURCE> qualifiedName=Axiom(context) 
  ( 
    (
      (
        axiomToken=<AXIOM> 
        ( 
          TermHeader(qualifiedName, context)
          ( "," templateToken=<EXPORT> qualifiedTemplateName=Axiom(context) )?
        )? 
      )
      | 
      templateToken=<EXPORT> 
    )
    ( "=" resourceToken=<STRING_LITERAL> ) ? ( ":" InitialiserList(properties, context) )?
  )
  delimitToken=";"
  {
    String resourceName;
    if (resourceToken != null)
      resourceName = getText(resourceToken);
    else
      resourceName = qualifiedName.toString();
    context.getQueryProgram().openResource(resourceName, properties);
    QualifiedName qualifiedBindingName = 
      axiomToken == null ?
      new QualifiedTemplateName(qualifiedName.getScope(), qualifiedName.getName()) :
      qualifiedName;
    if (resourceToken != null) 
      parserAssembler.bindResource(resourceName, qualifiedBindingName);
    else
      parserAssembler.bindResource(qualifiedBindingName);
    if ((axiomToken == null) || (templateToken == null))
      return;   
    QualifiedName templateBindingName = 
      new QualifiedTemplateName(qualifiedTemplateName.getScope(), qualifiedTemplateName.getName());
    parserAssembler.bindResource(resourceName, templateBindingName);
  }
}

void ScopeDeclaration(ParserContext context) :
{
  Token scopeToken;
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
}
{
  scopeToken=<SCOPE> nameToken=<IDENTIFIER>   
  {
    context.setSourceMarker(scopeToken, nameToken.image);
  }
  [ InitialiserList(properties, context) ]
  {
    Scope scope = context.getQueryProgram().scopeInstance(nameToken.image , properties);
    context.setScope(scope);
  }
  "{" 
  {
  }
     ( Statement(context) | QueryChain(context) )*
  "}" 
  {
    context.resetScope();
  }
}

void QueryChain(ParserContext context) :
{
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
  Token typeToken = null;
}
{  
  queryToken=<QUERY> ( "<" (typeToken=<AXIOM> | typeToken=<TERM>) ">" )? querySpec=Query(context)
  {
    context.setSourceMarker(queryToken, querySpec.getName());
  }
  querySpec=QueryDeclaration(querySpec, context) 
  ( 
    chainToken="->" 
    {
      context.onTokenIntercept(chainToken);
    }
    QueryDeclaration(querySpec.chain(), context) 
  )* ";"
  {
    context.getScope().addQuerySpec(querySpec);
    if (typeToken == null)
      return;
    ParserAssembler parserAssembler = context.getParserAssembler();
    VariableType varType = typeToken.kind == QueryParserConstants.AXIOM ? new VariableType(OperandType.AXIOM) : new VariableType(OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, querySpec.getKey());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, querySpec.getName());
    itemList.setPublic(true);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }  
}

QuerySpec Query(ParserContext context) :
{
   Token queryToken;
}
{
  queryToken=<IDENTIFIER> 
  {
    return new QuerySpec(queryToken.image);
  }    
}

QuerySpec QueryDeclaration(QuerySpec querySpec, ParserContext context) :
{
  KeyName firstKeyname;
  KeyName keyname;
  Token delimitToken;
  SourceItem sourceItem;
  int keynameCount = 1;
  List<Term> termList = new ArrayList<Term>();
}
{
   "(" 
      ( 
        firstKeyname = KeyName(querySpec, context)
        {
          sourceItem = context.addSourceItem(firstKeyname.toString());
        }
      )
      (
        delimitToken="," 
        {
          sourceItem.setEnd(delimitToken);
        }
        (
          keyname = KeyName(querySpec, context)
          {
          sourceItem = context.addSourceItem(keyname.toString());
          }
        )
        {
            ++keynameCount;
        }
      )* delimitToken=")" 
      {
        sourceItem.setEnd(delimitToken);
      }
      ( TermList(termList, context) )?
    {
        return context.getScope().buildQuerySpec(querySpec, firstKeyname, keynameCount, termList);
    }
}

KeyName KeyName(QuerySpec querySpec, ParserContext context) :
{
  String name1;
  String name2 = null;
}
{
  name1=Name(context) (":" name2=Name(context) )?
  {
    boolean isBinary = name2 != null;
    String axiomKey = isBinary  ? name1 : "";
    String templateName = isBinary  ? name2 : name1;
    KeyName keyname = new KeyName(axiomKey, templateName);
    querySpec.addKeyName(keyname);
    return keyname;
  }
}

void Statement(ParserContext context):
{
  context.setSourceItemPending(false);
}
{
    VariableInitialization(context) 
  | AxiomDeclaration(context) 
  | ListDeclaration(context)
  | TemplateDeclaration(context) ";" 
  | CalculatorTemplate(context) ";"   
  | ChoiceDeclaration(context) ";"
  | Include(context) ";"
}

void AxiomDeclaration(ParserContext context) :
{
  QualifiedName qualifiedAxiomName;
  SourceItem sourceItem;
  Token axiomToken;
  Token delimitToken;
  String axiomSpec;
}
{
  axiomToken=<AXIOM> qualifiedAxiomName=Axiom(context) 
  {
    context.setSourceMarker(axiomToken, qualifiedAxiomName);
    context.setSourceItemPending(false);
  }
  axiomSpec = AxiomSpecification(qualifiedAxiomName, context) 
  {
    sourceItem = context.addSourceItem(axiomSpec);
  }
  delimitToken=";"
  {
     sourceItem.setEnd(delimitToken);
  }
} 

QualifiedName Axiom(ParserContext context) :
{
  String axiomName;
}
{
  axiomName=Name(context)
  { 
    return axiomName.indexOf(".") == -1 ? 
        context.getParserAssembler().getContextName(axiomName) :
        QualifiedName.parseName(axiomName); 
  }
}

String AxiomSpecification(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  String termNames;
  Token resouceToken;
  int index = 0;
  StringBuilder builder = new StringBuilder(qualifiedAxiomName.getName());
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  termNames=TermHeader(qualifiedAxiomName, context)
  {
    builder.append(termNames);
  } 
  (
    resouceToken=":" 
    ( 
      ParameterDeclaration(qualifiedAxiomName, parserAssembler) 
      {
        builder.append(":parameter");
      }
    )
    |
    ( 
      <LBRACE> 
      AxiomItem(qualifiedAxiomName, context)
      {
        ++index;
      }
      <RBRACE> 
    )+
    {
      builder.append('[').append(Integer.toString(index)).append(']');
    }
  )?
  {
    return builder.toString();
  }
}

String TermHeader(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  String termName;
  StringBuilder builder = new StringBuilder();
  ParserAssembler parserAssembler = context.getParserAssembler();
  parserAssembler.getListAssembler().createAxiomItemList(qualifiedAxiomName);
}
{
  "(" 
  {
    builder.append('(');
  } 
     ( termName=TermName(qualifiedAxiomName, parserAssembler) 
        {
          builder.append(termName);
        }
        ( 
          "," termName=TermName(qualifiedAxiomName, parserAssembler)
          {
            builder.append(',').append(termName);
          } 
        )* 
      )?  
  ")" 
  {
    builder.append(')');
    return builder.toString();
  } 
}

String TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
  Token nameToken;
}
{
  nameToken=<IDENTIFIER>
  {
    parserAssembler.getAxiomAssembler().addAxiomTermName(qualifiedAxiomName, nameToken.image);
    return nameToken.image;
  }
}

void AxiomItem(QualifiedName qualifiedAxiomName, ParserContext context) :
{
}
{
  ( <BIT_OR> )? Fact(qualifiedAxiomName, context) ( LOOKAHEAD(2) ( "," | <BIT_OR> ) Fact(qualifiedAxiomName, context)  )* ( <BIT_OR> )? 
  {
    context.getParserAssembler().getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
  }
}

String Fact(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  Parameter param = null;
  Token lit = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  ( param=LiteralTerm(context) | param=MacroLiteralTerm(context))
  {
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, param);
    return param.getValue().toString();
  }
  |
  <NAN>
  {
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
    return "NaN";
  }
}

List<Template> AxiomList(QualifiedName qualifiedAxiomName, ParserContext context) :
{
  List<Template> templateParamList = new ArrayList<Template>();
  Template template;
}
{
  template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context)
  {
    templateParamList.add(template);
  }
  ( 
    template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, context)
    {
     templateParamList.add(template);
    }
  )*
  {
    return templateParamList;
  }
}

Template AxiomInitializer(String listName, QualifiedName axiomName, ParserContext context) :
{
  Template initializeTemplate = null;
}
{
  <LBRACE> ( initializeTemplate = Parameters(listName, context, true) )? <RBRACE>
  {
     if (initializeTemplate != null)
       return initializeTemplate;
     TemplateArchetype architype = new TemplateArchetype(new QualifiedTemplateName(context.getScope().getAlias(), axiomName.getName()));
     return new Template(architype);
  }
}

void TemplateDeclaration(ParserContext context) :
{
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String listName;
  Token typeToken = null;
  Token privateToken = null;
  QualifiedName contextName = context.getContextName();
}
{
  templateToken=<TEMPLATE> ( "<" (typeToken=<TERM>|typeToken=<AXIOM>) ">" )? template=Template(context, false) 
  ( 
    "+" 
    (
      listName=ListDeclaration(context) 
      {
        context.setQualifiedName(template.getName(), listName);
      }
      |
      CursorDeclaration(context)
    )
  )*
  "(" 
  {
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(templateToken, template.getQualifiedName());
  }
  ( 
    ( privateToken="." )?  
    expression=TemplateExpression(template, context)
    {
      if (privateToken != null)
        expression.setPrivate(true);
      privateToken = null;
      template.addTerm(expression);
      sourceItem = addSourceVariable(expression, context);
    }
  )
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    (
      ( privateToken="." )?  
      expression=TemplateExpression(template, context)
      {
        if (privateToken != null)
          expression.setPrivate(true);
        privateToken = null;
        template.addTerm(expression);
        sourceItem = addSourceVariable(expression, context);
      }
    )
  )* delimitToken=")" 
  {
    context.setContextName(contextName);
    sourceItem.setEnd(delimitToken);
    if (typeToken == null)
      return;
    VariableType varType = new VariableType(typeToken.kind == QueryParserConstants.AXIOM ? OperandType.AXIOM : OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, template.getQualifiedName());
    ParserAssembler parserAssembler = context.getParserAssembler();
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, template.getName());
    itemList.setPublic(true);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }
}

Template Template(ParserContext context, boolean isCalculator) :
{
  Token templateToken;
}
{
  templateToken=<IDENTIFIER>
  { 
    QualifiedName qualifiedTemplateName = new QualifiedTemplateName(context.getScope().getAlias(), templateToken.image);
    context.setContextName(qualifiedTemplateName);
    return context.getParserAssembler().getTemplateAssembler().createTemplate(qualifiedTemplateName, isCalculator); 
  }
}

void CalculatorTemplate(ParserContext context) :
{
  Template template;
  Token calcToken;
  Token delimitToken;
  Operand operand;
  SourceItem sourceItem;
  String listName;
  Token typeToken = null;
  List<Term> termList = new ArrayList<Term>();
  ParserAssembler parserAssembler = context.getParserAssembler();
  QualifiedName contextName = context.getContextName();
}
{ 
  calcToken=<CALC> ( "<" (typeToken=<TERM>|typeToken=<AXIOM>) ">" )? template=Template(context, true) 
  ( 
    "+" 
    (
      listName=ListDeclaration(context) 
      {
        context.setQualifiedName(template.getName(), listName);
      }
      |
      CursorDeclaration(context)
    )
  )*
  "(" 
  {
    context.setTemplateName(template.getQualifiedName());
    context.setSourceMarker(calcToken, template.getQualifiedName());
  }
  ( 
    operand = CalculatorExpression(template, template.getQualifiedName(), context) 
    |
    operand = CalculatorQuery(template, context)
    {
      operand.setPrivate(true);
    }
  )
  {
    sourceItem = addSourceVariable(operand, context);
  }        
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    (  
      operand = CalculatorExpression(template, template.getQualifiedName(), context) 
      |
      operand = CalculatorQuery(template, context)
      {
        operand.setPrivate(true);
      }
    )
    {
      sourceItem = addSourceVariable(operand, context);
    }        
  )* 
  delimitToken=")" 
    {
      sourceItem.setEnd(delimitToken);
    }
  [ TermList(termList, context) ]
  {
    if (termList.size() > 0)
        template.addProperties(termList);
    context.setContextName(contextName);
  }
  {
    if (typeToken == null)
      return;
    VariableType varType = new VariableType(typeToken.kind == QueryParserConstants.AXIOM ? OperandType.AXIOM : OperandType.TERM);
    varType.setProperty(VariableType.AXIOM_KEY, template.getQualifiedName());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, template.getName());
    itemList.setPublic(true);
    parserAssembler.getListAssembler().addItemList(itemList.getQualifiedName(), itemList);
  }
}

Operand TemplateExpression(Template template, ParserContext context) :
{
  SourceItem sourceItem;
  Template innerTemplate;
  Operand var = null;
  Operand lit = null;
  Token scToken = null;
  Operand shortCircuit = null;
  Operand regexOp = null;
  Token selectToken = null;
  Token nameToken = null;
  Token delimitToken = null;
  QualifiedName qname = null;
  Template parameterTemplate = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  (
    var = TemplateTerm(template, context)
    (
      ( scToken=<COLON> | scToken=<QMARK> ) shortCircuit=Expression(context)
      {
        var = new Evaluator(var.getQualifiedName(), shortCircuit, scToken.image, var);
      }
    )?
     {
      return var;
    }
  )
  |
  (
    selectToken=<CHOICE>
    {
      context.onTokenIntercept(selectToken);
    }
    nameToken=<IDENTIFIER>
    (
      "(" ( parameterTemplate = Parameters(nameToken.image, context, false) )? delimitToken=")"
      {
      }
      |
      (
      "{"
      {
        context.pushSourceMarker();
        qname = parserAssembler.getContextName(nameToken.image);
        innerTemplate = parserAssembler.getTemplateAssembler().chainTemplate(template.getQualifiedName());
        context.setSourceMarker(selectToken, innerTemplate.getQualifiedName());
      }
      (
        ( var = TemplateTerm(innerTemplate, context) | lit=Literal(context) )
        ( scToken=<COLON> | scToken=<QMARK> ) shortCircuit=Expression(context)
        {
          if (lit != null)
            var = lit;
          innerTemplate.addTerm(new Evaluator(var.getQualifiedName(), shortCircuit, scToken.image, var));
          sourceItem=addSourceVariable(var, context);
          lit = null;
          var = null;
        }
      )
      ( 
        delimitToken=","
        {
          sourceItem.setEnd(delimitToken);
        }
        ( var = TemplateTerm(innerTemplate, context) | lit=Literal(context) )
        (
          ( scToken=<COLON> | scToken=<QMARK> ) shortCircuit=Expression(context)
          {
            if (lit != null)
              var = lit;
            innerTemplate.addTerm(new Evaluator(var.getQualifiedName(), shortCircuit, scToken.image, var));
            sourceItem=addSourceVariable(var, context);
            lit = null;
            var = null;
          }
        )?
      )+
      delimitToken="}"
      {
        SelectionOperand selectionOperand = new SelectionOperand(qname, innerTemplate);
        sourceItem.setEnd(delimitToken);
        context.popSourceMarker();
        return selectionOperand;
      }
      )
    )?
    {
      return createChoiceOperand(QualifiedName.parseName(nameToken.image), template, parameterTemplate, context);
    }
  )
  |
  ( 
    regexOp = RegularExpression(context) 
    {
      return new Evaluator(regexOp.getLeftOperand().getQualifiedName(), regexOp, "?", regexOp.getLeftOperand());
    }
  )
}

Operand TemplateTerm(Template template, ParserContext context) :
{
  boolean isList = false;
  String name = null;
  QualifiedName qname = null;
  QualifiedName axiomQname;
  String axiomName = null;
  VariableType varType = null;
  Operand var = null;
  Token privateToken = null;
  Token assignToken = null;
  Token equalsToken = null;
  Token interceptToken = null;
  Token notToken = null;
  Operand expression = null;
  Operand shortCircuit = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  ListAssembler listAssembler = parserAssembler.getListAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  List<Parameter> literalList = null;
  List<Template> axiomList = null;
  Template parameterTemplate = null;
}
{
  ( varType=Type(context) )? name=Name(context) 
  {
    qname = parserAssembler.getContextName(name);
    axiomQname = qname;
    isList = (varType == null) && 
             (listAssembler.existsKey(ListType.basic, qname) || 
              listAssembler.existsKey(ListType.axiom_item, qname));
  }
  (  
    listIndexData=IndexExpression(context.getQualifiedName(name), context)
    {
      isList = false;
    } 
  )? 
  ( 
    (
      (  
        ( equalsToken="=" | assignToken=<PLUSASSIGN> )
        ( <AXIOM> 
          ( 
            axiomName=Name(context) 
            {
              axiomQname = QualifiedName.parseName(axiomName);
            }
          ) ? 
          axiomList=AxiomList(axiomQname, context) 
          {
            VariableType axiomListVarType = new VariableType(OperandType.LIST);
            axiomListVarType.setProperty(VariableType.PARAMS, axiomList);
            if (axiomName != null)
              axiomListVarType.setProperty(VariableType.AXIOM_KEY, axiomQname);
            expression = axiomListVarType.getInstance(parserAssembler, axiomQname);
          } 
          |
          expression=Expression(context) 
        )
      )
      |
      ( 
        (   
          assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN> 
        | assignToken=<LSHIFTASSIGN> 
        | assignToken=<RSIGNEDSHIFTASSIGN> 
        | assignToken=<RUNSIGNEDSHIFTASSIGN> 
        )
        expression=Expression(context) 
        {
        }
      )
      |
      ( notToken="!" ) ? interceptToken=<LBRACE> literalList = LiteralList(context) <RBRACE> 
      |
      "(" ( parameterTemplate = Parameters(name, context, true) )? ")"
	  {
	    template.addTerm(parserAssembler.getCallOperand(qname, parameterTemplate));
	  }
    )?
  )
  {
    if ((assignToken != null) && assignToken.image.equals("+=") && listAssembler.existsKey(ListType.axiom_dynamic, qname))
      isList = true;
    if (isList)
      varType = new VariableType(OperandType.APPENDER);
    boolean isDeclaration = varType != null;
    boolean isNot = notToken != null;
    if (isNot)
      interceptToken = notToken;
    boolean hasOperand = operandMap.hasOperand(name, parserAssembler.getQualifiedContextname());
    if (!isDeclaration)
      varType = new VariableType(OperandType.UNKNOWN);
    Operand assignExpression = (assignToken != null) ? expression : null;
    if (assignToken != null)
      expression = null;
    if (expression != null)
      varType.setProperty(VariableType.EXPRESSION, expression);
    if (isList)
      varType.setProperty(VariableType.EXPRESSION, assignExpression);
    if (listIndexData !=null)
      var = listIndexData.length == 1 ? listItemOperand(context, listIndexData[0]) : axiomContainerOperand(parserAssembler, listIndexData);
    else if (literalList != null)
      var = new LiteralListOperand(qname, literalList, isNot);
    else 
      var = operandMap.getOperand(qname);
    if ((var != null) && isDeclaration)
       operandMap.duplicateOperandCheck(qname); 
    if ((var == null) && !hasOperand)
      var = varType.getInstance(parserAssembler, name);
    if (var == null)
      var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
    if ((listIndexData == null) && (!hasOperand))
      operandMap.addOperand(var);
    if ((assignToken != null) && !isList)
      var = parserAssembler.createReflexiveEvaluator(var, assignToken.image, assignExpression);
    if ((equalsToken != null) && ((listIndexData !=null) || (axiomList != null)))
      var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
    else if (hasOperand && (equalsToken != null))
      var = new Evaluator(parserAssembler.getContextName(var.getName() + var.getQualifiedName().incrementReferenceCount()), var, "=", expression);
    if (interceptToken != null)
      context.onTokenIntercept(interceptToken);
      return var;
   }
}

Operand CalculatorExpression(Template template, QualifiedName outerTemplateName, ParserContext context) :
{
  Token delimitToken;
  Token privateToken = null;
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  Operand regexOp = null;
  String operator = "&&";
}
{
  (
    (
      (
        ( scToken=":" { operator = "||"; } | scToken="?" ) 
        {
          context.onTokenIntercept(scToken);
        }  
        expression=Expression(context)
      )
      | 
      regexOp = RegularExpression(context) 
      {
        expression = regexOp;
      }
    )
    ( 
      delimitToken="{"
      {
        Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
        if (regexOp != null)
          innerTemplate.addTerm(new Evaluator(regexOp, operator, Orientation.unary_postfix));
        String shortCut = (scToken != null) ? scToken.image+expression.toString() : regexOp.toString();
        context.addSourceItem(shortCut).setEnd(delimitToken);
        context.pushSourceMarker();
        Token token = Token.newToken(QueryParserConstants.CALC);
        token.beginLine = delimitToken.beginLine;
        token.beginColumn = delimitToken.beginColumn;
        context.setSourceMarker(token, innerTemplate.getQualifiedName());
      }
      innerLoop=InnerCalculator(innerTemplate, outerTemplateName, context, true) 
      {
        context.popSourceMarker();
        context.onTokenIntercept(delimitToken);
      }
    )?  
    {
      if ((regexOp == null) || (innerLoop == null))
        expression = innerLoop == null ? new Evaluator(expression, operator, Orientation.unary_postfix) : new Evaluator(expression, operator, innerLoop);
      else 
        expression = innerLoop;
      expression.setPrivate(true);
      template.addTerm(expression);
      return expression;
    }
  )
  |
  (
    ( privateToken="." )?  
    expression = CalculatorExpression2(template, outerTemplateName, context)
    {
      if (privateToken != null)
        expression.setPrivate(true);
      return expression;
    }
  )
}

Operand CalculatorExpression2(Template template, QualifiedName outerTemplateName, ParserContext context) :
{
  Token literalToken;
  Token delimitToken;
  Token choiceToken;
  Operand expression = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  List<Template> axiomList;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  (
      ( expression=TemplateExpression(template, context) | expression=Expression(context) )
      {
        template.addTerm(expression);
      }
      |
      (
        delimitToken="{"
        {
          context.onTokenIntercept(delimitToken);
          context.pushSourceMarker();
          Template innerTemplate = context.getParserAssembler().getTemplateAssembler().chainTemplate(outerTemplateName);
          Token token = Token.newToken(QueryParserConstants.CALC);
          token.beginLine = delimitToken.beginLine;
          token.beginColumn = delimitToken.beginColumn;
          context.setSourceMarker(token, innerTemplate.getQualifiedName());
        }
        expression=InnerCalculator(innerTemplate, outerTemplateName, context, false)
        {
          context.checkForShortCircuit();
          context.popSourceMarker();
        }
      )
      {
        template.addTerm(expression);
        context.onTokenIntercept(delimitToken);
      }
  )
  {
    return expression;
  }
}

Operand RegularExpression(ParserContext context) :
{
  String inputName = null;
  QualifiedName qname = null;
  Operand inputOp = null;
  Token regexLit = null;
  Token regexId = null;
  Group group = null;
  int flags = 0;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  <REGEX> ( LOOKAHEAD(2) flags=RegexFlags() )? 
  (
    ( "(" inputOp=Expression(context) ")" )
    {
      qname = inputOp.getQualifiedName();
    }
    |
    inputName=Name(context)
    {
      qname = parserAssembler.getContextName(inputName);
    }
  )    
  "==" 
  ( regexLit=<STRING_LITERAL> | regexId=<IDENTIFIER> ) ( LOOKAHEAD(2) group=GroupDeclaration(qname.getName(), parserAssembler) )? 
  {
    Operand regexOp = null;
    if (regexLit != null)
      regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
    else 
      regexOp = parserAssembler.getOperandMap().addOperand(regexId.image, null, parserAssembler.getQualifiedContextname());
    //Operand inputOp = null;
    if (inputName != null)
      inputOp = parserAssembler.getOperandMap().addOperand(inputName, null, parserAssembler.getQualifiedContextname());
    Operand var = new RegExOperand(qname, regexOp, inputOp, flags, group);
    return var;
  }
}

int RegexFlags() :
{
  int flags = 0;
}
{
  "(" 
  ( 
    (
       "unix_lines" { flags |= 0x01; }
     | "case_insensitive" { flags |= 0x02; }
     | "comments" { flags |= 0x04; }
     | "multiline" { flags |= 0x08; }
     | "literal" { flags |= 0x10; }
     | "dotall" { flags |= 0x20; }
     | "unicode_case" { flags |= 0x40; }
     | "canon_eq" { flags |= 0x80; }
     | "unicode_character_class" { flags |= 0x100; }
    )
  )*
  ")"
  {
    return flags;
  }
}

Operand CalculatorQuery(Template template, ParserContext context) :
{
  Token queryToken;
  Token delimitToken;
  String queryName;
  String callName;
  QualifiedName qname;
  QualifiedName outerTemplateName = template.getQualifiedName();
  Template innerTemplate = null;
  Template parameterTemplate = null;
}
{
  queryToken="<-"
  {
    context.onTokenIntercept(queryToken);
    context.pushSourceMarker();
  }
  queryName=Name(context)  
  {
    qname = context.getQualifiedName(queryName);
    callName = qname.getName();
    Token token = Token.newToken(QueryParserConstants.QUERY);
    token.beginLine = queryToken.beginLine;
    token.beginColumn = queryToken.beginColumn;
    context.setSourceMarker(token, queryName);
    context.setSourceItemPending(false);
  }
  "(" ( parameterTemplate = Parameters(callName, context, false) )? delimitToken=")"
  {
    int reference = qname.incrementReferenceCount();
    if (reference > 0)
       qname = new QualifiedName(qname.getName() + reference, qname);
    context.addCalcQuery(qname, parameterTemplate).setEnd(delimitToken);
  }
  ( innerTemplate=InnerTemplateDeclaration(outerTemplateName, callName, context) )?
  {
    Operand queryOperand = context.getParserAssembler().getQueryOperand(queryName, qname, parameterTemplate, innerTemplate);
    template.addTerm(queryOperand);
    context.popSourceMarker();
    return queryOperand;
  }
}

Template InnerTemplateDeclaration(QualifiedName outerTemplateName, String callName, ParserContext context) :
{
  Template template;
  Operand expression;
  Token templateToken;
  Token delimitToken;
  SourceItem sourceItem;
  String queryKey = outerTemplateName.getTemplate() + "." + callName;
}
{
    templateToken="->"
    {
      ParserAssembler parserAssembler = context.getParserAssembler();
      template = parserAssembler.getTemplateAssembler().createQueryTemplate(outerTemplateName, callName);
      template.setKey(queryKey);
      context.onTokenIntercept(templateToken);
    }
    delimitToken="(" 
    {
      context.addSourceItem("-> " + template.getQualifiedName().toString()).setEnd(delimitToken);
    }
      ( 
        expression=TemplateExpression(template, context)
        { 
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
        }
      )
      (
        delimitToken="," 
        {
          sourceItem.setEnd(delimitToken);
        }
        (
          expression=TemplateExpression(template, context)
        {
          template.addTerm(expression);
          sourceItem=context.addSourceItem(expression);
        }
        )
      )* 
      delimitToken=")" 
    {
        sourceItem.setEnd(delimitToken);
        return template;
    }
}

Operand InnerCalculator(Template template, QualifiedName outerTemplateName, ParserContext context, boolean runOnce) :
{

  Operand operand;
  SourceItem sourceItem;
  Token delimitToken;
  context.setSourceItemPending(true);
}
{
  ( 
    operand=CalculatorExpression(template, outerTemplateName, context)
    |
    operand = CalculatorQuery(template, context)
    {
      operand.setPrivate(true);
    }
  )
  {
     sourceItem=addSourceVariable(operand, context);
  }
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    (
      operand=CalculatorExpression(template, outerTemplateName, context)
      |
      operand = CalculatorQuery(template, context)
      {
        operand.setPrivate(true);
      }
    )
    {
      sourceItem=addSourceVariable(operand, context);
    }
  )* 
  delimitToken="}"
  {
    TemplateOperand templateOperand = new TemplateOperand(template, runOnce);
    sourceItem.setEnd(delimitToken);
    return templateOperand;
  }
}

QualifiedName ChoiceDeclaration(ParserContext context) :
{
  Token choiceToken;
  Token nameToken;
  Token delimitToken;
  QualifiedName qualifiedChoiceName;
  Template template;
  String termName;
  int selection = 0;
  boolean isSourceItemPending = context.isSourceItemPending();
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  QualifiedName contextName = context.getContextName();
  StringBuilder builder = new StringBuilder();
}
{
  choiceToken=<CHOICE> nameToken=<IDENTIFIER> 
  {
    qualifiedChoiceName = parserAssembler.getContextName(nameToken.image);
    parserAssembler.getListAssembler().createAxiomItemList(qualifiedChoiceName);
    template = parserAssembler.getTemplateAssembler().createTemplate(qualifiedChoiceName, true);
    context.setContextName(new QualifiedTemplateName(context.getScope().getAlias(), nameToken.image));
    context.setSourceMarker(choiceToken, qualifiedChoiceName);
    builder.append("choice ").append(nameToken.image).append('(');
  }
  "(" 
    termName=TermName(qualifiedChoiceName, parserAssembler)
    {
      builder.append(termName);
    }
    (
      "," termName=TermName(qualifiedChoiceName, parserAssembler) 
    {
      builder.append(',').append(termName);
    }
    )*  
  delimitToken=")" 
  {
    builder.append(')');
    context.addSourceItem(builder.toString()).setEnd(delimitToken); 
  }
  ( ChoiceItem(selection++, qualifiedChoiceName, template, context) )+ 
  {
    context.setContextName(contextName);
    return qualifiedChoiceName;
  }
} 

void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, Template template, ParserContext context) :
{
    Operand operand;
    String fact;
    Token delimToken;
    ParserAssembler parserAssembler = context.getParserAssembler();
    AxiomAssembler axiomAssembler = parserAssembler.getAxiomAssembler();
    String name = axiomAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.getAxiomAssembler().addAxiom(qualifiedAxiomName, new StringTerm(name + selection));
    QualifiedName term0Name = context.getParserAssembler().getContextName(name);
    StringBuilder builder = new StringBuilder();
}
{
   <LBRACE> operand=ChoiceExpression(term0Name, template, context)
   {
     builder.append('{').append(operand.toString());
   }
    ( "," 
      fact=Fact(qualifiedAxiomName, context) 
      {
        builder.append(',').append(fact);
      }
    )* delimToken=<RBRACE> 
    {
       parserAssembler.getAxiomAssembler().saveAxiom(qualifiedAxiomName).getArchetype().clearMutable();
       QualifiedName qualifiedTemplateName = new QualifiedTemplateName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName());
       parserAssembler.getTemplateAssembler().addTemplate(qualifiedTemplateName, operand);
       builder.append('}');
       context.addSourceItem(builder.toString()).setEnd(delimToken);
    }
}

Operand ChoiceExpression(QualifiedName qname, Template template, ParserContext context) :
{
  Operand operand;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
    operand=Literal(context)
    {
      if (operand.getValueClass() == Unknown.class)
        return new BooleanOperand(QualifiedName.ANONYMOUS, true);
      Variable choiceOperand = new Variable(qname); 
      return new Evaluator(parserAssembler.getContextName(qname.getName() + qname.incrementReferenceCount()), choiceOperand, "==", operand);
    }
    |
    operand=Expression(context)
    {
      return operand;
    }
}


void InitialiserList(Map<String, Object> properties, ParserContext context) :
{
  String property;
  SourceItem sourceItem;
  Token delimitToken;
}
{
  "("
  property = InitialiserDeclaration(properties, context)
  {
    sourceItem = context.addSourceItem(property);
  }
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    property = InitialiserDeclaration(properties, context) 
    {
      sourceItem = context.addSourceItem(property);
    }
  )* 
  delimitToken=")"
  {
    sourceItem.setEnd(delimitToken);
  }
}

String InitialiserDeclaration(Map<String, Object> properties, ParserContext context) :
{
  String name;
  Parameter param;
}
{
  name=Name(context) "=" param=LiteralTerm(context)
  {
     properties.put(name, param.getValue());
     return name + "=" + param.getValue().toString();
  }
}

void TermList(List<Term> termList, ParserContext context) :
{
  String property;
  SourceItem sourceItem;
  Token delimitToken;
}
{
  "("
  property = TermDeclaration(termList, context)
  {
    sourceItem = context.addSourceItem(property);
  }
  (
    delimitToken="," 
    {
      sourceItem.setEnd(delimitToken);
    }
    property = TermDeclaration(termList, context) 
    {
      sourceItem = context.addSourceItem(property);
    }
  )* 
  delimitToken=")"
  {
    sourceItem.setEnd(delimitToken);
  }
}

String TermDeclaration(List<Term> termList, ParserContext context) :
{
  Parameter param;
  String name = Term.ANONYMOUS;
}
{
  ( name=Name(context) "=" )? param=LiteralTerm(context)
  {
     termList.add(new Parameter(name, param.getValue()));
     if (name.isEmpty())
       return param.getValue().toString();
     return name + "=" + param.getValue().toString();
  }
}

Group GroupDeclaration(String name, ParserAssembler parserAssembler) :
{
  Group group = new Group(name);
}
{
  "{" Group(group, parserAssembler) ("," Group(group, parserAssembler) )* "}"
  {
    return group;
  }
}

 
void Group(Group group, ParserAssembler parserAssembler) :
{
  Token groupToken;
}
{
  groupToken=<IDENTIFIER> 
  {
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null, parserAssembler.getQualifiedContextname());   
    group.addGroup(var);
  }
}

List<Parameter> LiteralList(ParserContext context) :
{
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
}
{
  parameter=LiteralTerm(context)
  {
    literalList.add(parameter);
  }
  ( 
    "," 
    parameter = LiteralTerm(context) 
    {
      literalList.add(parameter);
    }
  )*
  {
    return literalList;
  }
}

void VariableInitialization(ParserContext context) :
{
  Operand var;
  Token delimitToken;
}
{
    var=VariableDeclaration(context) delimitToken=";" 
    {
      if (var == null)
        return;
      context.getOperandMap().addOperand(var);
      context.setSourceMarker(context.getItemToken(), var.getQualifiedName());
      addSourceVariable(var, context).setEnd(delimitToken);
    }
}

Operand VariableDeclaration(ParserContext context) :
{
  Token nameToken;
  String name;
  boolean isUntyped = true;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  Operand expression = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
  context.setSourceItemPending(true);
}
{
  ( varType=Type(context)
    {
      isUntyped = false;
    }
  )? 
  nameToken=<IDENTIFIER> 
  {
    name = nameToken.image;
    if (isUntyped)
      context.onTokenIntercept(nameToken);
  }
  ( listIndexData=IndexExpression(context.getQualifiedName(nameToken.image), context) )? 
  ( "=" expression=Expression(context) )?
  {
      if ((listIndexData !=null) && (listIndexData.length > 1))
       throw new ParseException("Axiom list variable \"" + name + "\" cannot be declared here");
     if (listIndexData !=null)
       return initList(context, listIndexData[0], expression);
     if (isUntyped)
       varType = new VariableType(OperandType.UNKNOWN);
     if (expression != null) //  Need literal condition? && !(expression instanceof Evaluator)
       varType.setProperty(expression.isEmpty() ? VariableType.EXPRESSION : VariableType.LITERAL, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     return operand;
  }
}

String ListDeclaration(ParserContext context) :
{
  Token keywordToken;
  Token nameToken;
  Token delimitToken;
  String listName;
  Token axiomToken = null;
  Token exportToken = null;
  VariableType varType = null;
  QualifiedName qualifiedAxiomName = null;
  QualifiedName contextName = null;
  Template template = null;
  Template initializeTemplate = null;
  Token beginToken = null;
  Token endToken = null;
  Operand operand = null;
  String target = null;
  SourceItem sourceItem = null;
  List<Template> axiomList;
  ParserAssembler parserAssembler = context.getParserAssembler();
  ListAssembler listAssembler = parserAssembler.getListAssembler();
}
{
  ( ( ( exportToken=<EXPORT> )? keywordToken=<LIST> ) | keywordToken=<LOCAL> ) 
  ( "<" ( varType=Type(context) | axiomToken=<AXIOM> ) ">" )? 
  nameToken=<IDENTIFIER> 
  {
    listName = nameToken.image;
    if (axiomToken != null)
      contextName = context.getContextName();
    if (contextName != null)
      template = createDynamicAxiomTemplate(listName, context);
    if (template != null)
      qualifiedAxiomName = parserAssembler.getContextName(listName);
    context.setSourceMarker(keywordToken, listName);
    context.setSourceItemPending(false);
  }
  (   
    ( "(" 
      ( 
        qualifiedAxiomName=Axiom(context) 
        | 
        ( beginToken=<INTEGER_LITERAL> "," endToken=<INTEGER_LITERAL>) 
      ) 
      ")" 
    )
    |
    ( "=" 
      (
        ( <LBRACE> template=ListParameters(listName, varType, context) <RBRACE> )
        | 
        target=Name(context)
      )
    )  
    |
    (
      axiomList=AxiomList(qualifiedAxiomName, context) 
      ( "(" initializeTemplate = Parameters(listName, context, true) ")" )?
    )
    {
      varType = new VariableType(axiomList.isEmpty() ? OperandType.AXIOM : OperandType.LIST);
      if (axiomList.isEmpty())
        return createAxiomList(qualifiedAxiomName, exportToken !=null, parserAssembler);
      varType.setProperty(VariableType.PARAMS, axiomList);
      if (initializeTemplate != null)
        varType.setProperty(VariableType.TEMPLATE, initializeTemplate);
      if (exportToken !=null)
        varType.setProperty(VariableType.EXPORT, Boolean.TRUE);
      operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
      template.addTerm(operand);
      context.getOperandMap().addOperand(operand);
      sourceItem = context.addSourceItem(operand);
    }
  )?
  delimitToken=";"
  {
    if (contextName != null)
      context.setContextName(contextName);
    if (sourceItem != null)
      sourceItem.setEnd(delimitToken);
    if (target != null)
      listAssembler.mapAxiomList(qualifiedAxiomName, parserAssembler.getContextName(target));
    if ((axiomToken != null) || (target != null))
      return listName;
    boolean isLocal = keywordToken.kind == QueryParserConstants.LOCAL;
    if ((varType == null) && (qualifiedAxiomName == null))
      throw new ParseException("Invalid declaration for list \"" + listName + "\". Missing type or axiom name.");
    if ((varType != null) && isLocal)
      throw new ParseException("Invalid declaration for local \"" + listName + "\". Type in declaration not allowed.");
    if (varType == null)
      varType = isLocal ? new VariableType(OperandType.LOCAL) : new VariableType(OperandType.AXIOM);
    if (qualifiedAxiomName != null)
      varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName);
    ItemList<?> itemList;    
    if (template != null)
      itemList = varType.getDynamicListInstance(parserAssembler, listName, template);
    else
      itemList = varType.getItemListInstance(parserAssembler, listName);
    if (exportToken !=null)
      itemList.setPublic(true);
    if (beginToken != null)
      sizeList(itemList, varType.getOperandType(), Integer.parseInt(beginToken.image), Integer.parseInt(endToken.image));
    listAssembler.addItemList(itemList.getQualifiedName(), itemList);
    if (sourceItem == null)
      context.addSourceItem(itemList).setEnd(delimitToken);
    return listName;
  }
}


void CursorDeclaration(ParserContext context) :
{
  Token keywordToken;
  Token nameToken;
  Token listToken;
  Token delimitToken;
  String cursorName;
  VariableType varType = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  keywordToken=<CURSOR> 
  ( "<" varType=Type(context) ">" )? 
  nameToken=<IDENTIFIER> 
  {
    cursorName = nameToken.image;
    context.setSourceMarker(keywordToken, cursorName);
    context.setSourceItemPending(false);
  }
  "(" listToken=<IDENTIFIER> ")" 
  delimitToken=";"
  {
    QualifiedName listName = context.getQualifiedName(listToken.image);
    QualifiedName qname = parserAssembler.getContextName(cursorName);
    ArrayIndex arrayIndex = new ArrayIndex(listName, 0, "cursor");
    Cursor cursor = new Cursor(qname, listName, arrayIndex);
    ParserTask parserTask = parserAssembler.addPending(cursor);
    parserTask.setPriority(ParserTask.Priority.variable.ordinal());
    parserAssembler.registerCursor(cursorName, varType, cursor);
    context.addSourceItem(cursor.toString()).setEnd(delimitToken);
   }
}

Template ListParameters(String listName, VariableType varType, ParserContext context) :
{
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  Operand var = null;
  if (varType == null)
      throw new ParseException("Invalid declaration for list \"" + listName + "\". Type omitted from declaration.");
}
{ 
  expression=Expression(context)
  { 
    if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
      var = expression;
    if (var == null)
      var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
    template.addTerm(var);
  }
  ( ","
    expression=Expression(context)
    { 
      var = null;
      if (varType.getOperandType() == expression.getOperator().getTrait().getOperandType())
        var = expression;
      if (var == null)
        var = varType.getInstance(parserAssembler, expression.getQualifiedName(), expression);
      template.addTerm(var);
    }
  )*
  {
    return template;
  }
}

void Include(ParserContext context) :
{
  Token includeToken = null;
}
{
  <INCLUDE> includeToken=<STRING_LITERAL>
  {
    includeResource(includeToken.image, context);
  }
}

Operand Expression(ParserContext context) :
{
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
}
{
  param=ConditionalOrExpression(context) 
    ( ( assignToken=<ASSIGN>
        | assignToken=<PLUSASSIGN>
        | assignToken=<MINUSASSIGN>
        | assignToken=<STARASSIGN>
        | assignToken=<SLASHASSIGN>
        | assignToken=<ANDASSIGN>
        | assignToken=<ORASSIGN>
        | assignToken=<XORASSIGN>
        | assignToken=<REMASSIGN>
        | assignToken=<LSHIFTASSIGN>
        | assignToken=<RSIGNEDSHIFTASSIGN>
        | assignToken=<RUNSIGNEDSHIFTASSIGN>
      )
      assignOperand=Expression(context) )?
  {
    if (assignOperand == null)
      return param;
    return new Evaluator(param, assignToken.image, assignOperand);
  }
}

Operand PrimaryExpression(ParserContext context) :
{
  Operand operand;
  QualifiedName qname;
  ListItemSpec[] listIndexData;
  String name = null;
  Token literal = null;
  Operand param1 = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  param1=Literal(context)
  {
    return param1;
  }
  |
  name=Name(context) (LOOKAHEAD(2) param1=NamedExpression(name, context) )?
  {
    if (param1 == null)
        return parserAssembler.addOperand(name);
    return param1;
  }
  |
  literal=<SCOPE> listIndexData=IndexExpression(context.getQualifiedName("scope"), context)
  {
    if (listIndexData.length > 1)
         throw new ParseException("Scope cannot be accessed using axiom list variable");
    operand = listItemOperand(context, listIndexData[0]);
    context.onTokenIntercept(literal);
    return operand;
  }
  |
  "(" ( param1 = Expression(context) ) ")" 
  {
    return param1;
  }
}

ListItemSpec[] IndexExpression(QualifiedName listName, ParserContext context) :
{
  Object index1;
  Object index2 = null;
  int dimension = 1;
}
{ 
   index1 = ListSelection1(context) ( LOOKAHEAD(2)  index2 = ListSelection2(context) { ++dimension; } )?
   {
     if ((dimension == 2) && (index1 instanceof String))
       throw new ParseException("Axiom list \"" + listName.getName() + "\" axiom cannot be selected by name");
     if ((dimension == 1) && (index1 instanceof String))
       return new ListItemSpec[] { new ListIndex(listName, (String)index1) };
     if (dimension == 1)
       return new ListItemSpec[] { new ListIndex(listName, (Operand)index1) };
     ListItemSpec listItemSpec1 = null;
     if (index1 instanceof String)  
         listItemSpec1 = new ListIndex(listName, (String)index1); 
     else
         listItemSpec1 = new ArrayIndex(listName, (Operand)index1); 
     ListItemSpec listItemSpec2 = null;
     if (index2 instanceof String)
       listItemSpec2 = new ListIndex(listName, (String)index2); 
     else
       listItemSpec2 = new ListIndex(listName, (Operand)index2); 
     return new ListItemSpec[] { listItemSpec1, listItemSpec2 };
   }
}

Object ListSelection1(ParserContext context) :
{
  Token name;
  Operand param;
}
{
  ( <LBRACKET> param=Expression(context) <RBRACKET> ) 
  {
    return param;
  }
  | 
  ( <RARROW> name=<IDENTIFIER> )
  {
    return name.image;
  }
}

Object ListSelection2(ParserContext context) :
{
  Token name;
  Operand param;
}
{
  ( <LBRACKET> param=Expression(context) <RBRACKET> ) 
  {
    return param;
  }
  | 
  ( <DOT> name=<IDENTIFIER> )
  {
    return name.image;
  }
}

Operand Literal(ParserContext context) :
{
  Token lit;
  Operand operand;
  boolean flag;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  lit=<INTEGER_LITERAL>
  {
    Long litValue = Long.decode(lit.image);
    operand = new IntegerOperand(QualifiedName.ANONYMOUS, litValue);
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  lit=<FLOATING_POINT_LITERAL>
  {
    operand = new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  lit=<STRING_LITERAL>
  {
    operand = new StringOperand(QualifiedName.ANONYMOUS, getText(lit));
	parserAssembler.registerLocaleListener((LocaleListener) operand);
    context.onTokenIntercept(lit);
    return operand;
  }
  |
  flag=BooleanLiteral(context)
  {
    return new BooleanOperand(QualifiedName.ANONYMOUS, flag);
  }
  |
  UnknownLiteral(context)
  {
    return new NullOperand(QualifiedName.ANONYMOUS, new Unknown());
  }
}

VariableType Type(ParserContext context) :
{
  Token literalToken;
  VariableType varType;
  Token qualifierLit = null;
  String qualifierId = null;
}
{
    literalToken=<INTEGER>
    { 
      varType = new VariableType(OperandType.INTEGER);
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<BOOLEAN>
    { 
      varType = new VariableType(OperandType.BOOLEAN);
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<DOUBLE>
    { 
      varType = new VariableType(OperandType.DOUBLE); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<STRING>
    { 
      varType = new VariableType(OperandType.STRING); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<DECIMAL>
    { 
      varType = new VariableType(OperandType.DECIMAL); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<TERM>
    { 
      varType = new VariableType(OperandType.TERM); 
      context.onTokenIntercept(literalToken);
      return varType; 
    }
|   literalToken=<CURRENCY>
    {
      context.onTokenIntercept(literalToken);
    }
    ( "$" ( qualifierLit=<STRING_LITERAL> | qualifierId=Name(context) ))?
    { 
      varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, context.getOperandMap().addOperand(qualifierId, null, context.getParserAssembler().getQualifiedContextname()));
       return varType; 
    }
}

void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) :
{
}
{
  <PARAMETER>
  {
    parserAssembler.setParameter(qualifiedAxiomName);
  }
}

String Name(ParserContext context) :
{
  String name;
  Token partToken;
}
{
  partToken=<IDENTIFIER> 
  {
    name = partToken.image;
    context.onTokenIntercept(partToken);
  }
  (
    LOOKAHEAD(2)
    "." 
    partToken=<IDENTIFIER>
    {
      name += ("." + partToken.image);
    } 
  )*
  {
    return name;
  }
}

Operand NamedExpression(String name, ParserContext context) :
{
  ListItemSpec[] indexData;
  QualifiedName qname;
  QualifiedName listName;
  ParserTask parserTask;
  Template parametersTemplate = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
}
{
  indexData=IndexExpression(context.getQualifiedName(name), context) 
  {
    return indexData.length == 1 ? 
    listItemOperand(context, indexData[0]) :  
    axiomContainerOperand(parserAssembler, indexData);
  }
  |
  "(" ( parametersTemplate = Parameters(name, context, true) )? ")"
  {
    qname = parserAssembler.getContextName(name);
    return parserAssembler.getCallOperand(qname, parametersTemplate);
  }
  |
  "." 
  (
    <LENGTH>
    {
      listName = context.getQualifiedName(name);
      qname = new QualifiedName(listName.getName() + "_length", listName);
      ListLength listLength = new ListLength(qname, listName);
      parserTask = context.getParserAssembler().addPending(listLength);
      parserTask.setPriority(ParserTask.Priority.variable.ordinal());
      return listLength;
    }
    |
    <FORMAT>
    {
      Operand operand = parserAssembler.addOperand(name);
      qname = parserAssembler.getContextName(name + "_format");
      Scope scope = parserAssembler.getScope();
      FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
      if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
      return formatter;
    }
    |
    <FACT>
    {
      Operand target = parserAssembler.addOperand(name);
      return new FactOperand(target);
    }
  )
}

Template Parameters(String callName, ParserContext context, boolean nameRequired) :
{
  Operand expression;
  QualifiedName outerTemplateName = context.getTemplateName();
  String functionKey = outerTemplateName.getTemplate() + "." + callName;
  ParserAssembler parserAssembler = context.getParserAssembler();
  Template template = parserAssembler.getTemplateAssembler().chainTemplate(outerTemplateName);
  template.setKey(functionKey);
}
{
  ( 
    expression=ParameterExpression(context, nameRequired)
    { 
      template.addTerm(expression);
     }
  )
  (
    "," 
    (
      expression=ParameterExpression(context, nameRequired)
      {
        template.addTerm(expression);
      }
    )
  )* 
  {
    return template;
  }
}

Operand ParameterExpression(ParserContext context, boolean nameRequired) :
{
  Token identifier = null;
  Parameter parameter = null;
  Operand expression = null;
  VariableType varType = null;
  ListItemSpec[] listIndexData = null;
  ParserAssembler parserAssembler = context.getParserAssembler();
  OperandMap operandMap = parserAssembler.getOperandMap();
}
{
  (varType=Type(context))? 
  (
    (identifier=<IDENTIFIER> ( listIndexData=IndexExpression(context.getQualifiedName(identifier.image), context) )?) 
    | 
    parameter=LiteralTerm(context)
  )  
  ( "=" expression=Expression(context))? 
  {
     String name = (identifier == null) ? Term.ANONYMOUS : identifier.image;
     QualifiedName qname = parserAssembler.getContextName(name);
     Operand var = null;
     if (parameter != null)
       var = new Variable(qname);
     if (var != null)
       var.assign(parameter);
     if ((var == null) && (varType == null))
       var = parserAssembler.getOperandMap().getOperand(qname);
     if (var != null)
       return var;
     if (operandMap.hasOperand(name, parserAssembler.getQualifiedContextname()))
         var = operandMap.addOperand(name, expression, parserAssembler.getQualifiedContextname());
     if (var != null)
       {if (true) return var;}
     if (listIndexData !=null)
       var = listIndexData.length == 1 ? listItemOperand(context, name, listIndexData[0]) : axiomContainerOperand(parserAssembler, name, listIndexData);
     if (var != null)
       return var;
     if (varType == null)
       varType = new VariableType(OperandType.UNKNOWN);
     if (varType.getOperandType() == OperandType.TERM)
       varType.setUnknownType();
     if (expression != null)
       varType.setProperty(VariableType.EXPRESSION, expression);
     return varType.getInstance(parserAssembler, name);
  }
}

Parameter LiteralTerm(ParserContext context) :
{
  Token lit;
  Parameter param;
  boolean flag;
}
{
  lit=<INTEGER_LITERAL>
  {
    param = new IntegerTerm(lit.image);
    context.onTokenIntercept(lit);
    return param;
  }
  |
  lit=<FLOATING_POINT_LITERAL>
  {
    param = new DoubleTerm(lit.image);
    context.onTokenIntercept(lit);
    return param;
  }
  |
  lit=<STRING_LITERAL>
  {
    param = new StringTerm(getText(lit));
    context.onTokenIntercept(lit);
    return param;
  }
  |
  flag=BooleanLiteral(context)
  {
    return new BooleanTerm(flag);
  }
  |
  UnknownLiteral(context)
  {
    return new LiteralParameter(Term.ANONYMOUS, new Unknown(), LiteralType.unknown);
  }
}

Parameter MacroLiteralTerm(ParserContext context) :
{
  VariableType varType;
  Parameter literal;
}
{
  varType=Type(context) "(" literal=LiteralTerm(context) ")"
  {
    return varType.getParameter(literal);
  }
  |
  literal=Function(context)
  {
    return literal;
  }
}

Parameter Function(ParserContext context) :
{
  Token name;
  Token library;
  List<Term> termList = new ArrayList<Term>();
}
{
   library=<IDENTIFIER> "." name=<IDENTIFIER> "(" ( TermList(termList, context) )? ")"
   {
     return context.getParserAssembler().callFunction(library.image, name.image, termList);
   }
}

boolean BooleanLiteral(ParserContext context) :
{
  Token lit;
}
{
  lit=<TRUE> 
  { 
    context.onTokenIntercept(lit);
    return true; 
  }
  |
  lit=<FALSE> 
  { 
    context.onTokenIntercept(lit);
    return false; 
  }
}

void UnknownLiteral(ParserContext context) :
{
  Token lit;
}
{
  lit=<UNKNOWN>
  {
    context.onTokenIntercept(lit);
  }
}

Operand ConditionalOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ConditionalAndExpression(context)
  ( 
    op="||" 
    params[1]=ConditionalAndExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand ConditionalAndExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=InclusiveOrExpression(context)
  ( 
    op="&&" 
    params[1]=InclusiveOrExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand InclusiveOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=ExclusiveOrExpression(context)
  ( 
    op="|" 
    params[1]=ExclusiveOrExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand ExclusiveOrExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AndExpression(context)
  ( 
    op="^" 
    params[1]=AndExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AndExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=EqualityExpression(context)
  ( 
    op="&" 
    params[1]=EqualityExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand EqualityExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{ 
  params[0]=RelationalExpression(context)
  ( 
    ( 
    op="==" 
    | 
    op="!=" 
    ) 
    params[1]=RelationalExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand RelationalExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=AdditiveExpression(context)
  ( 
    ( 
    op="<" 
    | 
    op=">" 
    |
    op="<=" 
    | 
    op=">=" 
    ) 
    params[1]=ShiftExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand ShiftExpression(ParserContext context):
{
  Operand[] params = new Operand[2];
  String op;
}
{
  params[0]=AdditiveExpression(context) 
  ( 
    ( 
      "<<" 
      {
        op="<<";
      }
      | 
      RSIGNEDSHIFT() 
      {
        op=">>";
      }
      | 
      RUNSIGNEDSHIFT() 
      {
         op=">>>";
      }
    ) 
    params[1]=AdditiveExpression(context) 
    {
       params[0] = new Evaluator(params[0], op, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand AdditiveExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{ 
  params[0]=MultiplicativeExpression(context)
  (  
    ( 
    op="+" 
    | 
    op="-" 
    ) 
    params[1]=MultiplicativeExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  }
}

Operand MultiplicativeExpression(ParserContext context) :
{
  Operand[] params = new Operand[2];
  Token op;
}
{
  params[0]=UnaryExpression(context)
  ( 
    ( 
    op="*" 
    | 
    op="/" 
    | 
    op="%" 
    ) 
    params[1]=UnaryExpression(context) 
    {
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
  )*
  {
    return params[0];
  } 
}

Operand UnaryExpression(ParserContext context) :
{
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
}
{  
  (
    "+"
    {
      plus = true;
    }
    | 
    "-"
    {
      minus = true;
    }
    |
      "~"
    {
      tilde = true;
    }
  ) 
  param=UnaryExpression(context)
  { 
    if (plus)
      return new Evaluator(param, "+", Orientation.unary_prefix);
    else if (minus)
      return new Evaluator(param, "-", Orientation.unary_prefix);
    else if (tilde)
      return new Evaluator(param, "~", Orientation.unary_prefix);
    return param;
  }
  | 
  param=PreIncrementExpression(context)
  {
    return param;
  }
  |
  param=PreDecrementExpression(context)
  {
    return param;
  }
  |
  param=UnaryExpressionNotPlusMinus(context)
  {
    return param;
  }
}

Operand PreIncrementExpression(ParserContext context) :
{
  Operand param;
}
{ 
  "++" param=PrimaryExpression(context)
  {
    return new Evaluator(param, "++", Orientation.unary_prefix);
  }
}

Operand PreDecrementExpression(ParserContext context) :
{
  Operand param;
}
{
  "--" param=PrimaryExpression(context)
  {
    return new Evaluator(param, "--", Orientation.unary_prefix);
  }
}

Operand UnaryExpressionNotPlusMinus(ParserContext context) :
{
  Operand param;
}
{ 
  "!" param=UnaryExpression(context)
  {
    return new Evaluator(param, "!", Orientation.unary_prefix);
  }
  |
  param=PostfixExpression(context)  
  {
    return param;
  }
}

Operand PostfixExpression(ParserContext context) :
{
  Operand param;
  boolean incr = false;
  boolean decr = false;
}
{ 
  param=PrimaryExpression(context)
  (   
    <INCR>
    {
      incr = true;
    }
    | 
    <DECR>
    {
      decr = true; 
    }
  )?
  {
    if (incr)
       return new Evaluator(param, "++", Orientation.unary_postfix);
    else if (decr)
       return new Evaluator(param, "--", Orientation.unary_postfix);
    return param;
  } 
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((MyToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   ">" ">" ">"
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((MyToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  ">" ">"
  )
}




